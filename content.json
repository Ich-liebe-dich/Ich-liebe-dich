{"pages":[],"posts":[{"title":"2048 Easyx C++图形版感想","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/87370023 一、感想辛苦酝酿好几天，终于做出这2048。虽然功能十分简陋，只能完成其基本功能。但在做这个的时候，还是学到了很多，领悟了很多，发现了自己的许多不足。 二、效果图做的还是感觉可以的，虽然很多功能自己想加上去（音乐、游戏道具等），但权衡利益下先不做了： 2.1 感慨游戏中所有的图形，都是在规划好整体格局，计算好图形坐标，n次调试下完成的。由于我几乎不会用Easyx图形库，很多知识还不懂，其中函数的使用也了解甚少，这使得我的进程非常慢。再加上前期没有规划好，后期又各种加功能，代码格式十分难看。 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190215171313175.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 笔记![在这里插入图片描述](https://img-blog.csdnimg.cn/20190215165838740.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)![在这里插入图片描述](https://img-blog.csdnimg.cn/20190215165914559.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)![在这里插入图片描述](https://img-blog.csdnimg.cn/20190215165948391.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)在这个程序中绘图占了绝大部分，一部分原因是2048算法简单，另一部分是很多地方的确需要大量绘图，况且我也没对算法进行优化。 2.2 主界面用到了Easyx的以下函数 绘制曲边矩形函数 （2048所在矩形） // 画填充圆角矩形(无边框) void solidroundrect(int left, int top, int right, int bottom, int ellipsewidth, int ellipseheight); 绘制矩形函数（菜单选项所在矩形） // 画填充矩形(无边框) void solidrectangle(int left, int top, int right, int bottom); 底行文字 // 在指定区域内以指定格式输出字符串 int drawtext(LPCTSTR str, RECT* pRect, UINT uFormat); 鼠标点击 // 获取一个鼠标消息。如果没有，就等待 MOUSEMSG GetMouseMsg(); 背景颜色 void setbkmode(int mode); // 设置背景混合模式 void setbkcolor(COLORREF color); // 设置当前绘图背景色 void cleardevice(); // 清屏 文字格式 void settextstyle(int nHeight, int nWidth, LPCTSTR lpszFace); 文字颜色&amp;&amp;矩形填充色 void settextcolor(COLORREF color); // 设置当前文字颜色 输出文字 void outtextxy(int x, int y, LPCTSTR str); // 在指定位置输出字符串![在这里插入图片描述](https://img-blog.csdnimg.cn/20190215163806239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)![在这里插入图片描述](https://img-blog.csdnimg.cn/20190215164002372.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 2.3 游戏界面![在这里插入图片描述](https://img-blog.csdnimg.cn/20190215164107580.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)![在这里插入图片描述](https://img-blog.csdnimg.cn/20190215164410227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)游戏结束后方块会消失，方块内的数字将计入总分![在这里插入图片描述](https://img-blog.csdnimg.cn/20190215164426525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)![在这里插入图片描述](https://img-blog.csdnimg.cn/20190215164443549.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)鉴于代码格式十分难看，结构不合理，逻辑我自己都快混了，所以就不放源代码了。源程序： 2048 提取码：lvg9 2019/9/8 更新：代码已上传至Github： Ich-liebe-dich","link":"/2019/02/15/2048 Easyx C++图形版感想/"},{"title":"2的幂 Leetcode231","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/88959505 给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 [ Here ](https://leetcode-cn.com/problems/power-of-two/)示例 1: 输入: 1 输出: true 解释: 2^0 = 1 示例 2: 输入: 16 输出: true 解释: 2^4 = 16 示例 3: 输入: 218 输出: false 这道题本来用穷举写的，结果超超时了…思路：首先这个数一定大于0，其次这其中暗含了一个规律：即对于2的幂n有 （n &amp; -n） == n why？首先明确一个概念：整数的在计算机中二进制表示为补码。8 = 00001000-8 = 111110008 &amp; -8 = 00001000 = 8这是个规律 class Solution { public: bool isPowerOfTwo(int n) { return (n &gt; 0) &amp;&amp; (n &amp; -n) == n; } };ps:似乎做一篇发一篇太水了，以后做到觉得有感受的再总结。","link":"/2019/04/01/2的幂 Leetcode231/"},{"title":"A + B Problem HDU - 1000（水题）","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/84839685 Problem Description: Calculate A + B. Input:Each line will contain two integers A and B. Process to end of file. Output:For each case, output A + B in one line. Sample Input1 1 Sample Output2 问题链接： A + B Problem HDU - 1000 问题简述：计算A+B； Accepted的C++代码如下： #include &lt;iostream&gt; using namespace std; int main() { long a, b, sum = 0; while (cin &gt;&gt; a &gt;&gt; b) { sum = a + b; cout &lt;&lt; sum &lt;&lt; endl; } }","link":"/2018/12/05/A + B Problem HDU - 1000（水题）/"},{"title":"10分钟搭建一个简单的Spring","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/96997112 一、SpringSpring的核心之一：IOC（控制反转），又称依赖注入（DI） 控制反转： 将 创建对象、属性值 的方式 进行了翻转 ，从new、setXxx() 翻转为了 从springIOC容器getBean() 依赖注入：将 属性值 注入给了属性，将属性 注入给了bean，将bean注入给了ioc容器； 简单来讲，SpringIOC就是一个容器，当我们需要对象时直接从里面获取（前提是容器里面有）。 传统方式： Student stu = new Student(); stu.setId(&quot;18000000&quot;);Spring: ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); Student stu = (Student) context.getBean(&quot;stu&quot;);使用Spring后就不用new和一系列set了。 二、Spring两步走配置容器 配置容器时要编写xml文件，为方便编写文件我们需要下载插件，有以下两种方式选择： 下载spring tool suite插件 下载点我 ，下载时注意查看eclipse版本，具体操作网上有很多，这里不讲。 下载STS（Eclipse+插件） 下载点我 ，STS本身就是eclipse，只不过多加了一个插件，操作方式与eclipse类似。 取出对象 三、准备工作开发Spring的基础jar包有6个： spring-aop.jar 开发AOP特性时需要的JAR spring-beans.jar 处理Bean的jar &lt;bean&gt; spring-context.jar 处理spring上下文的jar &lt;context&gt; spring-core.jar spring核心jar spring-expression.jar spring表达式 commons-logging.jar 第三方日志 点我下载jar包 黏贴到src目录下，右键- bulid path即可。 四、编写首先编写一个简单的Student类（ 一系列get和set方法 + 构造器（无参和含参） ），toString()方法可以不重写。 Student.java public class Student { private String id; private String name; private int age; public Student(String id, String name, int age) { super(); this.id = id; this.name = name; this.age = age; } public Student() { } public String toString() { return &quot;id：&quot;+id+&quot; name：&quot;+name+&quot; age：&quot;+age; } //一系列get和set方法Test.java public class Test { public static void main(String[] args) { /* Student stu = new Student(); * stu.setId(&quot;18000000&quot;); * ... * */ //省去 new对象 和 设置属性 两个步骤 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); Student stu = (Student) context.getBean(&quot;stu&quot;); System.out.println(stu); } }applicationContext.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;!-- Spring IOC 容器 --&gt; &lt;!--id:唯一标识符 class:完整类名路径--&gt; &lt;!-- set注入 普通值：value ref--&gt; &lt;bean id=&quot;stu&quot; class=&quot;com.test.entity.Student&quot;&gt; &lt;property name=&quot;id&quot; value=&quot;18000000&quot;&gt;&lt;/property&gt; &lt;property name=&quot;name&quot; value=&quot;sss&quot;&gt;&lt;/property&gt; &lt;property name=&quot;age&quot; value=&quot;0&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt;id：随便取个名字作为标识符，取对象时要用到class：完整类名路径name：类中的属性名称value：对应属性的值 就这样一个简单的Spring就搭建好了！","link":"/2019/07/23/10分钟搭建一个简单的Spring/"},{"title":"A+B问题 HDU-2101","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/84842018 A+B问题 HDU-2101时限：1000 ms 内存限制：32768 kBOS：窗 来源：HDU 2007-6编程比赛 Problem Description：This problem is also a A + B problem,but it has a littledifference,you should determine does (a+b) could be divided with 86.Forexample ,if (A+B)=98,you should output no for result. Input：Each line will contain two integers A and B. Process to end of file. Output：For each case, if(A+B)%86=0,output yes in one line,else output no inone line. Sample Input：1 18600 8600 Sample Output：noyes 问题链接： A+B问题 HDU-2101 问题描述：给出多组数据（A和B），问A+B是否能整除86，若能，输出“yes”，反之输出“no”(不包括双引号）.问题分析：简单的运算和判断语句的使用，有两个点要注意：（1）有多组数据；（2）判断两数是否相等时，应使用逻辑运算符“==“，而不是赋值运算符”=”。AC代码如下： #include &lt;iostream&gt; using namespace std; int main() { long A, B; while (cin &gt;&gt; A &gt;&gt; B) { if ((A + B) % 86 == 0) cout &lt;&lt; &quot;yes&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;no&quot; &lt;&lt; endl; } }","link":"/2018/12/05/A+B问题 HDU-2101/"},{"title":"ASCII码排序 HDU - 2000","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/84840338 ASCII码排序 HDU - 2000Time limit:1000 ms Memory limit ：32768kBOS ：Windows Source: C语言程序设计练习（一） Problem Description：输入三个字符后，按各字符的ASCII码从小到大的顺序输出这三个字符。 Input：输入数据有多组，每组占一行，有三个字符组成，之间无空格。 Output：对于每组输入数据，输出一行，字符中间用一个空格分开。 Sample Input： qweasdzxc Sample Output： e q wa d sc x z 问题链接： ASCII码排序 HDU - 2000 问题简述：输入3个字符，按AsCII升序排列，测试数据有多组。问题分析:本题选用了选择排序法将字符进行排序选择排序法的思路如下： *第1趟，在待排序记录r[1] r[n]中选出最小的记录，将它与r[1]交换；第2趟，在待排序记录r[2]r[n]中选出最小的记录，将它与r[2]交换；以此类推，第i趟在待排序记录r[i]~r[n]中选出最小的记录，将它与r[i]交换，使有序序列不断增长直到全部排序完毕。* 简单来说就是遍历字符串，以升序排序为例，在第1次排序中，第一个元素与其他元素相互比较，若第一个元素比之后遍历到的对应元素要大，则交换他们的值，每一趟排序都找出最小值并放在第一个位置，第2趟排序则从第二个元素开始遍历，以此类推。（个人理解，如有错误，欢迎纠正）动图如下： AC的C++代码如下： #include &lt;iostream&gt; using namespace std; int main() { char a[3]; int i; while (cin &gt;&gt; a)//选择排序 { for (i = 0; i &lt; 3; i++) { for (int j = i + 1; j &lt; 3; j++) { if (a[i] &gt; a[j]) { char temp = a[i]; a[i] = a[j]; a[j] = temp; } } } i = 0; while (a[i])//输出排序后的字符串 { if (i &lt; 2) cout &lt;&lt; a[i] &lt;&lt; &quot; &quot;; else cout &lt;&lt; a[i]; i++; } cout &lt;&lt; endl; } }","link":"/2018/12/05/ASCII码排序 HDU - 2000/"},{"title":"C C++ 打印三角形","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86700593 打印三角形是C语言的经典例题，首先我们先看看效果图。 一、直角三角形ok，现在从最简单的打印直角三角形开始。通过以上效果图你会发现规律： 行数 * 的个数 1 1 2 2 3 3 4 4 5 5 … … n n 根据以上规律写出以下代码： #include &lt;stdio.h&gt; int main() { int i, j; int LINE; scanf(&quot;%d&quot;, &amp;LINE); for (i = 1; i &lt;= LINE; i++)//直角三角形 { for (j = 0; j &lt; i; j++) { printf(&quot;*&quot;); } printf(&quot;\\n&quot;); } return 0; }在代码中 i 对应的循环控制（外层循环）着行数，j 对应的循环（内层循环）控制着每一行中*的个数。 二、等边三角形同样地，等边三角形也有规律。 行数 空格的个数 * 的个数 1 n 1 2 n-1 3 3 n-2 5 4 n-3 7 … … … n 1 2n+1 根据规律写出代码 #include &lt;stdio.h&gt; int main() { int i, j; int LINE; scanf(&quot;%d&quot;, &amp;LINE); for (i = 0; i &lt; LINE; i++)//等边三角形 { for (j = 0; j &lt; (LINE - i); j++) { printf(&quot; &quot;); } for (j = 0; j &lt; 2 * i + 1; j++) { printf(&quot;*&quot;); } printf(&quot;\\n&quot;); } return 0; }三、菱形学会了等边三角形的打印，菱形自然也不难。菱形是由两个等腰三角形组成的。 #include &lt;stdio.h&gt; int main() { int i, j; int LINE; scanf(&quot;%d&quot;, &amp;LINE); for (i = LINE - 2; i &gt;= 0; i--) { for (j = 0; j &lt; (LINE - i); j++) { printf(&quot; &quot;); } for (j = 0; j &lt; 2 * i + 1; j++) { printf(&quot;*&quot;); } printf(&quot;\\n&quot;); } return 0; }四、杨辉三角规律： 每行最左边和最右边都是1 从第二行起，中间的每一个数是上一行里相邻两个数之和 第n行有n个数字 我们用二维数组表示杨辉三角中的数字，结合规律得到以下代码 #include &lt;stdio.h&gt; #define MAX 10 int main() { int i, j; int LINE; int array[MAX][MAX] = { 0 }; scanf(&quot;%d&quot;, &amp;LINE); //cin &gt;&gt; LINE; for (i = 0; i &lt; LINE; i++) { array[i][0] = 1; printf(&quot;%d &quot;, array[i][0]); //cout &lt;&lt; array[i][0] &lt;&lt; &quot; &quot;; for (j = 1; j &lt;= i; j++) { array[i][j] = array[i-1][j] + array[i-1][j - 1]; printf(&quot;%d &quot;, array[i][j]); //cout&lt;&lt;array[i][j]&lt;&lt;&quot; &quot;; } printf(&quot;\\n&quot;); //cout &lt;&lt; endl; } return 0; }","link":"/2019/01/30/C C++ 打印三角形/"},{"title":"C C++获取系统时间","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/87860088 方法一C++版本： #include &lt;iostream&gt; #include &lt;ctime&gt; int main() { time_t timer; time(&amp;timer); tm *t_tm = localtime(&amp;timer); int year = t_tm-&gt;tm_year + 1900;//年 int month = t_tm-&gt;tm_mon + 1;//月 int day = t_tm-&gt;tm_mday;//日 int hour = t_tm-&gt;tm_hour;//时 int minute = t_tm-&gt;tm_min;//分 int second = t_tm-&gt;tm_sec;//秒 int wday = t_tm-&gt;tm_wday;//一周中的第几天 int yday = t_tm-&gt;tm_yday;//一年中的第几天 std::cout &lt;&lt; year &lt;&lt; &quot;/&quot; &lt;&lt; month &lt;&lt; &quot;/&quot; &lt;&lt; day &lt;&lt; std:: endl; std::cout &lt;&lt; hour &lt;&lt; &quot;:&quot; &lt;&lt; minute &lt;&lt; &quot;:&quot; &lt;&lt; second &lt;&lt; std::endl; std::cout &lt;&lt; wday &lt;&lt; &quot; &quot; &lt;&lt; yday &lt;&lt; &quot; &quot; &lt;&lt; std::endl; /*直接输出时间*/ std::cout&lt;&lt;asctime(t_tm)&lt;&lt;std::endl; }C版本：C版本与C++相同，头文件改为 time.h 输出时改为printf()语句即可 printf(&quot;%d/%d/%d \\n&quot;,year,month,day); printf(%s\\n&quot;, asctime(t_tm));方法二此方法时间可精确至毫秒 #include &lt;Windows.h&gt; #include &lt;iostream&gt; int main() { SYSTEMTIME sys; GetLocalTime(&amp;sys); std::cout &lt;&lt; sys.wYear &lt;&lt; &quot;/&quot; &lt;&lt; sys.wMonth &lt;&lt; &quot;/&quot; &lt;&lt; sys.wDay &lt;&lt; std::endl; std::cout &lt;&lt; sys.wHour &lt;&lt; &quot;:&quot; &lt;&lt; sys.wMinute &lt;&lt; &quot;:&quot; &lt;&lt; sys.wSecond &lt;&lt; &quot;:&quot; &lt;&lt; sys.wMilliseconds &lt;&lt; std::endl; }可输出的数据如下：运用以上两个方法输出时间如下：![在这里插入图片描述](https://img-blog.csdnimg.cn/2019022114171572.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)","link":"/2019/02/21/C C++获取系统时间/"},{"title":"C++ MFC ListBox SetItemData出现的错误","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/93651308 SetItemData的基本用法：假设ListBox关联的控件变量为 list ,类名为 Student：我起初是这样做的： for (int i = 0; i &lt; stu_manage.getSize(); i++) { //对象必需是new出来的，而不是栈中的对象 Student *p = &amp;stu_manage.get(i); int nIndex = list.AddString(CString(p-&gt;getName())); list.SetItemData(nIndex, (DWORD_PTR)p); } 注：stu_manage.get(i)返回的是一个Student对象 结果list保存的对象里面没有任何值，只有乱码…最终发现SetItemData中的 指针引用的对象必需是new出来的，而不是栈中的对象 。于是修改： //对象必需是new出来的，而不是栈中的对象 Student temp = stu_manage.get(i); Student *p = new Student(temp.getId(),temp.getName(),temp.getCScore(),temp.getMathScore(),temp.getSex(),temp.getAge(),temp.getAddress()); int nIndex = list.AddString(CString(p-&gt;getName())); list.SetItemData(nIndex, (DWORD_PTR)p);大功告成！","link":"/2019/06/25/C++ MFC ListBox SetItemData出现的错误/"},{"title":"C++ 文件删除注释","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/89430355 读取一个cpp文件，删除里面的所有注释，生成一个新的cpp文件。 在这里我用的是一行一行地读取，写的稍微有点复杂，将单行注释与多行注释分开来写了。实际上可以一个一个读取。 思路就是判断是不是注释里面的内容，若不是，则写入新文件。 #include &lt;iostream&gt; #include &lt;fstream&gt; #include &lt;Windows.h&gt; #include &lt;tchar.h&gt; using namespace std; bool deleteSingle(const char*, const char *); void deleteMulti(const char *, const char *); bool deleteAll(const char *, const char *); int main() { deleteAll(&quot;ConsoleApplication45.cpp&quot;, &quot;test.cpp&quot;); } bool deleteSingle(const char * oldFileSrc, const char * newFileSrc) { fstream oldfile(oldFileSrc, ios::in); fstream newfile(newFileSrc, ios::out); if (oldfile.is_open() &amp;&amp; newfile.is_open()) { const int size = 250; //设定每行的缓存大小 char temp[size]; oldfile.seekg(0, ios::beg); //指针移向文件头 while (oldfile.getline(temp, size)) //逐行读取，遇单行注释则终止 { for (int i = 0; i &lt; size; i++) { if (temp[i] == &apos;/&apos;&amp;&amp;temp[i + 1] == &apos;/&apos;) { temp[i] = 0; } } newfile &lt;&lt; temp &lt;&lt; endl; } oldfile.close(); newfile.close(); return true; /*删除单行注释成功*/ } else { cout &lt;&lt; &quot;源文件无法打开或无法创建新文件，请重试！\\n&quot;; return false; } } void deleteMulti(const char * oldFileSrc, const char * newFileSrc) { fstream oldfile(oldFileSrc, ios::in); fstream newfile(newFileSrc, ios::out); if (oldfile.is_open() &amp;&amp; newfile.is_open()) { const int size = 250; char temp[size]; bool meetFlag = false; //是否遇到了多行注释的标记 oldfile.seekg(0, ios::beg); while (oldfile.getline(temp, size)) { int i; for (i = 0; i &lt; size - 1; i++) { if (temp[i] == &apos;\\n&apos;) break; /* 没遇见标记前，检测标记 */ if (!meetFlag &amp;&amp; temp[i] == &apos;/&apos; &amp;&amp; temp[i + 1] == &apos;*&apos;) { temp[i] = 0; meetFlag = !meetFlag; //遇见了标记，故重置标记 } if (temp[i] == &apos;*&apos; &amp;&amp; temp[i + 1] == &apos;/&apos;) //找到了标记的结束位置 { meetFlag = !meetFlag; //重置标记 int j, k; for (j = i + 2, k = 0; j &lt; size; j++) //写入结束标记后的文字 { if (temp[j] == &apos;\\n&apos;) break; temp[k++] = temp[j]; } temp[--j] = 0; } } if (!meetFlag) //在注释标记间的文字不写入 { newfile &lt;&lt; temp &lt;&lt; endl; } } oldfile.close(); newfile.close(); } } bool deleteAll(const char *oldFileSrc, const char *newFileSrc) { bool success = deleteSingle(oldFileSrc, &quot;temp.cpp&quot;); if (success) { deleteMulti(&quot;temp.cpp&quot;, newFileSrc); DeleteFile(_T(&quot;temp.cpp&quot;)); //删除缓存文件 return true; } DeleteFile(_T(&quot;temp.cpp&quot;)); return false; }","link":"/2019/04/21/C++ 文件删除注释/"},{"title":"C++ 模板类 单链表","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/89300263 C++作业，用模板类写链表，完成了对基本的单链表的插入，删除等。 #include &lt;iostream&gt; using namespace std; template&lt;typename T&gt; struct Node { T data; Node&lt;T&gt; *next; }; template&lt;typename T&gt; class LinkedList { public: LinkedList() { size = 0; first = NULL; } ~LinkedList(); T find(int index); //返回索引对应的值 void remove(int index); //删除 void insert(T value); //插入在链表最后一位 void insert(int index, T value); //指定位置插入 void print(); //打印链表 int length() const; //获取链表长度 private: Node&lt;T&gt; *first; //头结点 int size; //链表长度 bool checkRange(int index); //检测索引合法性 Node&lt;T&gt;* getNode(int index); //返回索引位置节点 }; template&lt;typename T&gt; bool LinkedList&lt;T&gt;::checkRange(int index) { if (index &lt;0 || index &gt; size - 1) return false; return true; } template&lt;typename T&gt; Node&lt;T&gt;* LinkedList&lt;T&gt;::getNode(int index) { if(!checkRange(index)) { return NULL; } Node&lt;T&gt;* head = first; for (int i = 0; i &lt; index; i++) { head = head-&gt;next; } return head; } template&lt;typename T&gt; void LinkedList&lt;T&gt;::insert(T value) { if (first == NULL) { Node&lt;T&gt; *newNode = new Node&lt;T&gt;; newNode-&gt;data = value; first = newNode; first-&gt;next = NULL; size++; } else { Node&lt;T&gt; *head = getNode(size-1); Node&lt;T&gt; *newNode = new Node&lt;T&gt;; newNode-&gt;data = value; newNode-&gt;next = head-&gt;next; head-&gt;next = newNode; size++; } } template&lt;typename T&gt; void LinkedList&lt;T&gt;::insert(int index, T value) { if (!checkRange(index)) //忽略索引为负值 { return; } if (index == 0) { Node&lt;T&gt;* newNode = new Node&lt;T&gt;; newNode-&gt;data = value; newNode-&gt;next = first; first = newNode; size++; } else { Node&lt;T&gt;* head = getNode(index-1); Node&lt;T&gt;* newNode = new Node&lt;T&gt;; newNode-&gt;data = value; newNode-&gt;next = head-&gt;next; head-&gt;next = newNode; size++; } } template&lt;typename T&gt; void LinkedList&lt;T&gt;::print() { Node&lt;T&gt; *list = first; cout &lt;&lt; &quot;[&quot;; while (list != NULL) //判断当前位置是否存在节点 { cout &lt;&lt; list-&gt;data &lt;&lt; &quot; &quot; ; list = list-&gt;next; } cout &lt;&lt; &quot;]&quot; &lt;&lt; endl; } template&lt;typename T&gt; int LinkedList&lt;T&gt;::length() const { return size; } template&lt;typename T&gt; LinkedList&lt;T&gt;::~LinkedList() { if (first != NULL) { Node&lt;T&gt; *list = NULL, *cache = NULL; list = first; while (list != NULL) { cache = list-&gt;next; delete list; list = NULL; list = cache; } } } template&lt;typename T&gt; T LinkedList&lt;T&gt;::find(int index) { if (!checkRange(index)) return NULL; Node&lt;T&gt; *head = getNode(index); return head-&gt;data; } template&lt;typename T&gt; void LinkedList&lt;T&gt;::remove(int index) { if(!checkRange(index)) return; if (index == 0) { Node&lt;T&gt;* head = first; first = head-&gt;next; size--; } else { Node&lt;T&gt;* head = getNode(index - 1); head-&gt;next = (head-&gt;next)-&gt;next; size--; } } int main() { LinkedList&lt;int&gt; a; cout &lt;&lt; &quot;测试是否完成删除:&quot;; a.print(); a.insert(0); a.insert(1); a.insert(-1, 1); //自动忽略 a.insert(2); a.insert(3); a.insert(4); a.print(); cout &lt;&lt; &quot;在索引2位置插入10:&quot;; a.insert(2, 10);a.print(); cout &lt;&lt; &quot;在索引0位置插入112:&quot;;a.insert(0, 112);a.print(); cout &lt;&lt; &quot;移除索引2:&quot;; a.remove(2);a.print(); cout &lt;&lt; &quot;移除索引0:&quot;;a.remove(0);a.print(); cout &lt;&lt; &quot;移除最后一个索引:&quot;; a.remove(a.length() - 1); a.print(); cout &lt;&lt; &quot;索引0的值:&quot; &lt;&lt; a.find(0) &lt;&lt; endl &lt;&lt; &quot;索引3的值:&quot; &lt;&lt; a.find(3) &lt;&lt; endl &lt;&lt; &quot;最后一位:&quot; &lt;&lt; a.find(a.length() - 1); }","link":"/2019/04/14/C++ 模板类 单链表/"},{"title":"C++函数","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/85396214 一、概述C++语言有两种编程模块：函数与类。函数是功能的抽象，函数主要有两个作用：一是任务划分，把一个复杂的任务划分为若干个简单的小任务，便于分工和处理；二是软件重用。 二、如何使用一个函数？ 提供函数定义 提供函数原型 调用函数以下是个简单的例子： #include &lt;iostream&gt; using namespace std; int Add(int,int);//函数原型 int main() { int a,b; cin &gt;&gt; a &gt;&gt;b; cout &lt;&lt; Add(a,b) &lt;&lt;endl;//函数调用 } int Add(int a,int b)//函数定义 { return (a+b); }1.定义函数函数可分为两类：没有返回值的函数和有返回值的函数。通用格式如下： typename Name(parameterList) { statement(s); return value; //value的值与typename有关 }其中parameterList是函数参数的数量与类型。当函数定义为void类型时，return语句不带返回表达式或者不使用return语句。 2.函数原型如果函数定义出现在程序第一次调用之前，则不需要函数声明，因为此时函数定义就具有函数原型的作用。否则，函数原型要写在主函数之前。 为什么需要原型？函数的原型告诉了编译器函数返回值的类型，参数的类型和数量。当你在调用函数时，若函数的参数类型或个数出现错误，编译器就能捕获这种错误。其次，知道了函数的返回值类型后，编译器才知道应该检索多少个字节以及如何解释他们。 3.参数传递的机制 形参：函数定义首部的参数形参出现在函数定义中，在整个函数体内都可以使用， 离开该函数则不能使用。 实参：调用函数时使用的参数 三种参数传递机制：值传递、指针传递和引用传递。 #include &lt;iostream&gt; using namespace std; void A(int, int); int main() { int a = 1, b = 2; cout &lt;&lt; &quot;调用函数前:&quot;; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; A(a, b);//a和b为实参 cout &lt;&lt; &quot;调用函数后:&quot;; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b; } void A(int a, int b) { a = 2 * a;//a和b为实参 b = 2 * b; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; }以上代码的运行结果如下：由此可知，调用函数后a和b的值并没有发生变化。 这是因为在函数调用时，实参的值copy到形参，在函数内的所有操作都是对形参进行的。以上函数的实参和形参为非指针类型，那么当它们为指针类型会发生什么？ #include &lt;iostream&gt; using namespace std; void A(int *, int *); int main() { int a = 1, b = 2; cout &lt;&lt; &quot;调用函数前:&quot;; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl; A(&amp;a, &amp;b); cout &lt;&lt; &quot;调用函数后:&quot;; cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b; } void A(int *a, int *b) { *a = 2 * *a; *b = 2 * *b; cout &lt;&lt; *a &lt;&lt; &quot; &quot; &lt;&lt; *b &lt;&lt; endl; }形参与实参的区别： 1.形参变量只有在被调用时才分配内存单元，在调用结束时， 即刻释放所分配的内存单元。因此，形参只有在函数内部有效。函数调用结束返回主调函数后则不能再使用该形参变量。 2.实参可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。因此应预先用赋值，输入等办法使实参获得确定值。 3.实参和形参在数量上，类型上，顺序上应严格一致， 否则会发生“类型不匹配”的错误。 4.函数调用中发生的数据传送是单向的。 即只能把实参的值传送给形参，而不能把形参的值反向地传送给实参。因此在函数调用过程中，形参的值发生改变，而实参中的值不会变化。 5.当形参和实参不是指针类型时，在该函数运行时，形参和实参是不同的变量，他们在内存中位于不同的位置，形参将实参的内容复制一份，在该函数运行结束的时候形参被释放，而实参内容不会改变。 而如果函数的参数是指针类型变量,在调用该函数的过程中，传给函数的是实参的地址，在函数体内部使用的也是实参的地址，即使用的就是实参本身。所以在函数体内部可以改变实参的值。 三、内联函数与重载函数1、内联函数 （1）作用：降低小程序调用开销（2）注意事项：a.递归函数不能定义为内联函数 b.内联函数一般适合于不存在while和switch等复杂的结构且只有1~5条语句的小函数上，否则编译系统将该函数视为普通函数。 c.内联函数只能先定义后使用，否则编译系统也会把它认为是普通函数。 d.对内联函数不能进行异常的接口声明。2、重载函数函数重载是指以同一个名字命名多个函数的实现版本。重载函数的参数列表至少满足以下条件之一：&lt;1&gt;参数个数不同&lt;2&gt;参数类型不同。函数返回的类型不是重载条件,例： int average(int,int); double average(int,int); //此时编译器认为函数重复说明","link":"/2018/12/30/C++函数/"},{"title":"C++基本数据类型","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/85385087 一、数据类型C++的数据类型有四类：基本类型，结构类型，指针类型(*)和空类型(void)。![在这里插入图片描述](https://img-blog.csdnimg.cn/2018123013530844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 二、部分基本数据类型说明1.整型（1）int整数就是没有小数点部分的数字，如2、98、-100和0。在C++中提供多种整型，按示数范围分为短整数（short int）、有符号短整数（signedshort int）、无符号短整数（unsigned short int）、有符号整数（signed int）、无符号整数（unsignedint）、长整数（long int）、有符号长整数（signed long int）、无符号长整数（unsigned long int）等。整型可以是十进制，也可以是八进制和十六进制。 通过前缀指定基数： 不带前缀默认为十进制 0代表八进制 0x或0X代表十六进制如： 023 //合法，等于十进制19 078 //非法，8不属于八进制的数字 0xFF //合法，等于十进制255 0xFH //非法，H不属于十六进制的数字也可以带后缀： 4234L //长整数 24324U //无符号整数 343UL//无符号长整数（2）boolC++的逻辑类型用关键字bool定义，true或false。（3）enum枚举类型。2.浮点型有两种示数方式：小数示数法和指数示数法。指数示数法的格式： 尾数 E或e 指数 其中尾数可以是整数或小数，但指数必须是整数，尾数和指数都不能忽略。 小数示数法如下： 13.89 .638 //均合法 -452.指数示数法如下： 12E8 21324E-3 .618e3 e-7//非法，缺少尾数 .E10//非法，缺少尾数 1e2.5//非法，指数部分应为整数3.字符型C++中字符的表示方式有多种，对于常规字符，一般用单引号将字符括起，如： &apos;A&apos; &apos;a&apos; &apos;5&apos; &apos; &apos; &apos;!&apos; 也可以在ASCII码的八进制、十六进制前加上转义符反斜杠“\\”来表示，如： &apos;\\101&apos; &apos;\\x41&apos;//都可以表示&apos;A&apos; ’\\12&apos; &apos;\\x0A&apos;//都可以表示换行有些字符不能直接通过键盘直接输入到程序里，如回车键不能使字符串包含一个换行符。在C++中用转义字符表示他们。 字符名称 C++代码 换行符 \\n 水平制表符 \\t 垂直制表符 \\v 振铃 \\a 反斜杠 \\\\ 单引号 \\’ 双引号 &quot; 注意：“x”,”A”不属于字符，他们属于字符串。 三、定义常量在C++中有两种方式：第一：#define预处理器 #define N 10第二：使用const关键字 const int N = 10;在C++中推荐使用第二种方式。","link":"/2018/12/30/C++基本数据类型/"},{"title":"C++数组","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/85404286 一、一维数组数组声明时应指出以下三点： 存储在每个元素的值的类型 数组名 数组中的元素个数 通用格式 ：typeName arrayName[arratSize]初始化 ： 只有在定义数组时才能初始化 int a[4] = {1,2,3,4}; int b[4]; b[4] = {1,2,3,4} //错误 b = a; //错误 初始化数组时([])内可以为空int a[] = {1,2,3,4,5}; 初始化时可以只对部分初始化，未初始化的值将被设置为0。 数组的下标从0开始，所以数组的最后一个元素为a[N - 1]。** 用不同方式访问数组** #include &lt;iostream&gt; using namespace std; int main() { int a[] = {1,3,5,7,9},i,*p; for(i = 0;i &lt; 5;i++) //下标访问 { cout &lt;&lt; &quot;a[&quot; &lt;&lt; i &lt;&lt; &quot;]=&quot; &lt;&lt; a[i] &lt;&lt; &apos;\\t&apos; ; } cout &lt;&lt; endl; for(p = a,i = 0;i &lt; 5;i++)//指针变量下标访问 { cout &lt;&lt; &quot;a[&quot; &lt;&lt; i &lt;&lt; &quot;]=&quot; &lt;&lt; p[i] &lt;&lt; &apos;\\t&apos; ; } cout &lt;&lt; endl; for(i = 0;i &lt; 5; i++) //指针方式访问 { cout &lt;&lt; &quot;a[&quot; &lt;&lt; i &lt;&lt; &quot;]=&quot; &lt;&lt; *(a + i) &lt;&lt; &apos;\\t\\; } cout &lt;&lt; endl; for(p = a;p&lt; a + 5;p++)//指针变量间址访问 { cout &lt;&lt; &quot;a[&quot; &lt;&lt; p - a &lt;&lt; &quot;]=&quot; &lt;&lt; a[p - a] &lt;&lt; &apos;\\t&apos;; } cout &lt;&lt; endl; }二、二维数组表达式 ：类型 数字名 [表达式1][表达式2] 第一维是行，第二维是列。 int a[2][3] = {{1,2,3},{4,5,6}}; int a[2][3] = {1,2,3,4,5,6}; 可以只对部分元素初始化 int x[2][3] = {{1,2},{3}} 可以省略高数组的最高维长度说明 int ad[][3] = {1,2,3,4,5,6}; int at[][2][3] = {1,2,3,4,5,6,7,8,9,10,11,12};但不能写成 int ad[2][] = {1,2,3,4,5,6}; int at[2][][3] = {1,2,3,4,5,6,7,8,9,10,11,12};三、动态存储1. 动态存储 ：根据需要在程序运行时建立和撤销对象。2. new 和 delete 操作符一般语法形式： 指针变量 = new 类型 delete 指针变量如： int *p1 = new int(0); char *p2 = new char; float *p3 = new float; //... delete p1; delete p2; delete p3;申请动态数组，释放空间用delete[]操作： int *p4 = new int [4]; delete []p4;四、字符串1. 用字符数组存放字符串(1)逐个字符对数组元素赋初始值 char str1[10] = {&apos;S&apos;,&apos;t&apos;,&apos;u&apos;,&apos;d&apos;,&apos;e&apos;,&apos;n&apos;,&apos;t&apos;};(2)用串常量初始化 char str2[10] = {&quot;Student&quot;}; char str3[] = {&quot;Student&quot;); char str4[] = &quot;Student&quot;;注意：C++对串常量自动添加结束标志’\\0’，所以str2[7] = ‘\\0’，str2的长度为8。2.字符串处理函数头文件：cstring（string.h） 函数 说明 strlen(Str) 计算有效字符的个数，空字符不包含在内 strcpy(Des,Src) 串复制，将Src所指向的字符串复制到Des中 strcat(Des,Src) 串连接 strcmp(Str1,Str2) 串比较。以字典顺序方式比较两个字符串。若相等，返回0；若Str1大于Str2，则返回正数；若Str1小于Str2，则返回负数。","link":"/2018/12/30/C++数组/"},{"title":"C++星空","text":"//Star.h #pragma once #include &lt;graphics.h&gt; #include &lt;conio.h&gt; #include &lt;ctime&gt; #define SCREEN_WIDTH 1920 #define SCREEN_HEIGHT 1080 #define MAXSTAR 1080 class Star { protected: double m_x = 0; int m_y; double m_step; int m_color; void Draw(); void NewPos(); void Remove(); public: Star(){} ~Star(){} void Init(); void Move(); }; //Star.cpp #include &quot;Star.h&quot; void Star::Init() { if (m_x == 0) { m_x = rand() % SCREEN_WIDTH; } else { m_x = 0; } m_y = rand() % SCREEN_HEIGHT; m_step = (rand() % 5000) / 1000.0 + 1; m_color = (int)(m_step * 255 / 6.0 + 0.5); //m_color = RGB(m_color*255, 255, m_color * 255);//绿色 //m_color = RGB(254, m_color * 255, m_color * 255);橘红 m_color = RGB(m_color * 255, m_color * 255, 255);//蓝色 } void Star::Move() { Remove(); NewPos(); Draw(); } void Star::Draw() { putpixel((int)m_x, m_y, m_color); } void Star::NewPos() { m_x += m_step; if (m_x &gt; SCREEN_WIDTH) { this-&gt;Init(); } } void Star::Remove() { putpixel((int)m_x, m_y, 0); } //presentation.cpp #include &quot;Star.h&quot; int main() { srand((unsigned)time(NULL)); initgraph(SCREEN_WIDTH, SCREEN_HEIGHT); Star star[MAXSTAR]; for (int i = 0; i &lt; MAXSTAR; i++) { star[i].Init(); } while (!_kbhit()) { for (int i = 0; i &lt; MAXSTAR; i++) { star[i].Move(); } Sleep(30); } closegraph(); return 0; }","link":"/2019/01/27/C++星空/"},{"title":"C++程序控制结构","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/85389725 一、语句程序设计语言的语句按功能可以分为三类：说明语句，操作语句，控制语句。控制语句用于控制语句的执行流程。所有程序都只包含3种控制结构： _顺序结构 _ 、 _选择结构 _ 和 _循环结构 _ 。 二、选择结构C++使用if语句和switch语句构成选择结构。1.if语句（1）一个分支的if语句 if(x&gt;0) cout&lt;&lt;x&lt;&lt;endl;(2)if-else语句 if(x&gt;y) { cout&lt;&lt;&quot;max = &quot;&lt;&lt;x; } else { cout&lt;&lt;&quot;max = &quot;&lt;&lt;y; }(3)if语句的嵌套C++规定，else总是与它接近的if配对。 注意： 区分”=“和”==” “=”是赋值运算符 “==”是逻辑运算符 int a = 2; int b = 3; if(a=b)//错误，无论a和b的值如何改，结果都将是a=b { cout&lt;&lt;&quot;a = b&quot;&lt;&lt;endl; } else { cout&lt;&lt;&quot;a != b &quot;&lt;&lt;endl; } 浮点数的比较由于浮点数具有一定的误差，比较两个浮点数是否相等的方法应为if(fabs(a-b)&lt;精度） float a = 2.0000000000000000000000000001; float b = 2.00000000000000000000000001; if (a == b) { cout &lt;&lt; &quot;a = b&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;a != b &quot; &lt;&lt; endl; }//运行结果为a=b2.switch语句switch语句的形式如下： switch(表达式) { case 常量表达式1： 语句1; case 常量表达式2： 语句2; ... case 常量表达式n: 语句n; //default: 语句n+1; } 常量表达式必须互不相同 各个case和default出现的次序可以任意。在每个case分支都带有break的情况下，case的顺序不影响执行结果。 switch语句可以嵌套。 switch语句根据一个表达式不同的可能值作选择执行，它适用于条件判断比较简单的多路选择。3.?:运算符通用格式：expression1?expression2:expression3 int a = 2; int b = 3; cout&lt;&lt;&quot;max=&quot;&lt;&lt;(a&gt;b?a:b)&lt;&lt;endl;二、循环控制循环结构有while语句、do-while语句和for语句。一般循环结构包含三个部分：循环的初始化、循环条件和循环体。设计循环时必须要明确循环的算法是什么，进入循环的条件是什么，结束循环的条件是什么。 while(表达式) { //循环体 } do { //循环体 }while(表达式); for([表达式1];[表达式2]:[表达式3]) { //循环体 //表达式1，2，3皆可省略 //表达式1：通常用于变量的初始化 //表达式2：循环控制表达式 //表达式3:循环体之后执行 }三、转向语句C++中的转向语句主要有：break,continue,return和goto语句。1.break语句break语句无条件结束switch语句或循环语句2.continue语句continue语句用于循环体中，终止当前一次循环，不执行continue的后续语句，转向循环入口继续执行。3.return语句返回表达式的值，并中断函数的执行。4.goto语句无条件转向语句，在C++中滥用goto语句将降低程序的可读性与可维护性。在不破坏程序基本流程控制的情况下，可以适当使用goto语句实现必要的跳转。","link":"/2018/12/30/C++程序控制结构/"},{"title":"DBCP 与 c3p0 连接池的简单使用","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/96482385 一、概览结构图：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190719154923279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)jar包的位置：WEB-INF/lib 和 src配置文件位置：src 二、配置c3p0 和 DBCP 连接池都有两种方法配置： 配置文件配置c3p0配置文件：c3p0-config.xmldbcp配置文件：dbcpconfig.properties 直接在代码中配置 c3p0配置 public class C3P0Demo { public static DataSource getDataSourceWithC3P0(){ ComboPooledDataSource c3p0 = new ComboPooledDataSource(); try { c3p0.setDriverClass(&quot;com.mysql.cj.jdbc.Driver&quot;); } catch (PropertyVetoException e) { e.printStackTrace(); } c3p0.setJdbcUrl(&quot;jdbc:mysql://localhost:3306/db_stu?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&quot;); c3p0.setUser(&quot;root&quot;); c3p0.setPassword(&quot;root&quot;); return c3p0 ; } public static DataSource getDataSourceWithC3P0ByXml(){ ComboPooledDataSource c3p0 = new ComboPooledDataSource(&quot;yanqun&quot;); return c3p0 ; } public static void main(String[] args)throws Exception { System.out.println(getDataSourceWithC3P0().getConnection()); System.out.println(getDataSourceWithC3P0ByXml().getConnection()); } }c3p0-config.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;c3p0-config&gt; &lt;default-config&gt; &lt;!-- 如果要研究某个xml中可以设置哪些属性。找相关类的 属性 或者setXxx()--&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/db_stu?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;useSSL=false&amp;amp;serverTimezone=Asia/Shanghai&lt;/property&gt; &lt;property name=&quot;checkoutTimeout&quot;&gt;20000&lt;/property&gt; &lt;/default-config&gt; &lt;named-config name=&quot;yanqun&quot;&gt; &lt;property name=&quot;user&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;password&quot;&gt;root&lt;/property&gt; &lt;property name=&quot;driverClass&quot;&gt;com.mysql.cj.jdbc.Driver&lt;/property&gt; &lt;property name=&quot;jdbcUrl&quot;&gt;jdbc:mysql://localhost:3306/db_stu?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;useSSL=false&amp;amp;serverTimezone=Asia/Shanghai&lt;/property&gt; &lt;property name=&quot;checkoutTimeout&quot;&gt;20000&lt;/property&gt; &lt;/named-config&gt; &lt;/c3p0-config&gt;说明：jdbcUrl一栏中的原来的 &amp; 改用 &amp;amp; DBCP配置 public class DbcpDemo { public static DataSource getDataSourceWIthDBCP(){ BasicDataSource dbcp = new BasicDataSource(); dbcp.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;); dbcp.setUrl(&quot;jdbc:mysql://localhost:3306/db_stu?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&quot;); dbcp.setUsername(&quot;root&quot;); dbcp.setPassword(&quot;root&quot;); dbcp.setInitialSize(20); dbcp.setMaxActive(10); return dbcp; } public static DataSource getDataSourceWIthDBCPByProperties() throws Exception{ DataSource dbcp = null ; Properties props = new Properties(); InputStream input = new DbcpDemo().getClass().getClassLoader().getResourceAsStream(&quot;dbcpconfig.properties&quot;); props.load( input ); dbcp = BasicDataSourceFactory.createDataSource(props ) ; return dbcp; } public static void main(String[] args) throws Exception { DataSource ds = getDataSourceWIthDBCP(); DataSource ds1 = getDataSourceWIthDBCPByProperties(); System.out.println(ds); System.out.println(ds1); } }dbcpconfig.properties driverClassName=com.mysql.cj.jdbc.Driver url=jdbc:mysql://localhost:3306/db_stu?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai username=root password=root initialSize=10","link":"/2019/07/19/DBCP 与 c3p0 连接池的简单使用/"},{"title":"George and Accommodation  CodeForces - 467A","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/84839351 CodeForces - 467AProblem Description:George has recently entered the BSUCP (Berland State University for CoolProgrammers). George has a friend Alex who has also entered the university.Now they are moving into a dormitory.George and Alex want to live in the same room. The dormitory has n rooms intotal. At the moment the i-th room has pi people living in it and the room canaccommodate qi people in total (pi ≤ qi). Your task is to count how many roomshas free place for both George and Alex. InputThe first line contains a single integer n (1 ≤ n ≤ 100) — the number ofrooms.The i-th of the next n lines contains two integers pi and qi (0 ≤ pi ≤qi ≤ 100) — the number of people who already live in the i-th room and theroom’s capacity. OutputPrint a single integer — the number of rooms where George and Alex can movein. Sample Input1 12 23 3Sample Output0 Sample Input31 100 1010 10Sample Output2 问题链接： https://vjudge.net/problem/CodeForces-467A 问题描述：George和Alex想住在一起，现有n个房间，每个房间的人数和可居住人数分别为pi和qi，问他们有多少种住房选择。 问题分析：可居住人数减去房间内的人数之差大于等于2时，这个房间可作为一种选择。通过建立一个二维数组a[i][2],（i+1表示房间的总个数，a[i][0]表示第i+1个房间内的人数，a[i][1]表示第i+1房间可容纳的最大人数。），可将题目中出现的未知量表示出来。 Accepted的C++代码如下： #include &lt;iostream&gt; using namespace std; int main() { int n,m,count; int a[100][2]; cin &gt;&gt; n; m = n;//m用于计算输入的次数 while (m)//输入未知量 { cin&gt;&gt;a[m - 1][0]&gt;&gt;a[m-1][1]; m--; } count = 0;//统计方案个数 for (m = 0; m &lt; n; m++) { if (a[m][1] - a[m][0] &gt;= 2) count++; } cout &lt;&lt; count; }","link":"/2018/12/05/George and Accommodation  CodeForces - 467A/"},{"title":"IDEA引入jar包的正确方式","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/96481760 1.java项目：和eclipse一样2.web项目： jar本身就只在运行阶段有效ojdbc.jar只需要复制WebContent/lib/中即可。 jar在各个阶段均有效要复制Web-Content/lib/中即可再复制到src中，右键-Add as library…运行阶段才有效 : Class.forName(“驱动名”);不需要用到其中的类各个阶段有效 :要用到jar包中的类， BasicDataSource dbcp = new BasicDataSource();","link":"/2019/07/19/IDEA引入jar包的正确方式/"},{"title":"JDK 和 eclipse 的安装（搬砖）","text":"JDK 和 eclipse 的安装（搬砖）为了防止自己将来忘记，也为了与其他人分享，在这里贴上资源。 里面的JDK和eclipse的版本是相对应的，并且含有汉化包 环境变量的配置 附：eclipse的安装及汉化：1.下载文件后解压到桌面（便于查找，其他文件夹也可以，但要记住位置）；2.打开中文包所在的文件夹，发现有两个子文件夹，复制这两个文件夹；3.转到eclipse所在文件夹，里面有一个dropin的文件夹，打开dropin，黏贴；4.打开eclipse，发现已经汉化。（在安装eclipse前要先安装jdk，并配置环境变量）。","link":"/2018/12/11/JDK 和 eclipse 的安装（搬砖）/"},{"title":"JNDI","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/96424424 一、如何理解JNDI JNDI学习总结 二、在Tomcat中使用JNDI打开Tomcat目录下的conf\\context.xml D:\\Sogou\\apache-tomcat-9.0.16-windows-x64\\apache-tomcat-9.0.16\\conf\\context.xml![在这里插入图片描述](https://img-blog.csdnimg.cn/20190718100854612.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)添加 &lt;Environment name=&quot;jndiName&quot; value=&quot;jndiValue&quot; type=&quot;java.lang.String&quot; /&gt;name用于取数据，value是数据的值，type是类型 建立一个Web项目： &lt;%@ page import=&quot;javax.naming.Context&quot; %&gt; &lt;%@ page import=&quot;javax.naming.InitialContext&quot; %&gt; &lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% Context ctx = new InitialContext(); String name = (String)ctx.lookup(&quot;java:comp/env/jndiName&quot;); %&gt; &lt;%=name%&gt; &lt;/body&gt; &lt;/html&gt;","link":"/2019/07/18/JNDI/"},{"title":"JSP内置response对象小结","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/89513685 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190425120757216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 比较out对象与response对象的区别：&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; import=&quot;java.io.*&quot; %&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;ISO-8859-1&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% out.println(&quot;&lt;h3&gt;jsp内置对象之response对象&lt;/h3&gt;&quot;); out.println(&quot;&lt;br&gt;欧拉欧拉欧拉欧拉欧拉&lt;br&gt;&quot;); //out.flush(); PrintWriter outer = response.getWriter(); outer.println(&quot;&lt;hr&gt;&quot;); out.println(&quot;编码方式：&quot;+response.getCharacterEncoding()); %&gt; &lt;/body&gt; &lt;/html&gt;运行效果如下：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190425121251958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 如图，使用response对象输出的内容总是在out对象前面 删掉注释后运行如下：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190425121538513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 比较请求转发与请求重定向![在这里插入图片描述](https://img-blog.csdnimg.cn/20190425120857466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)main.jsp: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; import=&quot;java.io.*,java.util.*&quot; %&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;% out.println(&quot;&lt;h2&gt;请求重定向与请求转发&lt;/h2&gt;&quot;); //response.sendRedirect(&quot;test.jsp&quot;); request.getRequestDispatcher(&quot;test.jsp&quot;).forward(request,response); %&gt; &lt;/body&gt; &lt;/html&gt;test.jsp: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form action=&quot;post.jsp&quot; method=&quot;POST&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot;/&gt; &lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; /&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt;post.jsp: &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;p&gt;姓名： &lt;% String name = new String((request.getParameter(&quot;name&quot;)).getBytes(&quot;ISO-8859-1&quot;),&quot;UTF-8&quot;); %&gt; &lt;%= name %&gt; &lt;/p&gt; &lt;/li&gt; &lt;li&gt;&lt;p&gt;密码： &lt;%= request.getParameter(&quot;password&quot;) %&gt; &lt;/p&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt;请求重定向后的地址：请求转发地址：","link":"/2019/04/25/JSP内置response对象小结/"},{"title":"Java File类","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/89302838 File 类File 类在Java中表示 文件 或 文件夹（目录） 。 1.1 访问文件名相关方法 String getName() 文件名或路径名,若为路径名，返回最后一级子路径名 String getPath() File getAbsoluteFile() String getAbsolutePath() String getParent() boolean renameTo(File newFile) 重命名 1.2文件检测相关方法 boolean exists() boolean canWrite() boolean canRead() boolean isFile() boolean isDirectory() boolean isAbsolute() 1.3 文件常规信息 long lastModified() long length() 1.4 目录操作 boolean mkdir() String[] list() File[] listFiles() static File[] listRoots() 示例示例1 文件过滤器import java.io.File; import java.io.FilenameFilter; public class FileDemo { public static void main(String[] args) { File file = new File(&quot;C:\\\\Users\\\\DELL\\\\Desktop\\\\新建文件夹 (2)&quot;); String[] nameList = file.list(new MyFileNameFilter()); for(String name:nameList) { System.out.println(name); } } } class MyFileNameFilter implements FilenameFilter{ @Override public boolean accept(File str, String name) { // TODO Auto-generated method stub return name.endsWith(&quot;.jpg&quot;)||new File(name).isDirectory(); } } 实现 FilenameFilter 接口里的 accept()方法，accept()方法里是你过滤文件的标准。 Java中路径的分隔符有两个：’ / ’ 或使用转义字符 ‘ \\\\ ’ File类常见的构造方法有两种 File(String filename) File(String directoryPath,String filename) 示例2 输出文件的一些信息import java.io.File; import java.io.IOException; import java.text.SimpleDateFormat; import java.util.Date; public class testFile { public static void main(String[] args) throws IOException { File a = new File(&quot;1.txt&quot;); if(!a.exists()) { //文件不存在则创建文件 a.createNewFile(); System.out.println(&quot;创建文件!&quot;); } System.out.println(&quot;文件的绝对路径是：&quot;+a.getAbsolutePath()); long time = a.lastModified(); System.out.println(&quot;文件的上次修改时间是：&quot;+LongToDate(&quot;yyyy-MM-dd HH:mm:ss&quot;,time)); } public static String LongToDate(String DataFormat,long millSec) { SimpleDateFormat sdf = new SimpleDateFormat(DataFormat); Date date = new Date(millSec); return sdf.format(date); } }结果 文件的绝对路径是：C:\\Users\\DELL\\eclipse-workspace\\Test\\1.txt 文件的上次修改时间是：2019-04-20 23:03:14 调用第一种构造方法时，观察文件路径，它位于创建的Java项目的目录下![在这里插入图片描述](https://img-blog.csdnimg.cn/20190420235346462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 由于File类的 lastModified() 方法返回的是一个long 所以在以上代码中通过 SimpleDateFormat 做了一个格式化 示例3import java.io.File; public class testmkdir { public static void main(String[] args) { File file = new File(&quot;/one/test.txt&quot;); file.mkdir(); if(file.exists()) { //创建失败，因为one目录不存在 System.out.println(&quot;使用mkdir创建成功&quot;); } file.mkdirs(); if(file.exists()) { //成功 System.out.println(&quot;使用mkdirs创建成功&quot;); } } }","link":"/2019/04/21/Java File类/"},{"title":"Java IO流","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/89430091 字节流与字符流 Click 缓冲流BufferedInputStream 和 BufferedOutputStream这两个流是缓冲字节流，通过内部缓存数组来提高操作流的效率。（包装其他流，加上了缓冲的功能） 构造方法：BufferedInputStream(Reader in) BufferedOutputStream(Writer out) 同理有缓冲字节流 BufferedReader 与 BufferedWriter 注： readLine()方法是BufferedReader特有的方法，可以对文本文件进行更加方便的读取操作。 写入一行后要记得使用newLine()方法换行。 随机流随机流兼具I / O 功能，可读可写 RandomAccessFile(String name,String mode) RandomAccessFile(File file,String mode) mode 有两种可选：r(只读） rw(可读可写) 数据流数据流， DataInputStream 与 DataOutputStream ，可存取Java基本数据类型与字符串类型。 字节数组流ByteArrayInputStream 和 ByteArrayOutputStream 对象流ObjectInputStream / ObjectOutputStream是以“对象”为数据源，但是必须将传输的对象进行序列化与反序列化操作。（实现Serializable接口）","link":"/2019/04/21/Java IO流/"},{"title":"Java Integer测试","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/88616250 /** * * @author DELL * 1.返回为某类型：byteValue(),intValue(),shortValue(),toString() * 2.比较两个数：compareTo(),equals() * 3.valueOf(),parseInt() * 4.常量：MIN_VALUE,MAX_VALUE,SIZE,TYPE */ public class TestInteger { public static void main(String[] args) { /**************分割线*******************/ int a = 1; //基本数据类型 Integer b = new Integer(&quot;1&quot;); Integer c = Integer.valueOf(11); //官方推荐写法,int-&gt;Integer int _c = Integer.valueOf(1); int d = b.intValue(); //Integer-&gt;int String e = c.toString(); //Integer-&gt;String String f = c.toBinaryString(c); Integer g = Integer.parseInt(&quot;231&quot;); //String-&gt;Integer / int int _g = Integer.parseInt(&quot;231&quot;); System.out.println(&quot;Integer表示范围：&quot;+Integer.MIN_VALUE+&quot; ~ &quot;+Integer.MAX_VALUE); /***************分割线*****************/ Integer test1 = 2;//自动装箱，编译器解释为Integer test1 = Integer.vauleOf(2); int test2 = test1;//自动拆箱，编译器解释为int test2 = test1.intValue(); /***************分割线****************/ //缓存[-128,127]之间的数字，实际就是系统初始化时，创建了[-128,127]之间的一个换内存数组. //当我们调用valueOf时，收件检查是否在缓存之间，如果在则直接调用。不在则创建新的对象。 Integer in1 = -128; Integer in2 = -128; System.out.println(in1 == in2);//true 因为123在缓存范围内 System.out.println(in1.equals(in2));//true Integer in3 = 1234; Integer in4 = 1234; System.out.println(in3 == in4);//false 因为1234不在缓存范围内 System.out.println(in3.equals(in4));//true } }","link":"/2019/03/17/Java Integer测试/"},{"title":"Java Student类","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86694914 用Java写了一个简单的Student类，可以输出每个学生的信息，计算学生的平均分，以及获取学生成绩的最大值与最小值。运行效果如下：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190129201540264.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)这个类的成员变量有 String 型的 sNO,sName,sSex 与整型的 sAge,sJava，分别表示学号、姓名、性别、年龄和Java成绩。构造方法是带参数的。类的成员方法有 getNo() getName() getSex()getAge() getPoint() 这几个都用于返回成员变量的值，除此之外还有3个静态方法： doublegetAverageScore(Student arr[])、char judge(double point) 和 getMaxAndMin(Studentarr[]) 。代码如下： public class Student { String sNO,sName,sSex; int sAge,sJava; public Student(String num,String name,String sex,int age,int point){//构造函数 sNO = num; sName = name; sSex = sex; sAge = age; sJava = point; } public static char judge(double point){//返回分数对应等级 if(point &lt;= 100 &amp;&amp; point &gt;= 90){ return &apos;S&apos;; } else if(point &lt; 90 &amp;&amp; point &gt;= 80){ return &apos;A&apos;; } else if(point &lt; 80 &amp;&amp; point &gt;= 70){ return &apos;B&apos;; } else if(point &lt; 70 &amp;&amp; point &gt;= 60){ return &apos;C&apos;; } else{ return &apos;D&apos;; } } public static double getAverageScore(Student arr[]){//计算平均分 double sum = 0; int i; for(i = 0;i&lt;arr.length;i++){ sum += arr[i].sJava; } return sum / arr.length; } public static void getMaxAndMin(Student arr[]){//计算最大值与最小值 int max = -1; int min = 100; for(int i = 0;i&lt;arr.length;i++){ if(arr[i].sJava &gt; max) max = arr[i].sJava; } for(int i = 0;i&lt;arr.length;i++){ if(arr[i].sJava &lt; min){ min = arr[i].sJava; } } System.out.println(&quot;\\tMax: &quot;+max+&quot; &quot;+judge(max)); System.out.println(&quot;\\tMin: &quot;+min+&quot; &quot;+judge(min)); } public String getNO(){ return sNO; } public String getName(){ return sName; } public String getSex(){ return sSex; } public int getAge(){ return sAge; } public int getPoint(){ return sJava; } public static void main(String[] args) { //初始化 Student[] student = new Student[10]; student[0] = new Student(&quot;201900001&quot;,&quot;test1&quot;,&quot;女&quot;,18,88); student[1] = new Student(&quot;201900002&quot;,&quot;test2&quot;,&quot;女&quot;,18,97); student[2] = new Student(&quot;201900003&quot;,&quot;test3&quot;,&quot;男&quot;,19,89); student[3] = new Student(&quot;201900004&quot;,&quot;test4&quot;,&quot;男&quot;,20,96); student[4] = new Student(&quot;201900005&quot;,&quot;test5&quot;,&quot;女&quot;,19,88); student[5] = new Student(&quot;201900006&quot;,&quot;test6&quot;,&quot;男&quot;,19,82); student[6] = new Student(&quot;201900007&quot;,&quot;test7&quot;,&quot;女&quot;,20,83); student[7] = new Student(&quot;201900008&quot;,&quot;test8&quot;,&quot;男&quot;,20,89); student[8] = new Student(&quot;201900009&quot;,&quot;test9&quot;,&quot;女&quot;,19,90); student[9] = new Student(&quot;201900010&quot;,&quot;test10&quot;,&quot;男&quot;,18,88); //显示信息 System.out.println(&quot;\\t\\t\\t学生信息表&quot;); System.out.println(&quot;\\t学号\\t\\t姓名\\t性别\\t年龄\\t成绩&quot;); for(int i = 0;i&lt;student.length;i++){ System.out.print(&quot;\\t&quot;+student[i].getNO()+&quot;\\t&quot;+student[i].getName()); System.out.println(&quot;\\t&quot;+student[i].getSex()+&quot;\\t&quot;+student[i].getAge()+&quot;\\t&quot;+student[i].getPoint()); } Student.getMaxAndMin(student); System.out.println(&quot;\\t平均得分:&quot;+Student.getAverageScore(student) +&quot;(&quot;+Student.judge(Student.getAverageScore(student))+&quot;)&quot;); System.out.println(&quot;\\t总人数:&quot;+student.length); } }","link":"/2019/01/29/Java Student类/"},{"title":"Java Swing简易的计算器","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/90301412 1.编写程序，创建如下图所示的图形界面。（要求实现功能）![在这里插入图片描述](https://img-blog.csdnimg.cn/20190517221626799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)最终效果图：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190517221734917.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)源代码： import java.awt.BorderLayout; import java.awt.Color; import java.awt.Font; import java.awt.GridLayout; import java.awt.TextField; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JPanel; import javax.swing.JTextPane; public class MyCaluator extends JFrame{ /** * */ private static final long serialVersionUID = 1L; MyCaluator(String title){ super(title); //JPane以BorderLayout的形式布局 JPanel p1 = new JPanel(); JPanel p2 = new JPanel(); JPanel p3 = new JPanel(); Font myFont1 = new Font(&quot;serif&quot;,Font.BOLD,28); Font myFont2 = new Font(&quot;arial&quot;,Font.PLAIN,24); JPanel[] panel = {p1,p2,p3}; Color[] color = {Color.pink,Color.cyan,Color.magenta}; for(int i = 0;i &lt; panel.length;i++) { panel[i].setBackground(color[i]); panel[i].setLayout(new GridLayout(3,1)); } //JPanel1 的组件 JLabel p1_text1 = new JLabel(&quot; 加数1: &quot;); JLabel p1_text2 = new JLabel(&quot; 加数2: &quot;); p1_text1.setFont(myFont1); p1_text2.setFont(myFont1); p1.add(p1_text1); p1.add(p1_text2); JButton p1_btn = new JButton(&quot;求和&quot;); p1.add(p1_btn); p1_btn.setFont(new Font(&quot;Dialog&quot;, Font.PLAIN, 18)); //JPanel2 的组件 TextField txt1 = new TextField(); TextField txt2 = new TextField(); TextField txt3 = new TextField(); txt1.setFont(myFont2); txt2.setFont(myFont2); txt3.setFont(myFont2); p2.add(txt1); p2.add(txt2); p2.add(txt3); //JPanel3 的组件 JLabel p3_txt1 = new JLabel(&quot; &quot;); JLabel p3_txt2 = new JLabel(&quot; &quot;); p3_txt1.setFont(myFont1); p3_txt2.setFont(myFont1); p3.add(p3_txt1); p3.add(p3_txt2); JButton p3_btn = new JButton(&quot;清除&quot;); p3.add(p3_btn); p3_btn.setFont(new Font(&quot;Dialog&quot;, Font.PLAIN, 18)); //设置JFrame，添加3个Panel add(BorderLayout.WEST,p1); add(BorderLayout.CENTER,p2); add(BorderLayout.EAST,p3); setBackground(Color.pink); setBounds(400,300, getDefaultCloseOperation(), getDefaultCloseOperation()); setSize(500,400); setVisible(true); //按钮 求和 的事件： p1_btn.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { String num1 = txt1.getText(); String num2 = txt2.getText(); //判断是否为空 if(&quot;&quot;.equals(num1)) { txt1.requestFocus(); return; } if(&quot;&quot;.equals(num2)) { txt2.requestFocus(); return; } //判断是否为字符串 boolean num1_legal = JudgeUtil.isDoubleOrFloat(num1); boolean num2_legal = JudgeUtil.isDoubleOrFloat(num2); if(num1_legal&amp;&amp;num2_legal) { double num_1 = Double.parseDouble(num1); double num_2 = Double.parseDouble(num2); Double num_3 = num_1 + num_2; txt3.setText(num_3.toString()); }else { txt3.setText(&quot;请输入一个数字！&quot;); } } }); //按钮 清空 的事件： p3_btn.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent action) { txt1.setText(&quot;&quot;); txt2.setText(&quot;&quot;); txt3.setText(&quot;&quot;); } }); } public static void main(String[] args) { MyCaluator m = new MyCaluator(&quot;A simple caluator&quot;); } } class JudgeUtil{ //工具类，判断字符串是否为数字 public static boolean isDoubleOrFloat(String str) { return str.matches(&quot;-?[0-9]+.*[0-9]*&quot;); } }","link":"/2019/05/17/Java Swing简易的计算器/"},{"title":"Java 字节流&字符流","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/89428910 两者的区别Java字节流对应的类为 InputStream 与 OutputStream ，操作时以字节 (byte) 为单位。 由于Java的编码方式为 Unicode，中文对应的是两个字节，因此在使用字节流操作时若操作不当，会出现乱码的情况。于是字符流出现了。Java子节流对应的类为 Reader 与Writer ，操作时以字符 (char) 为单位。 InputStream 与 OutputStreamInputStream 与 OutputStream 在使用文件操作时使用的是他们的子类： FileInputStream 与FileOutputStream .接下来简单介绍一下他们的子类的构造方法 FileInputStream(String name); FileInputStream(File file);FileOutputStream的构造方法同上，另外， FileOutputStream所关联的文件若已经存在，则该文件的内容会被清空，所以若不想这样，就调用如下构造方法： FileOutputStream(String name,boolean append); //第二个参数改为true即可 FileOutputStream(File file,boolean append);Reader 与 Writer文件操作对应类： FileReader 与 FileWriter构造方法同上 使用字节流 读取 / 写入文件import java.io.*; public class testFileStream { public static void main(String[] args) throws IOException{ int n = -1; byte[] a = new byte[100]; File file = new File(&quot;C:\\\\Users\\\\DELL\\\\eclipse-workspace\\\\Test\\\\src\\\\JavaIO\\\\testFileStream.java&quot;); FileInputStream fin = new FileInputStream(file); while((n=fin.read(a,0,100))!=-1) { String s= new String(a,0,n); System.out.println(s); } fin.close(); } } 文件读取可能失败，记得抛出异常 操作完毕后记得关闭流 import java.io.*; public class testFileStream1 { public static void main(String[] args) { byte[] a = &quot;测试&quot;.getBytes(); byte[] b = &quot;FileOUtputStream写入&quot;.getBytes(); try { FileOutputStream fout = new FileOutputStream(&quot;test.txt&quot;); fout.write(a); fout.write(b,0,b.length); fout.close(); } catch (IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } } }使用字符流 读取/写入 文件import java.io.*; public class testFileReader { public static void main(String[] args) throws IOException { FileReader fread = new FileReader(&quot;test.txt&quot;); int n = -1; char[] a = new char[100]; while((n=fread.read(a, 0, 100))!=-1) { String content = new String(a,0,n); System.out.println(content); } fread.close(); } } 注：在这里我们打开了上面FileOutputStream生成的文件。 import java.io.*; public class testFileWriter { public static void main(String[] args) throws IOException{ FileWriter fwriter = new FileWriter(&quot;test.txt&quot;,true); char[] a = &quot;更改test.txt里面的内容&quot;.toCharArray(); fwriter.write(a); fwriter.close(); } }","link":"/2019/04/21/Java 字节流&字符流/"},{"title":"Java 模拟LinkedList","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/89057345 LinkedList底层用双向链表实现的存储。特点：查询效率低，增删效率高，线程不安全。 双向链表也叫双链表，是链表的一种，它的每个数据节点中都有两个指针，分别指向前一个节点和后一个节点。 // Node.java public class Node{ Node previous; Node next; public Node(Node previous,Node next,Object element) { super(); this.previous = previous; this.next = next; this.element = element; } public Node(Object element) { super(); this.element = element; } Object element; }// SxtLinkedList.java public class SxtLinkedList &lt;E&gt; { private Node first; private Node last; private int size; private Node getNode(int index) { checkRange(index); Node temp = first; if(index&lt;=(size&gt;&gt;1)) { for(int i = 0;i &lt; index;i++) { temp = temp.next; } }else { temp = last; for(int i = size-1;i &gt; index;i--) { temp = temp.previous; } } return temp; } private void checkRange(int index) { if(index&lt;0||index&gt;size-1) { throw new RuntimeException(&quot;索引&quot;+index+&quot;非法&quot;); } } public void add(E element) { Node node = new Node(element); if(first==null) { first = node; last = node; }else { node.previous = last; node.next = null; last.next = node; last = node; } size++; } public void add(int index,E obj) { checkRange(index); Node newNode = new Node(obj); Node temp = getNode(index); Node pTemp = temp.previous; if(temp!=null) { if(index==0) { temp.previous = newNode; newNode.next = temp; newNode.previous = null; first = newNode; }else if(index==size-1){ temp.next = newNode; newNode.previous = temp; newNode.next = null; }else { pTemp.next = newNode; newNode.previous = pTemp; newNode.next = temp; temp.previous = newNode; } size++; } } @SuppressWarnings(&quot;unchecked&quot;) public E get(int index) { Node temp = getNode(index); return temp!=null?(E)temp.element:null; } public void remove(int index) { Node temp = getNode(index); if(temp!=null) { Node up = temp.previous; Node down = temp.next; if(up!=null) { up.next = down; } if(down!=null) { down.previous = up; } if(index == 0) { first = down; } if(index==size-1) { last = up; } size--; } } public String toString() { Node temp = first; StringBuilder sb = new StringBuilder(&quot;[&quot;); while(temp!=null) { sb.append(temp.element+&quot;,&quot;); temp = temp.next; } sb.setCharAt(sb.length()-1,&apos;]&apos;); return sb.toString(); } public static void main(String[] args) { SxtLinkedList&lt;String&gt; list = new SxtLinkedList&lt;&gt;(); list.add(&quot;a&quot;); list.add(&quot;b&quot;); list.add(&quot;c&quot;); list.add(&quot;d&quot;); list.add(&quot;e&quot;); list.add(&quot;f&quot;); System.out.println(list); list.remove(0); System.out.println(list); list.remove(4); System.out.println(list); list.remove(2); System.out.println(list); list.add(0, &quot;o&quot;); list.add(3,&quot;l&quot;); System.out.println(list); System.out.println(list.get(2)); } }","link":"/2019/04/06/Java 模拟LinkedList/"},{"title":"Java 高淇300集资源分享","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/88423162 点我 java 高琪300集百度云资源 提取码:pvpt 教程中有教做飞机游戏，做出来的效果如下：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190312161643368.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)![在这里插入图片描述](https://img-blog.csdnimg.cn/2019031216184238.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)虽然游戏不难，却涉及很多知识与细节的使用。顺便把它打包成jar文件","link":"/2019/03/12/Java 高淇300集资源分享/"},{"title":"JavaScript 定义类或对象","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/90416464 一、工厂方式缺点：每次调用 函数 时，都要创建新的 getInfo()函数， 每个对象都有着自己的 getInfo() 版本 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;创建对象|工厂模式&lt;/title&gt; &lt;script&gt; function newPerson(name, age, gender) { var Person = new Object; Person.name = name; Person.age = age; Person.gender = gender; Person.getInfo = function () { alert(&quot;姓名：&quot; + this.name + &quot;\\n\\n年龄：&quot; + this.age + &quot;\\n\\n性别：&quot; + this.gender); } return Person; } var p = newPerson(&quot;xxx&quot;, 16, &quot;女&quot;); p.getInfo(); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;/html&gt;修改： function getInfo(){ alert(&quot;姓名：&quot; + this.name + &quot;\\n\\n年龄：&quot; + this.age + &quot;\\n\\n性别：&quot; + this.gender); } function newPerson(name, age, gender) { var Person = new Object; Person.name = name; Person.age = age; Person.gender = gender; Person.getInfo = getInfo; return Person; }以上修改解决了重复创建函数的问题，但是该函数看起来不像是对象的方法。 二、构造函数方式构造函数方式与工厂模式相比， 内部不用构造对象 ， 使用this关键字 。 在构造对象时使用new运算符。但是，也会出现工厂模式中出现的问题，同时也可以像工厂模式那样解决。 function Person(name, age, gender) { this.name = name; this.age = age; this.gender = gender; this.getInfo = function () { alert(&quot;姓名：&quot; + this.name + &quot;\\n\\n年龄：&quot; + this.age + &quot;\\n\\n性别：&quot; + this.gender); } } var p = new Person(&quot;xxx&quot;, 16, &quot;女&quot;); p.getInfo();三、原型方式缺点： 不能通过构造函数传递参数进行初始化 类似以下类中的drivers是指向Array的指针，当改变p2中drivers的值时，p1中的drivers也随之改变 function Person() { } Person.prototype.name = &quot;xxx&quot;; Person.prototype.age = 16; Person.prototype.gender = &quot;女&quot;; Person.prototype.drivers = new Array(&quot;a&quot;, &quot;b&quot;); Person.prototype.getInfo = function(){ alert(&quot;姓名：&quot; + this.name + &quot;\\n\\n年龄：&quot; + this.age + &quot;\\n\\n性别：&quot; + this.gender); } var p1 = new Person(); alert(p1.drivers); var p2 = new Person(); alert(p2.drivers); p2.drivers.push(&quot;sss&quot;); alert(p1.drivers); alert(p2.drivers);四、混合构造函数与原型方式function Person(name, age, gender) { this.name = name; this.age = age; this.gender = gender; this.drivers = new Array(&quot;a&quot;, &quot;b&quot;); } Person.prototype.getInfo = function () { alert(&quot;姓名：&quot; + this.name + &quot;\\n\\n年龄：&quot; + this.age + &quot;\\n\\n性别：&quot; + this.gender); } var p1 = new Person(&quot;npc1&quot;, 18, &quot;男&quot;); var p2 = new Person(&quot;npc2&quot;, 18, &quot;女&quot;); alert(p1.drivers); alert(p2.drivers); p1.drivers.push(&quot;c&quot;); alert(p1.drivers); alert(p2.drivers);五、动态原型方法function Person(name,age,gender) { this.name = name; this.age = age; this.gender = gender; if (typeof Person._initialized == &quot;undefined&quot;) { Person.prototype.getInfo = function () { alert(&quot;姓名：&quot; + this.name + &quot;\\n\\n年龄：&quot; + this.age + &quot;\\n\\n性别：&quot; + this.gender); } Person._initialized = true; } } var p1 = new Person(&quot;xxx&quot;, 17, &quot;abc&quot;); p1.getInfo();一般采取后面两种方式定义类或对象","link":"/2019/05/22/JavaScript 定义类或对象/"},{"title":"JavaScript 继承（原型链，对象冒充）","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/90479830 一、对象冒充&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; function Person(name, age) { this.name = name; this.age = age; this.show = function () { document.getElementById(&quot;target1&quot;).innerHTML = &quot;name:&quot; + this.name + &quot;&lt;br&gt;age:&quot; + this.age+&quot;&lt;br&gt;&quot;; } } var p = new Person(&quot;小学森&quot;, 12); p.show(); function Student(name, age, score) { // this.newMethod = Person; //this.newMethod(name, age); //delete newMethod; this.score = score; this.show = function () { document.getElementById(&quot;target2&quot;).innerHTML = &quot;name:&quot; + this.name + &quot;&lt;br&gt;age:&quot; + this.age + &quot;&lt;br&gt;score:&quot; + this.score + &quot;&lt;br&gt;&quot;; } } var stu = new Student(&quot;小学森&quot;, 12, 100); stu.show(); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;二、call() 与 apply()1.call()将以上代码注释部分替换为： Person.call(this, name, age);call()方法的第一个参数用作this的对象，其他参数与函数对应2.apply()将以上代码注释部分替换为 Person.apply(this, new Array(name, age));第一个参数为this，第二个参数为要传递给函数的参数数组。 三、原型链function ClassA() { } ClassA.prototype.color = &quot;red&quot;; ClassA.prototype.sayColor = function () { alert(this.color); } function ClassB() { } ClassB.prototype = new ClassA(); ClassB.prototype.name = &quot;&quot;; ClassB.prototype.sayName = function () { alert(this.name); } var objA = new ClassA(); var objB = new ClassB(); objA.color = &quot;yellow&quot;; objB.color = &quot;blue&quot;; objB.name = &quot;xx&quot;; objA.sayColor(); objB.sayColor(); objB.sayName();四、混合方式function ClassA(sColor) { this.color = sColor; } ClassA.prototype.sayColor = function () { alert(this.color); } function ClassB(sColor, sName) { ClassA.call(this, sColor); this.name = sName; } ClassB.prototype = new ClassA(); ClassB.prototype.sayName = function () { alert(this.name); } var objA = new ClassA(&quot;red&quot;); var objB = new ClassB(&quot;yellow&quot;, &quot;admin&quot;); objA.sayColor(); objB.sayColor(); objB.sayName();","link":"/2019/05/23/JavaScript 继承（原型链，对象冒充）/"},{"title":"Java 集合类","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/89059524 一、Collection 接口方法 ： add(E e) remove(Object o) isEmpty() iterator() size() 子接口 ： List 和 Set 二、List 接口继承 ：Collection接口，可使用其中搜友方法 自定义的重要方法 ： get(int index) set(int index,Object obj) 特点 ： 有序，可通过索引访问 可重复，可以添加重复的元素 实现类 ： ArrayList 可变的数组，允许null，访问快，增删慢，线程不安全。 LinkedList 双向链表，访问慢，增删快，线程不安全 手写LinkedList Vector 线程安全 List&lt;String&gt; a = new ArrayList&lt;&gt;(); a.add(&quot;a&quot;); a.add(&quot;b&quot;); a.set(1,&quot;b1&quot;); System.out.println(a); // [a,b1]三、Map接口 存储“键(key)-值(value) 对”,一一对应的关系，因此 键不能重复，若重复，新的值会替代旧的值 哈希算法实现，查找、删除、修改效率高 方法 ： put(K key,V value) containsKey(Object key) containsValue(Object value) get(Object key) keySet() values() 实现类 ： HashMap 允许使用null值和null键 不保证映射顺序 TreeMap 不允许null键 但集合映射具有一定顺序 import java.util.ArrayList; import java.util.HashMap; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; import java.util.TreeMap; import java.util.Vector; public class testMap { void test1() { Map&lt;Integer,String&gt; m1 = new HashMap&lt;&gt;(); m1.put(31,&quot;1&quot;); m1.put(13,&quot;3&quot;); m1.put(211,&quot;2&quot;); m1.put(42,&quot;4&quot;); m1.put(34,&quot;5&quot;); m1.put(101,&quot;6&quot;); Map&lt;Integer,String&gt; m2 = new TreeMap&lt;&gt;(); m2.put(31,&quot;1&quot;); m2.put(13,&quot;3&quot;); m2.put(211,&quot;2&quot;); m2.put(42,&quot;4&quot;); m2.put(34,&quot;5&quot;); m2.put(101,&quot;6&quot;); System.out.println(m1); System.out.println(m2); } public static void main(String[] args) { new testMap().test1(); } }结果： {34=5, 211=2, 101=6, 42=4, 13=3, 31=1} //无序 {13=3, 31=1, 34=5, 42=4, 101=6, 211=2} //有序 HashMap效率高于TreeMap;在需要排序的Map时才选用TreeMap。 四、Set接口继承 ：Collection接口方法 ：与Collection完全一致特点 ：无序（没有索引，只能遍历查找）、不可重复（不能出现重复元素）实现类 ： HashSet 允许null元素 不保证迭代顺序 TreeSet 不允许使用null元素 通过实现Comparable接口做到内部的排序 HashSet例子：public class Test { public static void main(String[] args) { Set&lt;String&gt; s = new HashSet&lt;String&gt;(); s.add(&quot;hello&quot;); s.add(&quot;-&quot;); s.add(&quot;world&quot;); System.out.println(s); s.add(&quot;hello&quot;); //相同的元素不会被加入 System.out.println(s); s.add(null); System.out.println(s); s.add(null); System.out.println(s); } }结果： [world, hello, -] [world, hello, -] [null, world, hello, -] [null, world, hello, -] 打印出来每个元素的位置与添加的位置无关（不保证迭代顺序） 允许添加null元素，但最多添加一个，因为Set不允许重复。 TreeSet例子：package Gaoqi300; import java.util.Iterator; import java.util.Set; import java.util.TreeSet; public class Test1 { public static void main(String[] args) { User u1 = new User(1001, &quot;高淇&quot;, 18); User u2 = new User(2001, &quot;高希希&quot;, 5); User u3 = new User(1599,&quot;xxx&quot;,12); Set&lt;User&gt; set = new TreeSet&lt;User&gt;(); set.add(u1); set.add(u2); set.add(u3); System.out.println(set); Iterator iter =set.iterator(); while(iter.hasNext()){ Object obj = iter.next(); System.out.println(obj); } } } class User implements Comparable&lt;User&gt; { int id; String uname; int age; public User(int id, String uname, int age) { this.id = id; this.uname = uname; this.age = age; } /** * 返回0 表示 this == obj 返回正数表示 this &gt; obj 返回负数表示 this &lt; obj */ @Override public int compareTo(User o) { if (this.id &gt; o.id) { return 1; } else if (this.id &lt; o.id) { return -1; } else { return 0; } } public String toString() { return id+&quot; &quot;+age+&quot; &quot;+uname; } }运行结果： [1001 18 高淇, 1599 12 xxx, 2001 5 高希希] 1001 18 高淇 1599 12 xxx 2001 5 高希希 Set &lt; User &gt; set = new TreeSet&lt; User &gt;(); 尖括号里面的类 必须实现Comparable接口 ，这样才能实现内部排序。 五、遍历集合对于Set、List和Map都可使用 Iterator迭代器 public class testSet { public static void main(String[] args) { Set&lt;String&gt; s = new HashSet&lt;String&gt;(); s.add(&quot;hello&quot;); s.add(&quot;-&quot;); s.add(&quot;world&quot;); s.add(&quot;hello&quot;); //相同的元素不会被加入 s.add(null); s.add(null); for(Iterator iter= s.iterator();iter.hasNext();){ String temp = (String)iter.next(); System.out.println(temp); } Iterator iter = s.iterator(); while(iter.hasNext()) { String temp = (String)iter.next(); System.out.println(temp); } } } 对于List，操作与以上类似 对于Map，如下： 根据Key值获取Value ： Map&lt;Integer, Man&gt; maps = new HashMap&lt;Integer, Man&gt;(); Set&lt;Integer&gt; keySet = maps.keySet(); //获取键 for(Integer id : keySet){ System.out.println(maps.get(id).name); }或 entrySet ： Set&lt;Entry&lt;Integer, Man&gt;&gt; ss = maps.entrySet(); for (Iterator iterator = ss.iterator(); iterator.hasNext();) { Entry e = (Entry) iterator.next(); System.out.println(e.getKey()+&quot;--&quot;+e.getValue());除此之外，对于List，也可以结合 循环和List的get()方法 遍历集合： for(int i=0;i&lt;list.size();i++){//list为集合的对象名 String temp = (String)list.get(i); System.out.println(temp); }","link":"/2019/04/06/Java 集合类/"},{"title":"Java做的奇怪的东西╮(╯﹏╰）","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86561454 ╭(｀・ω・´)如下所示： import java.util.Date; import javax.swing.plaf.synth.SynthSpinnerUI; public class hellojava { public static void main(String[]args){ Date date = new Date(); String year = String.format(&quot;%tY&quot;,date);//年 String month = String.format(&quot;%tm&quot;, date);//月 String day = String.format(&quot;%td&quot;, date);//日 String a = String.format(&quot;%ta&quot;, date);//星期几 String b = String.format(&quot;%tj&quot;,date);//一年中第几天 String c = String.format(&quot;%td&quot;,date);//一个月第几天 String d = String.format(&quot;%tc&quot;,date);//全部信息 int i = Integer.parseInt(year); int j = Integer.parseInt(b); int all = 365; if((i%4==0&amp;&amp;i%100!=0)||i%400==0) all += 1; System.out.println(year+&quot;/&quot;+month+&quot;/&quot;+day+&quot;\\t&quot;+a); System.out.println(); System.out.println(year+&quot;年的第&quot;+b+&quot;天,&quot;+month+&quot;月的第&quot;+c+&quot;天,离&quot;+(i+1)+&quot;年还有&quot;+(all - j)+&quot;天&quot;); System.out.println(); System.out.println(d); System.out.println(); } }","link":"/2019/01/20/Java做的奇怪的东西╮(╯﹏╰）/"},{"title":"Java包","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/88771421 一、包 类包是Java管理文件的一种机制。 目的：防止类同名问题（将两个类放置在不同包中） 命名规则：小写字母 cn.sxt.test; cn.sxt.view; cn.sxt.view.model;注意事项 : 写项目时都要加包，不要使用默认包。 com.sxt.view 和 com.sxt.view.model 是两个完全独立的包。 二、packagepackage用于指定包名格式： package 包名 三、import导入包import用于导入包，告诉编译器应该使用哪个包里面的类。例如：一个程序同时用到java.sql.Date类和java.util.Date里面的类，你需这样做： java.util.Date date1 = new java.util.Date(); java.sql.Date date2 = new java.sql.date(2333);即使程序里面没有出现像如上的情况，也需要导入包： import java.util.date; //import java.util.*;(java.util包里面的所有类都可以使用) Date date = new Date();导入静态成员import static java.lang.Math.max; import static java.lang.System.out; public class Test{ public static void main(String args[])[ out.println(&quot;1和2中的最大值为&quot;+max(1,2)); } }注意： Java会默认导入java.lang包下所有的类，因此这些类我们可以直接使用。 四、常用包 包名 功能 java.lang 包含一些Java语言的核心类，如String、Math、Integer、System和Thread，提供常用功能。 java.awt 包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。 java.net 包含执行与网络相关的操作的类。 java.io 包含能提供多种输入/输出功能的类。 java.util 包含一些实用工具类，如定义系统特性、使用与日期日历相关的函数。","link":"/2019/03/24/Java包/"},{"title":"Java多线程（一）","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/90299404 一、认识多线程进程 VS 线程进程 ：打开任务管理器，里面有多个进程。![在这里插入图片描述](https://img-blog.csdnimg.cn/20190517194556128.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 进程是系统进行资源分配和调度的独立单位。每一个进程都有它自己的内存空间和系统资源 独立性：拥有自己独立的资源，每个进程拥有自己的私有地址空间。 动态性：程序是一个静态的指令集合，而进程加入了时间的概念。 并发性：多个进程可以在单个处理器并发执行。 线程 ：线程是进程的一部分。每个进程可以执行多个任务，这个任务就是线程。（可以想象成某个程序的子模块） 分类： 用户级线程：管理过程全部由用户程序完成，操作系统内核心只对进程进行管理。 系统级线程(核心级线程)：由操作系统内核进行管理。操作系统内核给应用程序提供相应的系统调用和应用程序接口API，以使用户程序可以创建、执行以及撤消线程。 why 多线程？ 线程之间可以共享内存 创建代价小（不需要重新分配系统资源） 二、使用多线程常用的有两种方法: 继承 Thread 类，重写run()方法 实现 Runnable 接口 示例1： public class MyThread extends Thread{ private int num = 10; public void run() { while(true) { System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+num); num--; if(num==0) { return; } } } public static void main(String[] args) { MyThread myThread = new MyThread(); Thread a = new Thread(myThread,&quot;thread1&quot;); a.start(); } } 重写 run() 方法，使用 start() 启动线程 Thread.currentThread().getName() 用于获取线程名，即 Thread a = new Thread(myThread,&quot;thread1&quot;); 的构造方法的第二个参数。 示例2： public class MyThread1 implements Runnable{ private int num = 10; public void run() { while(true) { System.out.println(Thread.currentThread().getName()+&quot;--&gt;&quot;+num); num--; if(num==0) { return; } } } public static void main(String[] args) { MyThread myThread1 = new MyThread(); Thread a = new Thread(myThread1,&quot;thread1&quot;); a.start(); } } run() VS start() run():仅仅是封装被线程执行的代码，直接调用是普通方法 start():首先启动了线程，然后再由jvm去调用该线程的run()方法。 main方法也是一个线程 public class MyThread1 { public static void main(String[] args) { System.out.println(Thread.currentThread().getName()); } } /*** main ***/三、线程的优先级 线程的优先级可以在某种程度上影响执行线程的顺序，但设置优先级仅仅只是个建议， 优先级高不一定先执行，这取决与操作系统 。 设置优先级使用 setPriority() 方法，参数的取值范围为 *1 &lt;= x &lt;= 10 * ，不在范围内则抛出IllegalArgumentException 异常 Thread.MIN_PRIORITY(1) Thread.MAX_PRIORITY(10) Thread.NORM_PRIORITY(5)是Thread类里面的变量， 线程创建时优先级默认为5. 线程设置优先级要在调用start方法之前 public class MyThread1 { public static void main(String[] args) { Thread thread = new Thread(()-&gt;{ for(int i = 0;i &lt; 6;i++) { System.out.println(&quot;lamada..&quot;+i); } }); System.out.println(&quot;thread的优先级是&quot;+thread.getPriority()); thread.setPriority(10); System.out.println(&quot;thread的优先级是&quot;+thread.getPriority()); thread.start(); for(int i = 0;i &lt; 6;i++) { System.out.println(&quot;main..&quot;+i); } } }![在这里插入图片描述](https://img-blog.csdnimg.cn/20190517203956412.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) Runnable接口时函数式接口，可以用Lamada表达式建立Runnable对象。 四、线程的生命周期线程的生命周期有 5 种状态： 新建（ New ） 就绪 ( Runnable ) 运行 ( Running ) 阻塞 （ Blocked ) 死亡 ( Dead )![在这里插入图片描述](https://img-blog.csdnimg.cn/20190517211540274.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 五、操作线程的方法1.join() 线程插队public class MyThread1 { public static void main(String[] args) throws InterruptedException { Thread thread = new Thread(()-&gt;{ for(int i = 0;i &lt; 20;i++) { System.out.println(&quot;lamada..&quot;+i); } }); thread.start(); for(int i = 0;i &lt; 20;i++) { if(i==10) { thread.join(); } System.out.println(&quot;main..&quot;+i); } } }运行结果： main..0 main..1 main..2 main..3 main..4 main..5 main..6 main..7 main..8 main..9 lamada..0 lamada..1 lamada..2 lamada..3 lamada..4 lamada..5 lamada..6 lamada..7 lamada..8 lamada..9 lamada..10 lamada..11 lamada..12 lamada..13 lamada..14 lamada..15 lamada..16 lamada..17 lamada..18 lamada..19 main..10 main..11 main..12 main..13 main..14 main..15 main..16 main..17 main..18 main..19 很显然，当main()方法中的 i 为 10时，main()方法被插队了，只有thread执行完成后，main()才执行。 2.slepp() 线程睡眠 抱着资源睡觉处于sleep()中的线程不会执行，调用后线程进入阻塞状态。 Thread.sleep(long millis);//参数为毫秒数,1000ms = 1s3.yield() 线程让步 sleep()暂停主线程后会给其他线程机会，而yield()只会给优先级相同或更高的线程执行机会 yield()不会阻塞进程，只是将该线程进入就绪状态。 yield()不会抛出异常，而sleep()会 4.改变线程优先级","link":"/2019/05/17/Java多线程（一）/"},{"title":"Java多线程（二） 线程同步","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/90320339 一、线程不安全 与 线程安全1. 了解线程不安全线程不安全示例1：模拟抢票 public class Unsafe01 extends Thread{ private int num = 30; @Override public void run() { while(true) { if(num &gt; 0) { try { Thread.sleep(100); } catch(Exception e) { } System.out.println(Thread.currentThread().getName()+&quot;卖出了第&quot;+num--+&quot;张票&quot;); }else { System.out.println(&quot;票卖完了&quot;); return; } } } public static void main(String[] args) { Unsafe01 sell = new Unsafe01(); Thread sell1 = new Thread(sell, &quot;窗口1&quot;); Thread sell2 = new Thread(sell, &quot;窗口2&quot;); Thread sell3 = new Thread(sell, &quot;窗口3&quot;); sell1.start(); sell2.start(); sell3.start(); } } （会出现负数，抢到同一张票的情况） 线程不安全示例2： import java.util.ArrayList; import java.util.List; public class Unsafe02 { public static void main(String[] args) { List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for(int i = 0;i &lt; 10000;i++) { new Thread(()-&gt;{ list.add(Thread.currentThread().getName()); }).start(); } System.out.println(list.size()); } } 输出的值小于10000 2.使用线程安全1. 使用线程安全的两种方式 同步方法 同步块 2.使用方法对于同步方法：在方法前面加上 synchronized public synchronized void play(){ }对于同步块： synchronized(obj){ }synchronized 保证在同一个时刻只有一个线程在使用。3. 修改以上两个程序：示例1加上同步方法 public class Safe01 extends Thread{ private int num = 30; boolean flag = true; @Override public void run() { while(flag) { sale(); try { Thread.sleep(100); }catch(InterruptedException e) { e.printStackTrace(); } } } //synchronized 锁的是this（也就是对象）的资源，而不是方法。 private synchronized void sale() { if(num &gt; 0) { try { Thread.sleep(100); } catch(Exception e) { } System.out.println(Thread.currentThread().getName()+&quot;卖出了第&quot;+num--+&quot;张票&quot;); }else { System.out.println(&quot;票卖完了&quot;); flag = false; return; } } public static void main(String[] args) { Safe01 sell = new Safe01(); Thread sell1 = new Thread(sell, &quot;窗口1&quot;); Thread sell2 = new Thread(sell, &quot;窗口2&quot;); Thread sell3 = new Thread(sell, &quot;窗口3&quot;); sell1.start(); sell2.start(); sell3.start(); } }示例2加上同步块 import java.util.ArrayList; import java.util.List; public class Safe02 { public static void main(String[] args) throws InterruptedException { List&lt;String&gt; list = new ArrayList&lt;String&gt;(); for(int i = 0;i &lt; 10000;i++) { new Thread(()-&gt;{ synchronized(list) { list.add(Thread.currentThread().getName()); } }).start(); } Thread.sleep(1); System.out.println(list.size()); } }3. synchronized限定的范围太大会影响效率，太小有可能发挥不了功能，发生错误。 使用以下代码测试一下（将示例1改为同步块的形式，并添加了计时）： import java.util.Date; public class Safe03 extends Thread{ private int num = 300; boolean flag = true; long start; long end; @Override public void run() { while(flag) { if(num &lt;= 0) { Date date = new Date(); end = date.getTime(); System.out.println((end-start)/1000+&quot;seconds&quot;); return; } synchronized((Integer)num) { if(num &gt; 0) { System.out.println(Thread.currentThread().getName()+&quot;卖出了第&quot;+num--+&quot;张票&quot;); }else { System.out.println(&quot;票卖完了&quot;); flag = false; Date date = new Date(); end = date.getTime(); System.out.println((end-start)/1000+&quot;seconds&quot;); return; } try { Thread.sleep(100); }catch(InterruptedException e) { e.printStackTrace(); } } } } public static void main(String[] args) { Safe03 sell = new Safe03(); Date date = new Date(); sell.start = date.getTime(); Thread sell1 = new Thread(sell, &quot;窗口1&quot;); Thread sell2 = new Thread(sell, &quot;窗口2&quot;); Thread sell3 = new Thread(sell, &quot;窗口3&quot;); sell1.start(); sell2.start(); sell3.start(); } }第一次同步块锁 num :![在这里插入图片描述](https://img-blog.csdnimg.cn/20190518222049660.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)第二次锁 this :![在这里插入图片描述](https://img-blog.csdnimg.cn/20190518221940998.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)","link":"/2019/05/18/Java多线程（二） 线程同步/"},{"title":"Java多线程 模拟售票窗口售票","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/90552660 编写一个Java 多线程程序,完成三个售票窗口同时出售20张票 程序分析： 1.票数要使用同一个静态值； 2.为保证不会出现卖出同一个票数，要java多线程同步锁。 设计思路： 创建一个站台类Station，继承Thread，重写run方法，在run方法里面执行售票操作！售票要使用同步锁：即有一个站台卖这张票时，其他站台要等这张票卖完！ 2.创建主方法调用类 方法1：同步方法 public class Safe01 extends Thread{ private int num = 30; boolean flag = true; @Override public void run() { while(flag) { sale(); try { Thread.sleep(100); }catch(InterruptedException e) { e.printStackTrace(); } } } //synchronized 锁的是this（也就是对象）的资源，而不是方法。 private synchronized void sale() { if(num &gt; 0) { try { Thread.sleep(100); } catch(Exception e) { } System.out.println(Thread.currentThread().getName()+&quot;卖出了第&quot;+num--+&quot;张票&quot;); }else { System.out.println(&quot;票卖完了&quot;); flag = false; return; } } public static void main(String[] args) { Safe01 sell = new Safe01(); Thread sell1 = new Thread(sell, &quot;窗口1&quot;); Thread sell2 = new Thread(sell, &quot;窗口2&quot;); Thread sell3 = new Thread(sell, &quot;窗口3&quot;); sell1.start(); sell2.start(); sell3.start(); } }方法2：同步块 import java.util.Date; public class Safe03 extends Thread{ private int num = 300; boolean flag = true; @Override public void run() { while(flag) { if(num &lt;= 0) { return; } synchronized((Integer)num) { if(num &gt; 0) { System.out.println(Thread.currentThread().getName()+&quot;卖出了第&quot;+num--+&quot;张票&quot;); }else { System.out.println(&quot;票卖完了&quot;); flag = false; return; } try { Thread.sleep(100); }catch(InterruptedException e) { e.printStackTrace(); } } } } public static void main(String[] args) { Safe03 sell = new Safe03(); Thread sell1 = new Thread(sell, &quot;窗口1&quot;); Thread sell2 = new Thread(sell, &quot;窗口2&quot;); Thread sell3 = new Thread(sell, &quot;窗口3&quot;); sell1.start(); sell2.start(); sell3.start(); } } 写的时候要注意 共享的变量尽量不要暴露在没加同步锁的地方","link":"/2019/05/30/Java多线程 模拟售票窗口售票/"},{"title":"Java抽象类与接口","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/88908553 一、抽象方法与抽象类1.抽象方法 ：只有声明没有方法体： abstract public void shout();2.抽象类 ：含有抽象方法的类 abstract class Animal { abstract public void shout(); //抽象方法 } class Dog extends Animal { //子类必须实现父类的抽象方法，否则编译错误 public void shout() { System.out.println(&quot;汪汪汪！&quot;); } public void seeDoor(){ System.out.println(&quot;看门中....&quot;); } } //测试抽象类 public class TestAbstractClass { public static void main(String[] args) { Dog a = new Dog(); a.shout(); a.seeDoor(); } } 抽象类不能实例化，抽象类的构造方法只能被子类调用 抽象类只能用来被继承。 抽象方法必须在子类中实现，即使方法体为空也行 例子： public class TestAbstract { public static void main(String[] args) { Animal a =new Dog(); a.shout(); // 编译器报错：a.seeDoor(); } } abstract class Animal { abstract public void shout(); //抽象方法 } class Dog extends Animal { //子类必须实现父类的抽象方法，否则编译错误 public void shout() { System.out.println(&quot;汪汪汪！&quot;); } public void seeDoor(){ System.out.println(&quot;看门中....&quot;); } } 用抽象类实例化子类时，只能调用抽象类里面的方法 注意 ：抽象类中也可以有非抽象方法，但必须有抽象方法！有抽象方法必定是抽象类！ public class TestAbstract { public static void main(String[] args) { Animal a =new Dog(); a.shout(); //a.seeDoor(); a.a(); } } abstract class Animal { abstract public void shout(); //抽象方法 void a(){ System.out.println(&quot;lalala&quot;); } } class Dog extends Animal { //子类必须实现父类的抽象方法，否则编译错误 public void shout() { System.out.println(&quot;汪汪汪！&quot;); } public void seeDoor(){ System.out.println(&quot;看门中....&quot;); } }二、接口比较： 普通类：具体实现 抽象类：具体实现，规范(抽象方法) 接口：规范! 什么是接口？接口就是比抽象类还抽象的抽象类，接口中全部的方法都是抽象方法。如何使用？ public class TestInterface { public static void main(String[] args) { people p = new people(); p.walkWay(); p.walk(); Walk walk = new people(); walk.walk(); } } interface Walk{ void walk(); //public abstract ... int speed = 1; //public static final ... } class people implements Walk{ @Override public void walk() { // TODO Auto-generated method stub System.out.println(&quot;走路速度：&quot;+speed); } public void walkWay() { System.out.println(&quot;双腿行走&quot;); } } //双腿行走 //走路速度：1 //走路速度：1接口说明 常量：接口中的属性只能是 常量 ，总是： public static final 修饰。不写也是。 方法：接口中的方法只能是： public abstract 。 省略的话，也是public abstract。 接口 不能创建实例 ，但是可用于声明引用变量类型（可用于调动接口里面的方法）。 一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是 public 的。 接口可以多继承。","link":"/2019/03/30/Java抽象类与接口/"},{"title":"Java数组","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/88770005 一、数组的特点 数组的每个元素 同类型 数组的长度在申明后 不可变 类型： 基本数据类型 和 引用类型 （ 对象 ） 二、数组的创建 两步走： 申明 （确定长度）和 分配变量 申明： type[] arrName; //推荐用法 type arrName[];举个例子： public class Test { public static void main(String args[]) { int[] s = null; // 声明数组； s = new int[10]; // 给数组分配空间； for (int i = 0; i &lt; 10; i++) { s[i] = 2 * i + 1;//给数组元素赋值； System.out.println(s[i]); } } }注意事项 ：声明的时候并没有实例化任何对象，只有在实例化数组对象时，JVM才分配空间，这时才与长度有关。 三、数组的初始化1. 静态初始化int[] a = { 1, 2, 3 };// 静态初始化基本类型数组； Man[] mans = { new Man(1, 1), new Man(2, 2) };// 静态初始化引用类型数组；2.动态初始化int[] a1 = new int[2];//动态初始化数组，先分配空间； a1[0]=1;//给数组元素赋值； a1[1]=2;//给数组元素赋值；3.默认初始化int a2[] = new int[2]; // 默认值：0,0 boolean[] b = new boolean[2]; // 默认值：false,false String[] s = new String[2]; // 默认值：null, null四、二维数组1.二维数组的申明 public class Test { public static void main(String[] args) { // Java中多维数组的声明和初始化应按从低维到高维的顺序进行 int[][] a = new int[3][]; a[0] = new int[2]; a[1] = new int[4]; a[2] = new int[3]; // int a1[][]=new int[][4];//非法 } }2. 静态初始化 int[][] a = {{1,2},{3},{4,5,6}};3.动态初始化 int[][] a = new int[2][]; a[0] = new int[]{1,2,3}; a[1] = new int[]{3,5};4.使用二维数组(1) 获取长度 /获取的二维数组第一维数组的长度。 System.out.println(a.length); //获取第二维第一个数组长度。 System.out.println(a[0].length);(2) 输出 System.out.println(a[0][2]); System.out.println(Arrays.toString(a[0]));(3) 打印全部元素for循环版： int[][] a = {{1,2,3},{4,5,6},{7,8,9}}; for(int i = 0;i&lt;a.length;i++){ for(int j = 0;j&lt;a[i].length;j++){ System.out.print(a[i][j]); } System.out.println(); }foreach版： int[][] array = {{1,2,3},{4,5,6},{7,8,9}}; for(int[] a: array){ for(int m: a){ System.out.print(m); } System.out.println(); }五、foreach语句int[] a = {1,2,3,4,5}; for(int x : a){ System.out.println(x); }注意： for-each增强for循环在遍历数组过程中不能修改数组中某元素的值。 六、数组操作的常用类java.util.Arrays类 比较数组:equals()方法 (deepEquals()用于多维数组) 打印数组:Arrays.toString(数组名); 数组排序:Arrays.sort(数组名); 二分查找:Arrays.binarySearch(数组名,查找的元素)。 元素替换:Arrays.fill(数组名,元素值) 数组复制:Arrays.copyOf(数组名,复制后新数组的长度)System.arraycopy(数组1,i,数组2,j,需要复制的元素的个数) 以上具体方法查看官方文档，或者使用编译器时可查看。","link":"/2019/03/23/Java数组/"},{"title":"Java猜数字","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/90301977 编写一个JavaApplication程序，实现如下的设计目标：程序运行时自动产生1~100的随机数，接收用户键盘输入数据并给出提示信息，直至猜对。游戏者猜对后，显示猜测次数，并提供“重新开始”和“退出”功能。 import java.util.Scanner; public class guessNumber { int target; public guessNumber() { target = ((int) (Math.random()*100)+1)%100; } public void start() { Scanner scr = new Scanner(System.in); int count= 0; while(true) { System.out.println(&quot;请输入您猜的数字&quot;); System.out.print(&quot;&gt;&quot;); int guess = scr.nextInt(); count++; if(guess &lt; target) { System.out.println(&quot;猜低了&quot;); }else if(guess&gt;target) { System.out.println(&quot;猜高了&quot;); }else { System.out.println(&quot;猜对了！您一共猜了&quot;+count+&quot;次！&quot;); System.out.println(&quot;--------------------&quot;); return; } System.out.println(&quot;--------------------&quot;); } } public static void main(String[] args) { while(true) { System.out.println(&quot;******************&quot;); System.out.println(&quot;*** 1. 开始游戏 ***&quot;); System.out.println(&quot;*** 2. 退出游戏 ***&quot;); System.out.println(&quot;******************&quot;); System.out.println(&quot;请输入您的选择&quot;); System.out.print(&quot;&gt;&quot;); int choose = 0; Scanner scr = new Scanner(System.in); choose = scr.nextInt(); switch(choose) { case 1: new guessNumber().start(); break; case 2: System.out.println(&quot;退出成功！&quot;); return; default: break; } } } }","link":"/2019/05/17/Java猜数字/"},{"title":"Java简易的矩阵类","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86579114 今天对Java的类有了简单的认识，按照书上习题编写了一个矩阵类。题目 ：尝试编写一个矩阵类，将长和宽作为矩阵类的属性，在构造方法中将长、宽初始化，定义一个成员方法求次矩形的面积。自己写的代码如下： public class Rectangle { private double a,b; public Rectangle(){ //构造方法 a = 1; b = 1; } public void setLength(double a,double b){//可赋值 this.a = a; this.b = b; } private double getSquare(){ //求面积方法 return a*b; } public Rectangle returnThis(){ return this; } public static void main(String[] args) { Rectangle a = new Rectangle(); //创建对象 /*验证*/ System.out.println(&quot;初始化后的长为&quot;+a.a+&quot;,宽为&quot;+a.b+&quot;,面积为&quot;+a.getSquare()); a.setLength(22, 12); System.out.println(&quot;更改后后的长为&quot;+a.a+&quot;,宽为&quot;+a.b+&quot;,面积为&quot;+a.getSquare()); } }运行结果：","link":"/2019/01/21/Java简易的矩阵类/"},{"title":"Java控制台三种输入方式","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/89818193 Round 1第一种：使用 System.in.read() ,较为麻烦 package com.first.test; import java.io.IOException; public class Accept { public static void main(String[] args) { int c= 0; String s = &quot;&quot;; System.out.println(&quot;输入摄氏度：0&lt;数值&lt;100&quot;); System.out.print(&quot;&gt;&quot;); while(c!=13) { try { c = System.in.read(); } catch (IOException e) { e.printStackTrace(); } s = s + (char)c; } int celsius = Integer.parseInt(s.trim()); double fahre = 1.8 * celsius + 32; System.out.println(&quot;转化为华氏度为：&quot;+fahre); } }对以上代码说明: System.in.read() 一次只能接收一个字符，返回一个ASCII码 ASCII码13对应的值为 ‘\\r’ 回车 以上代码看起来匪夷所思，让我们对代码进行修改，做个测试，在每次循环时输出c与s的值 package com.first.test; import java.io.IOException; public class Accept { public static void main(String[] args) { int c= 0; String s = &quot;&quot;; System.out.println(&quot;输入摄氏度：0&lt;数值&lt;100&quot;); System.out.print(&quot;&gt;&quot;); while(c!=13) { //13对应的ASCII为&apos;/r&apos;回车 try { c = System.in.read(); } catch (IOException e) { e.printStackTrace(); } //返回一个ASCII值，如c=13,先返回1的ASCII再返回3的ASCII System.out.println(c); s = s + (char)c; System.out.println(s); System.out.println(&quot;*****************&quot;); } int celsius = Integer.parseInt(s.trim()); double fahre = 1.8 * celsius + 32; System.out.println(&quot;转化为华氏度为：&quot;+fahre); } }结果： 输入摄氏度：0&lt;数值&lt;100 &gt;13 49 //1对应的ASCII 1 ***************** 51 //3对应的ASCII 13 ***************** 13 //&apos;\\r&apos;对应的ASCII 13 ***************** 转化为华氏度为：55.400000000000006结合代码中的注释与说明，这个应该不难理解。 Round 2使用 BufferedReader import java.io.BufferedReader; import java.io.InputStreamReader; public class Accept1 { public static void main(String[] args) { String s=&quot;&quot;; System.out.println(&quot;输入摄氏度：0&lt;数值&lt;100&quot;); System.out.print(&quot;&gt;&quot;); BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); try { s = br.readLine(); }catch(Exception e) { } int celsius = Integer.parseInt(s.trim()); double fahre = 1.8 * celsius + 32; System.out.println(&quot;转化为华氏度为：&quot;+fahre); } } Round 3使用Scanner类，较为方便 import java.util.Scanner; public class Accept2 { public static void main(String[] args) { int c= 0; System.out.println(&quot;输入摄氏度：0&lt;数值&lt;100&quot;); System.out.print(&quot;&gt;&quot;); Scanner scr = new Scanner(System.in); c = scr.nextInt(); double fahre = 1.8 * c + 32; System.out.println(&quot;转化为华氏度为：&quot;+fahre); } }","link":"/2019/05/04/Java控制台三种输入方式/"},{"title":"Java继承,多态,抽象类,接口基本概念","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/93880701 这篇主要用来集中一下以前写的博客，方便复习… 抽象类与接口 继承与多态 1.Java 不支持多继承，但支持多重继承。一个类只能继承一个类，但能被多个类继承。 class Person { } class Student extends Person { } class Teacher extends Person{ }2.继承的特性 子类拥有父类非 private 的属性、方法。 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。 子类可以用自己的方式实现父类的方法。 3.final关键字 final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写： 声明类： final class 类名 {//类体} 声明方法： 修饰符(public/private/default/protected) final 返回值类型 方法名(){//方法体} 注 :实例变量也可以被定义为 final，被定义为 final 的变量不能被修改。被声明为 final 类的方法自动地声明为final，但是实例变量并不是 final 4.Java 重写(Override)与重载(Overload) 重写： class Animal{ public void move(){ System.out.println(&quot;动物可以移动&quot;); } } class Dog extends Animal{ public void move(){ System.out.println(&quot;狗可以跑和走&quot;); } } public class TestDog{ public static void main(String args[]){ Animal a = new Animal(); // Animal 对象 Animal b = new Dog(); // Dog 对象 a.move();// 执行 Animal 类的方法 b.move();//执行 Dog 类的方法 } }重写规则 ： 参数列表必须完全与被重写方法的相同； 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）； public class A extends B{ double getB() { //报错 return 1; } public static void main(String[] args) { }} class B { int b; int getB() { return b; }} public class A extends B{ D getB() { //OK，原来返回值是C，现在返回值是C的派生类D return new D(); } public static void main(String[] args) { } } class B { C c; C getB() { return c; } } class C{ } class D extends C{ } 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。 public class A extends B{ //private default protected public protected int getB() { //private会报错 return 1; } public static void main(String[] args) { }} class B { int b; int getB() { return b; }} 父类的成员方法只能被它的子类重写。 声明为final的方法不能被重写。 声明为static的方法不能被重写，但是能够被再次声明。 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。。 构造方法不能被重写。 如果不能继承一个方法，则不能重写这个方法。(如父类private方法) 重载： 重载规则: 被重载的方法必须改变参数列表(参数个数或类型不一样)； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载。 无法以返回值类型作为重载函数的区分标准。 5.多态 多态存在的三个必要条件 继承 重写 父类引用指向子类对象 public class Test { public static void main(String[] args) { show(new Cat()); // 以 Cat 对象调用 show 方法 show(new Dog()); // 以 Dog 对象调用 show 方法 Animal a = new Cat(); // 向上转型 a.eat(); // 调用的是 Cat 的 eat Cat c = (Cat)a; // 向下转型 c.work(); // 调用的是 Cat 的 work } public static void show(Animal a) { a.eat(); // 类型判断 if (a instanceof Cat) { // 猫做的事情 Cat c = (Cat)a; c.work(); } else if (a instanceof Dog) { // 狗做的事情 Dog c = (Dog)a; c.work(); } } } abstract class Animal { abstract void eat(); } class Cat extends Animal { public void eat() { System.out.println(&quot;吃鱼&quot;); } public void work() { System.out.println(&quot;抓老鼠&quot;); } } class Dog extends Animal { public void eat() { System.out.println(&quot;吃骨头&quot;); } public void work() { System.out.println(&quot;看家&quot;); } }6.抽象类 1、抽象类中可以没有抽方法； 2、抽象类中既可以有抽象方法，也可以有普通方法； 3、一个类中只要有一个抽象方法，那么这个类就必须是抽象类； 4、一个类继承一个抽象类必须重写所有的抽象方法，否则这个类就是抽象类； 5、抽象类可以作为参数传递； 6、当方法的参数是抽象类或者接口时，调用这个方法需要抽象类的子类或者接口的实现类","link":"/2019/06/27/Java继承,多态,抽象类,接口基本概念/"},{"title":"Java继承与多态","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/88896985 一、继承继承是由已有类创建新类的机制。子类继承了父类原有的属性与方法，也可以增加新得属性与方法，也可以重写父类中的某些方法。系统默认Object类为所有类的父类。 Java中类没有多继承，接口有多继承。 子类继承父类，可以得到父类的全部属性和方法 (除了父类的构造方法)，但不见得可以直接访问(比如，父类私有的属性和方法)。 示例package able; public class Person { String name; double height,weight; public Person(String name, double height, double weight) { super(); this.name = name; this.height = height; this.weight = weight; } void thing(){ System.out.println(&quot;工作...&quot;); } public String toString() { return &quot;姓名:&quot;+name+&quot;身高:&quot;+height+&quot;体重:&quot;+weight; } public static void main(String[] args) { Student a = new Student(&quot;xxx&quot;,0,0,&quot;1000&quot;,1); Student b = new Student(&quot;xxx&quot;,0,0,&quot;1010&quot;,2); System.out.println(a.equals(b)); new Student(&quot;xxx&quot;,0,0,&quot;1000&quot;,1).thing(); } } class Student extends Person{ public Student(String name, double height, double weight,String id,int grade) { super(name, height, weight); this.id = id; this.grade = grade; // TODO Auto-generated constructor stub } String id; int grade; void thing() { super.thing(); System.out.println(&quot;学习...&quot;); } Person who() { return new Person(&quot;null&quot;,175,60); } @Override public int hashCode() { final int prime = 31; int result = 1; result = prime * result + ((id == null) ? 0 : id.hashCode()); return result; } @Override public boolean equals(Object obj) { if (this == obj) return true; if (obj == null) return false; if (getClass() != obj.getClass()) return false; Student other = (Student) obj; if (id == null) { if (other.id != null) return false; } else if (!id.equals(other.id)) return false; return true; } } student类中的super(name, height, weight);用于调动父类的构造方法 student类中的thing()方法里面的super.thing();用于调动父类的thing()方法 二、方法重写方法重写满足以下规则 “==”： 方法名、形参列表相同。 “≤”：返回值类型和声明异常类型，子类小于等于父类。 “≥”： 访问权限，子类大于等于父类。 以上示例中出现了方法重写J2SE 5.0以上版本可修改重写方法的返回值类型（ 重写的返回值类型必须是父类中同意返回值类型的子类 ） public class TestSubClass { TestSubClass(){ System.out.println(&quot;父类构造方法被调用&quot;); } TestSubClass test() { int a = 1; System.out.println(&quot;父类test()方法被调用&quot;); return new TestSubClass(); } public static void main(String[] args) { SubClass a = new SubClass(); a.test(); } } class SubClass extends TestSubClass{ SubClass(){ System.out.println(&quot;子类构造方法被调用&quot;); } SubClass test() { System.out.println(&quot;子类test()方法被调用&quot;); return new SubClass(); } }测试结果为： 父类构造方法被调用 子类构造方法被调用 子类test()方法被调用 父类构造方法被调用 子类构造方法被调用 由此可知编译器在调动子类构造方法前先调用父类无参构造方法（有参构造方法需显式使用 super 调用 三、Object类Object类主要方法：clone()、finalize()、 equals() 、 toString() 。最常用的是后面2个。Object类中不能被重写的方法（被定义为 final 类型）：getClass()、notify()、notifyAll()、wait()等 public class TestObject { public String toString() { return &quot;在&quot;+getClass().getName()+&quot;类中改写toString()方法&quot;; } public static void main(String[] args) { TestObject test = new TestObject(); System.out.println(test); } } //结果：在TestObject类中改写toString()方法四、封装封装是面向对象的三大特性（ 封装、继承、多态 ）之一，封装简单来讲就是将自己的数据隐藏起来。 举个例子：别人向你借钱，传统的面向过程的做法是别人去你家拿，拿多少有时候你也不知道。面向对象的做法是别人向你发出请求：我要借多少钱，至于你借给他多少，如何借这些都是由你自己内部的机制自己完成。用户不需要知道你的内部结构（实现细节）是怎样的，他只需要拿到钱。 五、多态public class TestPoly { public static void animalCry(Animal a) { a.shout(); } public static void main(String[] args) { Animal a1 = new Dog(); //向上转型 animalCry(a1); a1.shout(); //这句不能通过编译：a1.action(); Animal a2 = new Cat(); animalCry(a2); a2.shout(); Dog d1 = (Dog) a1; //向下转型，需强制类型转换 d1.action(); } } class Animal{ void shout() { System.out.println(&quot;叫了一声&quot;); } } class Dog extends Animal{ void shout() { System.out.println(&quot;旺旺旺&quot;); } void action() { System.out.println(&quot;看门&quot;); } } class Cat extends Animal{ void shout() { System.out.println(&quot;喵喵喵&quot;); } } 3个条件： 继承 ， 方法重写 ， 父类引用指向子类对象 。 父类的引用对象无法调用子类特有的方法 （除非向下转型） 向上转型：从 具体 的类（子类）到 抽象 的类（父类），安全。 向下转型：与向上转型相反，需要显式说明才能转换。 instanceof可以用于判断某个类是否是一个类的子类","link":"/2019/03/30/Java继承与多态/"},{"title":"Leetcode 344 翻转字符串","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/88938238 [ Leetcode 344 翻转字符串 ](https://leetcode-cn.com/problems/reverse-string/submissions/) class Solution { public void reverseString(char[] s) { char temp; int len = s.length; for(int i = 0;i != len/2;i++){ temp = s[i]; s[i] = s[len - 1 - i]; s[len - 1 -i] = temp; } } }","link":"/2019/03/31/Leetcode 344 翻转字符串/"},{"title":"Leetcode 628 三个数的最大乘积","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/88938165 [ Leetcode 628 三个数的最大乘积 ](https://leetcode-cn.com/problems/maximum-product-of-three-numbers/) class Solution { public int maximumProduct(int[] nums) { Arrays.sort(nums); int len = nums.length; int a = nums[0] * nums[1] * nums[len - 1]; int b = nums[len - 1] * nums[len - 2] * nums[len - 3]; return a &gt; b ? a : b; } }","link":"/2019/03/31/Leetcode 628 三个数的最大乘积/"},{"title":"Leetcode 633 平方数之和","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/88938095 [ Leetcode 633 平方数之和 ](https://leetcode-cn.com/problems/sum-of-square-numbers/) class Solution { public: bool judgeSquareSum(int c) { int d = (int)sqrt(c); for(int i = 0;i&lt;=d;i++){ int e = (int)sqrt(c-i*i); if(e*e+i*i==c) return true; } return false; } };","link":"/2019/03/31/Leetcode 633 平方数之和/"},{"title":"Leetcode 217存在重复元素（Java）","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/88938320 [ Leetcode 217 ](https://leetcode-cn.com/problems/contains-duplicate/submissions/) class Solution { public boolean containsDuplicate(int[] nums) { Arrays.sort(nums); int count = 1; for(int i = 0;i&lt;nums.length-1;i++){ if(nums[i]==nums[i+1]){ count++; if(count&gt;=2) return true; } else count = 1; } return false; } }提交速度还行。。。","link":"/2019/03/31/Leetcode 217存在重复元素（Java）/"},{"title":"Leetcode 7整数反转","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/88931621 链接： Here class Solution { public int reverse(int x) { boolean isN = false; if(x &lt; 0) { isN = true; x = -x; } long sum = 0; while(x!=0){ sum = sum * 10 + x%10; x = x / 10; } if(isN){ sum = -sum; } if (sum &gt;Integer.MAX_VALUE || sum &lt; Integer.MIN_VALUE) return 0; return new Long(sum).intValue(); } }","link":"/2019/03/31/Leetcode 7整数反转/"},{"title":"Leetcode 9：回文数","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/88921308 题目链接： 回文数 刚刚注册了Leetcode试了一下，结果n次报错…没有考虑到负数的情况。 class Solution { public: bool isPalindrome(int x) { if(x&lt;0) { return false; } int m = x; long long sum = 0; while (m) { sum = sum * 10 + m % 10; m /= 10; } if (sum == x) { return true; } return false; } };![在这里插入图片描述](https://img-blog.csdnimg.cn/20190330234647726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)","link":"/2019/03/30/Leetcode 9：回文数/"},{"title":"Leetcode136 只出现一次的数字","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/88931701 链接： Here 这道题之前在程序员小灰的漫画里面看过，用异或解。 class Solution { public int singleNumber(int[] nums) { int res = 0; for (int num : nums) res ^= num; return res; } }","link":"/2019/03/31/Leetcode136 只出现一次的数字/"},{"title":"MySQL8 jdbc连接 无法加载主类","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/89741009 之前 mysql 一直连接不上 eclipse 的 jdbc，总是显示 无法找到或加载主类 。 在网上找了很多教程，jdbc驱动包我导入了，代码也没有异常,数据库也正常。 原代码如下： package util; import java.sql.Connection; import java.sql.DriverManager; public class DBHelper { private static final String driver = &quot;com.mysql.jdbc.Driver&quot;; //数据库驱动 //连接数据库的URL地址 private static final String url=&quot;jdbc:mysql://localhost:3306/shopping??useUnicode=true&amp;characterEncoding=UTF-8&quot;; private static final String username=&quot;root&quot;;//数据库的用户名 private static final String password=&quot;&quot;;//数据库的密码 private static Connection conn = null; //静态代码块负责加载驱动 static { try { Class.forName(driver); } catch (ClassNotFoundException e) { // TODO Auto-generated catch block System.out.println(&quot;......&quot;); e.printStackTrace(); } } //单例模式返回数据库连接对象 public static Connection getConnection() throws Exception { if(conn==null) { conn = DriverManager.getConnection(url, username, password); return conn; } return conn; } public static void main(String[] args) { try { Connection conn = DBHelper.getConnection(); if(conn!=null) { System.out.println(&quot;数据库连接正常！&quot;); } else { System.out.println(&quot;数据库连接异常！&quot;); } } catch(Exception ex) { ex.printStackTrace(); } } }最终找到的原因是 URL 后面要加上 useSSL 和 serverTimezone 这两个： private static final String url=&quot;jdbc:mysql://localhost:3306/shopping?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai&quot;; 除此之外driver那一行也应改为： private static final String driver = &quot;com.mysql.cj.jdbc.Driver&quot;;至此，数据库连接成功！","link":"/2019/05/01/MySQL8 jdbc连接 无法加载主类/"},{"title":"MYSQL常用语句","text":"看到一篇关于MYSQL常用语句的博文，在此放上链接： MySQL常用SQL语句大全 方便以后查找","link":"/2019/07/17/MYSQL常用语句/"},{"title":"MySql 8.0.15 安装","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/89462014 安装教程我是对照着这个教程安装的，之前也找过很多其他教程，但最终在这里成功了： http://blog.csdn.net/u013067166/article/details/49951577(https://blog.csdn.net/u013067166/article/details/49951577) 关于服务无法启动，服务没有报告任何错误在这之前我总是遇到服务无法启动，服务没有报告任何错误的情况。最终无意在data目录里的ERR文件里发现：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190422214551251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)套接字地址只能出现一次，也就是说 接口被占用 了。由于我在my.ini的配置文件里指定的端口为3306，所以我在网上搜索到了解决方法： https://blog.csdn.net/Java_Warplane/article/details/46709463 找到套接字3306对应进程，关闭即可。关闭后，服务就可以启动了（我之前安装了Wampserver) [mysqld] # Remove leading # and set to the amount of RAM for the most important data # cache in MySQL. Start at 70% of total RAM for dedicated server, else 10%. # innodb_buffer_pool_size = 128M # Remove leading # to turn on a very important data integrity option: logging # changes to the binary log between backups. # log_bin # These are commonly set, remove the # and set as required. basedir = &quot;D:\\\\mysql-8.0.15-winx64&quot; datadir = &quot;D:\\\\mysql-8.0.15-winx64\\\\data&quot; character-set-server = utf8 port = 3306补充按照上面第一个的安装教程，在服务启动后，需要更改密码由于第一个教程mysql版本较低，更改密码的方式改变了，所以这里补上修改密码的方法。 在服务启动后，会出现这个使用输入以下指令即可 ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;你的密码&apos;;","link":"/2019/04/22/MySql 8.0.15 安装/"},{"title":"Poj 1008 - 玛雅历","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86587228 1. 问题详情 ： 点击查看 2.题目解析 ： 题目给出玛雅的两种历法，要求我们将第一种历法转换成第二种历法 第一种历法：每年365天，分19月，前18月都为20天 第二种历法：每年有20月，每月13天，即每年有20*13=260天 了解两种历法的规则后不难看出整个问题的关键在于将第一种历法下的日期转化为总天数，进而按照第二种历法换算 参考公式(y，m，d分别为年月日)：总天数 = y * 365 + m * 20 + d;换算后的年数 = 总天数 / 260换算后的月数 = 总天数%20换算后的天数 = 总天数%13 + 1： 3.代码示例 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; string Maya[19] = { &quot;pop&quot;, &quot;no&quot;, &quot;zip&quot;, &quot;zotz&quot;, &quot;tzec&quot;, &quot;xul&quot;, &quot;yoxkin&quot;, &quot;mol&quot;, &quot;chen&quot;, &quot;yax&quot;, &quot;zac&quot;, &quot;ceh&quot;, &quot;mac&quot;, &quot;kankin&quot;, &quot;muan&quot;, &quot;pax&quot;, &quot;koyab&quot;, &quot;cumhu&quot;, &quot;uayet&quot; }; string Tzolkin[20] = { &quot;imix&quot;, &quot;ik&quot;, &quot;akbal&quot;, &quot;kan&quot;, &quot;chicchan&quot;, &quot;cimi&quot;, &quot;manik&quot;, &quot;lamat&quot;, &quot;muluk&quot;, &quot;ok&quot;, &quot;chuen&quot;, &quot;eb&quot;, &quot;ben&quot;, &quot;ix&quot;, &quot;mem&quot;, &quot;cib&quot;, &quot;caban&quot;, &quot;eznab&quot;, &quot;canac&quot;, &quot;ahau&quot; }; int main() { int i, n , y, d,sum; string m; char c; cin &gt;&gt; n; cout &lt;&lt; n &lt;&lt; endl; while (n--) { cin &gt;&gt; d &gt;&gt; c &gt;&gt; m &gt;&gt; y;//c用于表示输入格式中的&quot; . &quot; sum = 0; for (i = 0; i &lt; 19; i++) //查找月份对应索引 { if (Maya[i] == m) { sum = y * 365 + i * 20 + d; break; } } y = sum / 260; //转换公式 m = Tzolkin[sum % 20]; d = sum % 13 + 1; cout &lt;&lt; d &lt;&lt; &apos; &apos; &lt;&lt; m &lt;&lt; &apos; &apos; &lt;&lt; y &lt;&lt; endl; } }","link":"/2019/01/22/Poj 1008 - 玛雅历/"},{"title":"Poj 1013 假币","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86598718 1. 题目详情 ： 点击查看 2. 题目分析 ： 题目给出3组硬币称量的数据，包括 左盘的硬币 、 右盘的硬币 和 天平的状态 ，要求我们找出其中的假币（只有1个）并判断它比真币重还是轻 理解完题目有几点要知道：（1） 当天平的状态为平衡（even）时，天平两端的硬币必为真币（2） 处于两种不同状态的硬币一定是真的 以下代码解决的方法是用三个数组来存储硬币的三次状态（初始化数组为0 ）（3）处于even状态的硬币必为真币（even数组）（4）up和down数组存储硬币出现这两种状态的次数，次数差值的绝对值越大，是假币的概率越大（5）满足次数差值绝对值最大且这个对应的硬币不处于even数组这两个条件的硬币就是假币 3.代码示例 #include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; int main() { int n; cin &gt;&gt; n; while (n--) { int even[20] = { 0 }; int up[20] = { 0 }; int down[20] = { 0 }; char list1[3][6], list2[3][6], list3[3][6]; //录入信息并记录状态 for (int i = 0; i &lt; 3; i++) { cin &gt;&gt; list1[i] &gt;&gt; list2[i] &gt;&gt; list3[i]; for(int j = 0;list1[i][j]&amp;&amp;list2[i][j];j++) { switch (list3[i][0]) { case &apos;e&apos;: even[list1[i][j] - &apos;A&apos;]++; even[list2[i][j] - &apos;A&apos;]++; break; case &apos;u&apos;: up[list1[i][j] - &apos;A&apos;]++; down[list2[i][j] - &apos;A&apos;]++; break; case &apos;d&apos;: down[list1[i][j] - &apos;A&apos;]++; up[list2[i][j] - &apos;A&apos;]++; break; default: break; } } } int max = -1; int ans = 0; for (int i = 0; i &lt; 12; i++) { if (down[i] &amp;&amp; up[i]) //2.（2） { even[i]++; } if (even[i]!=0) //2.（3） { continue; } if (abs(down[i] - up[i]) &gt; max) //2.（5） { max = abs(down[i] - up[i]); ans = i; } } cout &lt;&lt; (char)(&apos;A&apos;+ans) &lt;&lt; &quot; is the counterfeit coin and it is &quot; &lt;&lt; (up[ans] &lt; down[ans] ? &quot;light.&quot; : &quot;heavy.&quot;)&lt;&lt;endl; } }","link":"/2019/01/22/Poj 1013 假币/"},{"title":"Servlet初始化参数（Servlet2.5,3.0）","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/96435804 一、使用Servlet2.5初始化参数Servlet2.5是基于 xml 配置的，所以在xml中配置。Servlet3.0开始支持 注解 配置。 配置分两种情况：在当前 Servlet有效 和在 整个web容器 中有效。 对于整个web容器有效的情况下，无论是2.5还是3.0（及以上）都必须在xml中配置。 配置整个web容器有效时使用 &lt;context-param&gt;&lt;/context-param&gt;配置当前Servlet有效时在对应的 &lt;servlet&gt;&lt;/servlet&gt; 使用 &lt;init-param&gt;&lt;/init-param&gt; 配置文件如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt; &lt;context-param&gt; &lt;param-name&gt;globalParamName&lt;/param-name&gt; &lt;param-value&gt;globalParamValue&lt;/param-value&gt; &lt;/context-param&gt; &lt;servlet&gt; &lt;description&gt;&lt;/description&gt; &lt;display-name&gt;TestServlet&lt;/display-name&gt; &lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;TestServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;servletParamName&lt;/param-name&gt; &lt;param-value&gt;servletParamValue&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;TestServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/TestServlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt;读取： public class TestServlet extends HttpServlet { private static final long serialVersionUID = 1L; public TestServlet() { } @Override public void init() throws ServletException { super.init(); String value = super.getInitParameter(&quot;servletParamName&quot;); System.out.println(&quot;当前Servlet的servletParam值为&quot;+value); ServletContext sc = super.getServletContext(); String gValue = sc.getInitParameter(&quot;globalParamName&quot;); System.out.println(&quot;当前Web容器的gobalValue为&quot;+gValue); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { response.getWriter().append(&quot;Served at: &quot;).append(request.getContextPath()); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } }二、使用Servlet3.0初始化参数initParams= {@WebInitParam(name=&quot;servletnameParam30&quot;,value=&quot;servletValue30&quot;)}name和value分别对应 &lt;param-name&gt; &lt;param-value&gt; @WebServlet(value=&quot;/TestServlet&quot;,loadOnStartup=1,initParams= {@WebInitParam(name=&quot;servletnameParam30&quot;,value=&quot;servletValue30&quot;)}) public class TestServlet extends HttpServlet { private static final long serialVersionUID = 1L; /** * Default constructor. */ public TestServlet() { // TODO Auto-generated constructor stub } @Override public void init() throws ServletException { super.init(); String value = super.getInitParameter(&quot;servletnameParam30&quot;); System.out.println(&quot;当前Servlet的servletParam30值为&quot;+value); ServletContext sc = super.getServletContext(); String gValue = sc.getInitParameter(&quot;globalParamName&quot;); System.out.println(&quot;当前Web容器的gobalValue为&quot;+gValue); } /** * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response) */ protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO Auto-generated method stub response.getWriter().append(&quot;Served at: &quot;).append(request.getContextPath()); } /** * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response) */ protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO Auto-generated method stub doGet(request, response); } }","link":"/2019/07/18/Servlet初始化参数（Servlet2.5,3.0）/"},{"title":"SSM 表单字段int为空，400","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/98604083 问题描述表单中一些字段为空的话，如果POJO定义该属性为int型就会报400. 实体类： public class Teacher { private int id; //教师编号 private String name; //教师姓名 private String sex; //性别 private List&lt;Course&gt; courseList; //课程列表 //省略get,set方法与构造器 }前端的表单： &lt;form method=&quot;post&quot; action=&quot;${pageContext.request.contextPath}/teacher/queryTeacher&quot;&gt; 教师号：&lt;input type=&quot;number&quot; name=&quot;id&quot; id=&quot;id&quot;&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;name&quot; id=&quot;name&quot; value=&quot;&quot;&gt; 性别：&lt;label&gt;&lt;input name=&quot;sex&quot; type=&quot;radio&quot; value=&quot;男&quot; /&gt;男 &lt;/label&gt;&amp;nbsp; &lt;label&gt;&lt;input name=&quot;sex&quot; type=&quot;radio&quot; value=&quot;女&quot; /&gt;女 &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;查询&quot; /&gt; &lt;/form&gt;当id为空时，会报400。 解决方案将实体类中int改为Integer https://ask.csdn.net/questions/658351","link":"/2019/08/06/SSM 表单字段int为空，400/"},{"title":"Servlet实现文件上传与下载","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/96480347 一、说明文件的上传需要引入jar包：可以去网上搜索下载(Maven官网等）文件的下载不需要导入jar包 二、项目结构![在这里插入图片描述](https://img-blog.csdnimg.cn/20190719144013593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 三、编写jsp文件&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;style&gt; .preview { width: 300px; height: 300px; } .preview img { margin: 0 auto; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 表单,用于上传文件 --&gt; &lt;form method=&quot;post&quot; action=&quot;file&quot; enctype=&quot;multipart/form-data&quot;&gt; 学号：&lt;input type=&quot;text&quot; name=&quot;sid&quot;/&gt;&lt;br&gt; 姓名：&lt;input type=&quot;text&quot; name=&quot;sname&quot;/&gt;&lt;br&gt; 照片：&lt;input type=&quot;file&quot; name=&quot;filename&quot; id=&quot;file&quot; onchange=&quot;imgChange(this);&quot;/&gt;&lt;br&gt; &lt;!-- 导入照片后显示出来 --&gt; &lt;div id=&quot;preview&quot;&gt; &lt;img id=&quot;imghead&quot; src=&quot;&quot; width= &quot;100%&quot; height=&quot;100%&quot; /&gt; &lt;!--图片显示位置--&gt; &lt;/div&gt; &lt;input type=&quot;submit&quot; &gt; &lt;/form&gt; &lt;!-- 下载文件 --&gt; &lt;a href=&quot;download?filename=img.png&quot;&gt;download img.png&lt;/a&gt; &lt;script type=&quot;text/javascript&quot;&gt; // 选择图片显示 function imgChange(obj) { //获取点击的文本框 var file =document.getElementById(&quot;file&quot;); var imgUrl =window.URL.createObjectURL(file.files[0]); var img =document.getElementById(&apos;imghead&apos;); img.setAttribute(&apos;src&apos;,imgUrl); // 修改img标签src属性值 }; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt;![在这里插入图片描述](https://img-blog.csdnimg.cn/20190719144820373.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 四、编写 FileServlet(上传）说明：此处Tomcat为托管模式，当项目中的class文件出现改动时，Tomcat目录被刷新，文件会消失。 所以 path 可以改为非Tomcat工作路径。 @WebServlet(&quot;/file&quot;) public class FileServlet extends HttpServlet { private static final long serialVersionUID = 1L; public FileServlet() { super(); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(&quot;utf-8&quot;); response.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=UTF-8&quot;); boolean flag = ServletFileUpload.isMultipartContent(request); // 判断前台的form是否有 mutipart属性 if(flag) { DiskFileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(factory); //设置上传文件时，临时文件的大小 factory.setSizeThreshold(10240); //factory.setRepository(new File(&quot;&quot;)); 设置临时文件存储位置 upload.setSizeMax(30*1024); //控制单个文件上传大小 30k try { // 通过parseRequest解析form中的所有请求字段，并保存到 items集合中 List&lt;FileItem&gt; items = upload.parseRequest(request); //获取迭代器，遍历 Iterator&lt;FileItem&gt; iter = items.iterator(); while(iter.hasNext()) { FileItem item = iter.next(); String itemName = item.getFieldName(); int sid = -1; String sname = null; //普通表单字段 还是 文件字段 if(item.isFormField()) { if(itemName.equals(&quot;sid&quot;)) { sid = Integer.parseInt(item.getString()); }else if(itemName.equals(&quot;sname&quot;)) { sname = item.getString(); }else { System.out.println(&quot;其他字段...&quot;); } }else { String fileName = item.getName(); String path = request.getSession().getServletContext().getRealPath(&quot;upload&quot;); File file = new File(path,fileName); //限制上传的格式，可根据情况决定是否保留 String ext = fileName.substring(fileName.indexOf(&quot;.&quot;)+1); if(!(&quot;png&quot;.equals(ext)||&quot;gif&quot;.equals(ext)||&quot;jpg&quot;.equals(ext))) { System.out.println(&quot;格式不正确&quot;); return; } item.write(file); System.out.println(fileName+&quot;上传成功&quot;); return; } } } catch (FileUploadBase.FileSizeLimitExceededException e) { e.printStackTrace(); } catch (FileUploadException e) { e.printStackTrace(); } catch (Exception e) { e.printStackTrace(); } }else { } } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { doGet(request, response); } }五、实现文件的下载这这里上传的是png格式的图片，对应MIME类型为image/png.建议文件名为英文，此处并没有对中文进行处理，若文件名为中文，则下载时文件名可能会乱码。 @WebServlet(&quot;/download&quot;) public class DownloadServlet extends HttpServlet { private static final long serialVersionUID = 1L; public DownloadServlet() { super(); // TODO Auto-generated constructor stub } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(&quot;utf-8&quot;); //获取要下载的文件名 String filename = request.getParameter(&quot;filename&quot;); System.out.println(filename); //下载文件 设置消息头 response.addHeader(&quot;Content-Type&quot;, &quot;image/png&quot;);//MIME类型 response.addHeader(&quot;content-Disposition&quot;,&quot;attachment;filename=&quot;+filename); //Servlet通过文件的地址 将文件转为输入流 读到Servlet中 InputStream in = getServletContext().getResourceAsStream(&quot;/&quot;+filename); ServletOutputStream out = response.getOutputStream(); byte[] b =new byte[1024]; int i = -1; while((i=in.read(b))!=-1) { out.write(b, 0, i); } out.close(); in.close(); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { // TODO Auto-generated method stub doGet(request, response); } }","link":"/2019/07/19/Servlet实现文件上传与下载/"},{"title":"Spring  使用注解实现事务","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/97178384 第一步，准备好jar包除了Spring最基本的6个jar包： spring-aop.jar 开发AOP特性时需要的JAR spring-beans.jar 处理Bean的jar &lt;bean&gt; spring-context.jar 处理spring上下文的jar &lt;context&gt; spring-core.jar spring核心jar spring-expression.jar spring表达式 commons-logging.jar 第三方日志 点我下载jar包 还需要： spring-tx-4.3.9.RELEASE mysql-connector-java-8.0.15.jar 数据库驱动 commons-dbcp.jar 连接池使用到数据源 commons-pool.jar 连接池 spring-jdbc-4.3.9.RELEASE.jar aopalliance.jar 黏贴到src目录下，右键- bulid path即可。 第二步，配置首先要 添加 tx 命名空间 ，在下载完STS插件后，点击tx即可![在这里插入图片描述](https://img-blog.csdnimg.cn/20190724224146476.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)添加后开始配置： 思路：首先配这个： &lt;!-- 增加对事务的支持 tx命名空间--&gt; &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt;发现它需要配置一个txManager，于是配置txManager： &lt;!-- 配置事务管理器 txManager --&gt; &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt; &lt;/property&gt; &lt;/bean&gt;配置txManager需要一个dataSource，所以我们还要配置一个： &lt;!-- 配置数据库相关 事务 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/db_stu?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;useSSL=false&amp;amp;serverTimezone=Asia/Shanghai&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; &gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; &gt;&lt;/property&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;6&quot;&gt;&lt;/property&gt; &lt;/bean&gt;这样就把思路理清了，总的配置如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd&quot;&gt; &lt;!-- 配置数据库相关 事务 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/db_stu?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;useSSL=false&amp;amp;serverTimezone=Asia/Shanghai&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; &gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; &gt;&lt;/property&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;6&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 txManager --&gt; &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 增加对事务的支持 tx命名空间--&gt; &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt; &lt;/beans&gt;最后一步，使用注解在需要添加事务控制的地方，写上: @Transactional 这里引用一些其他博主写的博客 spring 使用注解方式进行事务管理","link":"/2019/07/24/Spring  使用注解实现事务/"},{"title":"Spring 各种集合的注入（Set,Map,String[],List,Properties）","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/97171197 首先先写一个类，包含各种集合： public class CollectionTypes { private List&lt;String&gt; list; private String[] array; private Set&lt;String&gt; set; private Map&lt;String,String&gt; map; private Properties property; public CollectionTypes() { } public CollectionTypes(List&lt;String&gt; list, String[] array, Set&lt;String&gt; set, Map&lt;String, String&gt; map, Properties property) { super(); this.list = list; this.array = array; this.set = set; this.map = map; this.property = property; } public List&lt;String&gt; getList() { return list; } public void setList(List&lt;String&gt; list) { this.list = list; } public String[] getArray() { return array; } public void setArray(String[] array) { this.array = array; } public Set&lt;String&gt; getSet() { return set; } public void setSet(Set&lt;String&gt; set) { this.set = set; } public Map&lt;String, String&gt; getMap() { return map; } public void setMap(Map&lt;String, String&gt; map) { this.map = map; } public Properties getProperty() { return property; } public void setProperty(Properties property) { this.property = property; } @Override public String toString() { String s = &quot;&quot;; for(String content:array) { s += content+&quot; &quot;; } return &quot;list:&quot;+this.list+&quot;\\n&quot;+ &quot;String[]:&quot;+s+&quot;\\n&quot;+ &quot;Set:&quot;+set+&quot;\\n&quot;+ &quot;Map:&quot;+map+&quot;\\n&quot;+ &quot;Properties:&quot;+property; } }然后开始配置文件：name对应的是类中的属性名每个集合属性都有着对应的标签： List： &lt;list&gt; String[]： &lt;array&gt; Set： &lt;set&gt; Map： &lt;map&gt; Properties： &lt;props&gt; &lt;!-- 各种集合的注入 --&gt; &lt;bean id=&quot;collection&quot; class=&quot;com.test.entity.CollectionTypes&quot;&gt; &lt;property name=&quot;list&quot;&gt; &lt;list&gt; &lt;value&gt;one&lt;/value&gt; &lt;value&gt;two&lt;/value&gt; &lt;value&gt;three&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=&quot;array&quot;&gt; &lt;array&gt; &lt;value&gt;s1&lt;/value&gt; &lt;value&gt;s2&lt;/value&gt; &lt;value&gt;s3&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=&quot;set&quot;&gt; &lt;set&gt; &lt;value&gt;set1&lt;/value&gt; &lt;value&gt;set2&lt;/value&gt; &lt;value&gt;set3&lt;/value&gt; &lt;/set&gt; &lt;/property&gt; &lt;property name=&quot;map&quot;&gt; &lt;map&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;one&lt;/value&gt; &lt;/key&gt; &lt;value&gt;1&lt;/value&gt; &lt;/entry&gt; &lt;entry&gt; &lt;key&gt; &lt;value&gt;two&lt;/value&gt; &lt;/key&gt; &lt;value&gt;2&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;property name=&quot;property&quot;&gt; &lt;props&gt; &lt;prop key=&quot;p1&quot;&gt;1&lt;/prop&gt; &lt;prop key=&quot;p2&quot;&gt;2&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;写个类测试一下： public class Test { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); CollectionTypes collection = (CollectionTypes) context.getBean(&quot;collection&quot;); System.out.println(collection); } }测试结果如下：","link":"/2019/07/24/Spring 各种集合的注入（Set,Map,String[],List,Properties）/"},{"title":"SpringMVC 无法跳转到Controller","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/97400968 今天纪录一个困扰我一天的问题：自己写的Controller无法跳转。 我的配置首先来看一下我的配置：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190726181255910.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)首先是我的Controller，我使用的是注解 + 扫描器的方式配置 Hello.java(Controller) @Controller @RequestMapping(value=&quot;say&quot;) public class Hello { @RequestMapping(value=&quot;hello&quot;) public String hello() { return &quot;hello&quot;; } }SpringMVC的配置文件我采用的是 约定 方式，在WEB-INF下配置 dispatcherServlet-servlet.xml 。 注：另一种方式是自己写配置文件，随便命名，但是在web.xml配置dispatcherServlet时需要用 &lt;init-param&gt;指定路径 dispatcherServlet-servlet.xml(SpringMVC配置文件) &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.3.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd&quot;&gt; &lt;!-- 扫描器 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;mvc:annotation-driven/&gt; &lt;context:component-scan base-package=&quot;org.test.controller&quot;&gt;&lt;/context:component-scan&gt; &lt;!-- 配置视图解析器 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;property name=&quot;viewClass&quot; value=&quot;org.springframework.web.servlet.view.JstlView&quot; /&gt; &lt;property name=&quot;prefix&quot; value=&quot;/view/&quot;&gt;&lt;/property&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/beans&gt;然后就是web.xml web.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;2.5&quot;&gt; &lt;display-name&gt;SpringMVCProject1&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc-config.xml&lt;/param-value&gt; &lt;/init-param&gt;--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;/web-app&gt;最后再来看一下我index.jsp中的路径 index.jsp &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot;%&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Insert title here&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;say/hello&quot;&gt;Click me.&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 吐槽一开始我以为是我的SpringMVC的配置有问题，于是上网找各种配置 但是运行起来也没有任何报错，于是我又在Controller里面打印一句话，当Controller运行时我就知道了。 控制台没有输出，故Controller并没有运行。于是我怀疑是路径错了，又开始上网看路径。。。 后来过了很久很久… 运行一下这个: public class Test { public static void main(String[] args) { Hello hello = new Hello(); System.out.println(hello.hello()); } }发现 找不到main方法 ，于是上网搜解决方法：[添加链接描述],( https://blog.csdn.net/Victory_nan/article/details/86633922 ) ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190726185500565.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)最终终于解决了…","link":"/2019/07/26/SpringMVC 无法跳转到Controller/"},{"title":"String Task CodeForces - 118A","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/84837037 String Task CodeForces - 118APetya started to attend programming lessons. On the first lesson his task wasto write a simple program. The program was supposed to do the following: inthe given string, consisting if uppercase and lowercase Latin letters, it:deletes all the vowels,inserts a character “.” before each consonant, replaces all uppercaseconsonants with corresponding lowercase ones. Vowels are letters “A”, “O”,“Y”, “E”, “U”, “I”, and the rest are consonants. The program’s input isexactly one string, it should return the output as a single string, resultingafter the program’s processing the initial string.Help Petya cope with this easy task. InputThe first line represents input string of Petya’s program. This string onlyconsists of uppercase and lowercase Latin letters and its length is from 1 to100, inclusive. OutputPrint the resulting string. It is guaranteed that this string is not empty. Input Outout Tour .t.r Codeforces .c.d.f.r.c.s aBAcAba .b.c.b 问题链接： String Task CodeForces - 118A 问题简述：输入字符串，删去其中的元音字母 “A”, “O”, “Y”, “E”, “U”, “I”，并在每个辅音字母前插入”.”，辅音字母全转换为小写。问题分析：（1）先将字符串中所有的字母转换为小写； （2）用另一个字符串存储（1）所获得的字符串所有辅音字母（非元音字母）；（3）输出字符串。 以下为Accepted的C++代码： #include &lt;iostream&gt; #include &lt;cstring&gt; using namespace std; int main() { int i,j=0, len1,len2; char a[101]; char b[101]; //字符串的长度为[1,100] cin &gt;&gt; a; len1 = strlen(a); for (i = 0; i &lt; len1; i++)//步骤（1）：转换为小写 { if (a[i] &gt;= &apos;A&apos;&amp;&amp;a[i] &lt;= &apos;Z&apos;) { a[i] += 32; } } for (i = 0; i &lt; len1; i++)//步骤（2）：存储字符串中的非元音字母 { if (a[i] != &apos;a&apos; &amp;&amp; a[i] != &apos;o&apos; &amp;&amp; a[i] != &apos;y&apos; &amp;&amp;a[i]!=&apos;e&apos;&amp;&amp; a[i] != &apos;u&apos; &amp;&amp; a[i] != &apos;i&apos;)//&quot;A&quot;, &quot;O&quot;, &quot;Y&quot;, &quot;E&quot;, &quot;U&quot;, &quot;I&quot;为元音字母 b[j++] = a[i]; } b[j] = &apos;\\0&apos;; len2 = strlen(b); for (i = 0; i &lt; len2; i++)//步骤（3）：输出字符串 { cout &lt;&lt; &quot;.&quot; &lt;&lt; b[i]; } }","link":"/2018/12/05/String Task CodeForces - 118A/"},{"title":"Stones on the Table CodeForces - 266A","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/84843939 Stones on the Table CodeForces - 266ATime limit：2000 ms Memory limit：262144 kBSource：Codeforces Round #163 (Div. 2)Tag：simplementation *800Editorial：Announcement TutoriaProblem Description：There are n stones on the table in a row, each of them canbe red, green or blue. Count the minimum number of stones to take from thetable so that any two neighboring stones had different colors. Stones in a roware considered neighboring if there are no other stones between them. Input：The first line contains integer n (1 ≤ n ≤ 50) — the number of stones onthe table.The next line contains string s, which represents the colors of thestones. We’ll consider the stones in the row numbered from 1 to n from left toright. Then the i-th character s equals “R”, if the i-th stone is red, “G”, ifit’s green and “B”, if it’s blue. Output：Print a single integer — the answer to the problem. Sample Input：3RRG Sample Output：1 Sample Input： 5RRRRR Sample Output：4 Sample Input： 4BRBG Sample Output：0 问题链接： Stones on the Table CodeForces - 266A 问题简述：有一排彩色的石头，问最少拿走几个时，每两个相邻的石头颜色不同。问题分析：自己多写几个不同的序列，通过比较分析得出：当每两个相邻的颜色相同的石头拿掉其中一个时，拿的次数最少。AC代码如下： #include &lt;iostream&gt; using namespace std; int main() { int n; char a[51]; while (cin &gt;&gt; n) { int m, count = 0; cin &gt;&gt; a; for (m = 0; m &lt; n; m++) { if (a[m] == a[m + 1])//当相邻两个石头颜色相同时，取出一个，次数加一 count++; } cout &lt;&lt; count &lt;&lt; endl; } }","link":"/2018/12/05/Stones on the Table CodeForces - 266A/"},{"title":"Visual Studio 2017美化（修改字体，图片背景）","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86765404 对自己的 Microsoft Visual Studio 2017 美化，效果如下：![在这里插入图片描述](https://img-blog.csdnimg.cn/2019020513512363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 背景图片 提取码：l451 图片背景你只需下载两个插件 （ MoeIDE 和 Color Theme Editor for Visual Studio 2017 ）和一个透明主题即可。 点击 *工具 - &gt; 拓展和更新 -&gt; 联机 -&gt; 搜索 * 将名称输入后即可下载![在这里插入图片描述](https://img-blog.csdnimg.cn/20190205143024849.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)![在这里插入图片描述](https://img-blog.csdnimg.cn/20190205143232115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 下载完成后 退出Visual studio安装 待两个插件都安装完成后会弹出以下界面 这个时候 导入透明主题 （import theme）没弹出也可打开 *工具 - &gt; Customize Colors * 进行导入透明主题网上有很多，这里提供一个 [ 透明主题 提取码：rh3a ](https://pan.baidu.com/s/1LmYNyk01D7UVk7Bxb-ZJ_g)![在这里插入图片描述](https://img-blog.csdnimg.cn/20190205143539156.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)![在这里插入图片描述](https://img-blog.csdnimg.cn/20190205143852675.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)点击 Apply 完成导入 *工具 - &gt; 选项中设置背景图片 *![在这里插入图片描述](https://img-blog.csdnimg.cn/20190205144420183.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 修改字体*工具 - &gt; 选项 -&gt; 环境 -&gt; 字体和颜色 *![在这里插入图片描述](https://img-blog.csdnimg.cn/20190205144720642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)按照自己喜好调整字体和字体大小即可这里安利几款字体（以下均为11号大小展示效果 ）： Inconsolata ** 提取码：xeki（点击下载，下载后直接安装就可以在编译器内找到）![在这里插入图片描述](https://img-blog.csdnimg.cn/2019020514570513.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)**Consolas （好像和上面那个没什么区别，自己调试，慢慢品味，内置字体）![在这里插入图片描述](https://img-blog.csdnimg.cn/20190205150557631.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)Courier New 内置字体Terminal 内置字体 比上面那个长一点![在这里插入图片描述](https://img-blog.csdnimg.cn/20190205151130276.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)","link":"/2019/02/05/Visual Studio 2017美化（修改字体，图片背景）/"},{"title":"eclipse java-ee 导入jdbc驱动","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/89931923 创建一个项目，点击右键-&gt;Build Path-&gt;Configure Build Path…![在这里插入图片描述](https://img-blog.csdnimg.cn/2019050723261816.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)进入以上界面后切换到Libraries，点击Add External JARs…导入即可","link":"/2019/05/07/eclipse java-ee 导入jdbc驱动/"},{"title":"css 笔记(margin,padding)","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/90680673 1.行内元素不能指定上下外边距 (margin-top,margin-bottom)&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; body { background: #0094ff; } span{ margin: 100px; background: blue; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--行内元素不能指定上下外边距--&gt; &lt;span&gt;行内元素&lt;/span&gt; &lt;/body&gt; &lt;/html&gt;上下外边距不生效，另外要行内元素要 避免内边距的使用 ，因为预期效果可能不好。![在这里插入图片描述](https://img-blog.csdnimg.cn/20190529232938895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 2. 外边距合并问题(子块在父块中塌陷）&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; body { background: #0094ff; } .father { width: 400px; height: 400px; background: #b200ff; } .son { width: 200px; height: 200px; background: pink; margin: 100px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!--外边距合并问题--&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;![在这里插入图片描述](https://img-blog.csdnimg.cn/20190529233631622.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 我们的预期效果是 子块居中在父块当中，但是我们发现父块却移动了，子块与父块之间的上边距也没有生效。 解决方案 ： 父块加入 overflow: hidden;![在这里插入图片描述](https://img-blog.csdnimg.cn/20190529234032125.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 为父块加入边框,例: border: 1px solid purple;![在这里插入图片描述](https://img-blog.csdnimg.cn/20190529234310613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 3.文字垂直居中： 设置行高等于块的高度&lt;html lang=&quot;en&quot; xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; div { width: 100px; height: 50px; line-height: 50px; border: 1px solid purple; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; 文字垂直居中 &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;![在这里插入图片描述](https://img-blog.csdnimg.cn/20190529235407794.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 4.width &gt; padding &gt; margin 在布局时优先使用 width ,其次padding,最后margin width基本不会出现问题 padding会影响盒子大小，需要计算 margin会出现外边距合并等问题，最后使用 5.浮动首先创建块， 浮动的元素总是找到他最近的父级元素对齐，但是不会超出内边距的范围&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father { width: 400px; height: 400px; background: red; border: 3px solid yellow; padding: 10px; } .son { width: 200px; height: 200px; background: purple; float: right; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;father&quot;&gt; &lt;div class=&quot;son&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;![在这里插入图片描述](https://img-blog.csdnimg.cn/20190530173346518.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 6.浮动元素不占位置，父块很多时候不方便指定高度，此时布局会改变，因此要清除浮动（更准确来说是清除浮动造成的影响。&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; .father { width: 400px; background: pink; } .son1 { width:100px; height: 100px; background: purple; float: left; } .son2 { width: 100px; height: 100px; background: hotpink; float: left; } .other { width: 300px; height: 200px; background: blue; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;father clearfix&quot;&gt; &lt;div class=&quot;son1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;son2&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;other&quot;&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt;![在这里插入图片描述](https://img-blog.csdnimg.cn/20190530215748658.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)1.在浮动元素加个空块 &lt;div style=&quot;clear: both&quot;&gt;&lt;/div&gt;缺点：结构化较差，繁琐2.父级添加overflow属性 overflow: hidden | scroll | auto;缺点：内容增多时有时会无法显示需要溢出的元素3.after伪类元素 .clearfix:after { content:&quot;.&quot;; display:block; height:0; visibility:hidden; clear:box; } .clearfix { *zoom: 1;/*兼容ie6 7*/ }4.双伪类元素 .clearfix:before,.clearfix:after{ content: &quot;&quot;; display: table; } .clearfix:after { clear: both; } .clearfix { *zoom: 1; }未完待续…","link":"/2019/05/30/css 笔记(margin,padding)/"},{"title":"jsp九大内置对象","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/96142398 一、pageContext对象二、request对象 请求对象 （client）存储 “客户端向服务端发送的请求信息” request对象的常见方法： 方法 说明 String getParameter(String name) 根据请求的字段名key （input标签的name属性值） ，返回字段值value （input标签的value属性值） String[] getParameterValues(String name): 根据请求的字段名key ，返回多个字段值value （checkbox） void setCharacterEncoding(“编码格式utf-8”) 设置post方式的请求编码 （tomcat7以前默认iso-8859-1，tomcat8以后改为了utf-8） getRequestDispatcher(“b.jsp”).forward(request,response) ; 请求转发 跳转页面 A - &gt; B ServletContext getServerContext() 获取项目的ServletContext对象 使用getParameter()时要可能会出现编码问题，解决方法如下： 对于get的提交方式 方法1(不推荐） String name = request.getParameter(&quot;boy&quot;); name = new String(name.getBytes(“ISO-8859-1”),”utf-8”); * 方法2 修改server.xml ，一次性的 更改tomcat默认get提交方式的编码 （utf-8） 对于post的提交方式 request.setCharacterEncoding(&quot;utf-8&quot;); 三、response 响应对象 (server)提供的方法： void addCookie( Cookie cookie ); 服务端向客户端增加cookie对象 void sendRedirect(String location ) throws IOException; 页面跳转的一种方式（重定向） void setContetType(String type) 设置服务端响应的编码（设置服务端的contentType类型） 请求转发与重定向 | 请求转发 | 重定向—|—|—地址栏是否改变 | 不变 | 改变是否保留第一次请求时的数据 | 保留 | 不保留请求的次数 | 1 | 2跳转发生的位置 | 服务端 | 客户端发出的第二次跳转 四、session 对象 (server)session: 会话 常见场景： a.浏览网站：开始-关闭 b.购物： 浏览、付款、退出 c.电子邮件：浏览、写邮件、退出 session机制： 客户端第一次请求服务端时,出现以下行为： 服务端会产生一个session对象（用于保存该客户的信息）； 并且每个session对象 都会有一个唯一的 sessionId( 用于区分其他session); 服务端会产生一个cookie，并且该cookie的name=JSESSIONID ,value=服务端sessionId的值； 然后 服务端会在 响应客户端的同时 将该cookie发送给客户端，至此 客户端就有了 一个cookie(JSESSIONID)； 因此，客户端的cookie就可以和服务端的session一一对应（JSESSIONID - sessionID） 客户端第二/n次请求服务端时:服务端会先用客户端cookie种的JSESSIONID去服务端的session中匹配sessionid,如果匹配成功（cookie jsessionid和sesion sessionid），说明此用户不是第一次访问,无需登录； 提供的方法： 方法 说明 String getId() 获取sessionId boolean isNew() 判断是否是 新用户（第一次访问） void invalidate() 使session失效 （退出登录、注销） void setAttribute() Object getAttribute() void setMaxInactiveInterval(秒) 设置最大有效 非活动时间 int getMaxInactiveInterval() 获取最大有效 非活动时间 五、Application对象 服务器启动后自动产生 所有客户共享这个内置的Application对象。 六、out对象用来向客户端输出数据。 七、config对象八、page对象九、exception对象在处理异常的网页中可以直接访问exception隐式对象。","link":"/2019/07/16/jsp九大内置对象/"},{"title":"poj 1005","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86490141 poj 10051.题目链接 ： poj 1005 2.题目解析 ： 题目告诉我们有一块半圆土地，以每年50个单位消失，问几年后开始完全消失 题目给出坐标，以次我们可以计算出半径，进而计算出这块土地的面积 根据题意，可得到公式：年数 = ½ πr² / 50 + 1（年数要取整，故加1） 3.代码示例 #include &lt;stdio.h&gt; #define PI 3.141592654 int main() { int n,m,num; double x, y; scanf(&quot;%d&quot;, &amp;n); m = 1; while (n--) { scanf(&quot;%lf&quot;, &amp;x); scanf(&quot;%lf&quot;, &amp;y); num = 0.5 * PI * (x*x + y * y) / 50 + 1; printf(&quot;Property %d: This property will begin eroding in year %d.\\n&quot;, m++,num); } printf(&quot;END OF OUTPUT.&quot;); }","link":"/2019/01/15/poj 1005/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/09/08/hello-world/"},{"title":"poj1003","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86485052 一、问题描述 poj 1003 二、问题解析实际上是求 1/2+ 1/3 + 1/4 + … + 1/(n + 1) 大于 题目给定的浮点数 c 时，n所需的最小值。 三、代码示例注意： 输入c时用的是%lf而不是%f，这是因为c是double型的，这两个不能混用. #include &lt;stdio.h&gt; int a[1000] = { 0 }; int main() { double i,sum,c = 0; int k,j = 0; scanf(&quot;%lf&quot;, &amp;c); while (c - 0 &gt;= 0.01) { sum = 0; for (i = 2; sum &lt; c; i++) { sum += 1 / i; } a[j++] = (int)(i - 2); scanf(&quot;%lf&quot;, &amp;c); } for (k = 0; k &lt; j; k++) { printf(&quot;%d card(s)\\n&quot;,a[k]); } }","link":"/2019/01/14/poj1003/"},{"title":"poj1002","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86484615 一、题目详情 poj - 1002 二、题目解析（1） 题目说电话号码有多种形式：纯数字，数字与字母结合，纯英文（2） 题目还给出了多组映射关系： A，B和C映射到2 D、E和F映射到3 G，H，I映射到4 J，K和L映射到5 M，N和O映射到6 P，R和S映射到7 T，U和V映射到8 W，X和Y映射到9 Q和Z没有对应关系 连字符‘ - ’可以忽略 以此我们可以将任意号码化为纯数字的标准形式 TUT-GLOP is 888-4567 310-GINO is 310-4466 3-10-10-10 is 310-1010. （3） 题目提供多组数据，要求我们将其 标准化 ，并按 升序 格式输出，输出的同时 输出出现次数，如果输入中没有重复项则输出 No duplicates.例如： 12 4873279 ITS-EASY 888-4567 3-10-10-10 888-GLOP TUT-GLOP 967-11-11 310-GINO F101010 888-1200 -4-8-7-3-2-7-9- 487-3279 结果为 310-1010 2 487-3279 4 888-4567 3 （4） 本文提供了一种较为简便但耗费大的方法：将电话号码标准化后以下标的形式储存起来，接下来就遍历这个数组，按题目要求的格式输出。 由于数组的长度非常大，所以遍历起来耗时间长，但这样做的好处是省去了排序的步骤。 三、代码示例以下为纯C代码 #include &lt;stdio.h&gt; #define MAXN 10000000 //电话号码数字最多为7位 int b[MAXN + 1] = { 0 }; int map(char c) //映射关系 { if (&apos;0&apos; &lt;= c &amp;&amp; c &lt;= &apos;9&apos;) return c - &apos;0&apos;; else if (c == &apos;A&apos; || c == &apos;B&apos; || c == &apos;C&apos;) return 2; else if (c == &apos;D&apos; || c == &apos;E&apos; || c == &apos;F&apos;) return 3; else if (c == &apos;G&apos; || c == &apos;H&apos; || c == &apos;I&apos;) return 4; else if (c == &apos;J&apos; || c == &apos;K&apos; || c == &apos;L&apos;) return 5; else if (c == &apos;M&apos; || c == &apos;N&apos; || c == &apos;O&apos;) return 6; else if (c == &apos;P&apos; || c == &apos;R&apos; || c == &apos;S&apos;) return 7; else if (c == &apos;T&apos; || c == &apos;U&apos; || c == &apos;V&apos;) return 8; else if (c == &apos;W&apos; || c == &apos;X&apos; || c == &apos;Y&apos;) return 9; else return -1; } int main() { int n; char a[101]; scanf(&quot;%d&quot;, &amp;n); while (n--) //输入数据并将其化为数组下标的形式 { scanf(&quot;%s&quot;,a); int tel = 0; for (int j = 0; a[j]; j++) { int t = map(a[j]); if (t == -1) { continue; } tel = tel * 10 + t; } b[tel]++; } int flag = 0; //判断是否有重复项 for (int i = 0; i &lt; MAXN; i++) { if (b[i] &gt; 1) { flag = 1; printf(&quot;%d-%d %d\\n&quot;, i / 10000, i % 10000, b[i]);//标准化输出 } } if (flag == 0) { printf(&quot;No duplicates.\\n&quot;); } return 0; }","link":"/2019/01/14/poj1002/"},{"title":"poj1007","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86489983 poj10071.题目链接 ： poj 1007 2.题目解析 ： 题目要求我们按字符串的逆序数大小将字符串排序并输出 关于逆序数 DAABEC D的右边的4个字母要大：A A B C A比右边的0个字母要大 A比右边的0个字母要大 B比右边的0个字母要大 E右边的1个字母要大：C 故逆序数为4 + 1 = 5 故题目的要点在于求逆序数和将它们排序 3.代码示例以下代码中定义了一个结构，方便对字符串操作。排序方法采用了冒泡排序法。 #include &lt;stdio.h&gt; struct Ron { char c[101]; int Rev; }; Ron ron[101] = { 0,0 }; Ron temp = { 0,0 }; int main() { int m,n,i,j,k;//m:长度 n：数据个数 scanf(&quot;%d%d&quot;, &amp;m, &amp;n); for (i = 0; i &lt; n; i++) { scanf(&quot;%s&quot;, ron[i].c); for (j = 0; j &lt; m; j++) //求逆序数 { for (k = j; k &lt; m; k++) { if (ron[i].c[j] &gt; ron[i].c[k]) { ron[i].Rev++; } } } } for (i = 0; i &lt; n; i++) //对数据排序 { for (j = i + 1; j &lt; n; j++) { if (ron[i].Rev &gt; ron[j].Rev) { temp = ron[i]; ron[i] = ron[j]; ron[j] = temp; } } } for (i = 0; i &lt; n; i++) { printf(&quot;%s\\n&quot;, ron[i].c); } }","link":"/2019/01/15/poj1007/"},{"title":"struts2.5 eclipse环境配置 及 xml的一些坑","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/90209674 1.struts包导入首先百度struts2，点击第二个进入官网下载![在这里插入图片描述](https://img-blog.csdnimg.cn/20190514162812935.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)下载完成后解压![在这里插入图片描述](https://img-blog.csdnimg.cn/20190514162917334.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)里面的文件结构如上所示，点开 lib ，发现里面有很多jar包![在这里插入图片描述](https://img-blog.csdnimg.cn/20190514163007627.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)根据自己需要，将所需jar包复制，黏贴到项目的lib文件夹下![在这里插入图片描述](https://img-blog.csdnimg.cn/20190514163150401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)文件结构如上图所示 2.xml配置step1导入完成后还需要配置xml文件， xml文件可在新建项目时勾选（提示：新建Dynamic Web Project项目后 一直点next ，就是如下界面）![在这里插入图片描述](https://img-blog.csdnimg.cn/20190514163333666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)如果忘记勾选也没事，将鼠标移到项目名旁边，鼠标右击选择 Java EE tools里面的第二个选项就是了 step2打开后有些人显示![在这里插入图片描述](https://img-blog.csdnimg.cn/20190514163901730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)上图中点击Source就可以切换了 (控制台上面）点开后默认如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;display-name&gt;StrutsForm&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt;加入代码后如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;filter&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;struts&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;display-name&gt;StrutsForm&lt;/display-name&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;index.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;welcome-file&gt;default.html&lt;/welcome-file&gt; &lt;welcome-file&gt;default.htm&lt;/welcome-file&gt; &lt;welcome-file&gt;default.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt;filter-name可以随便取，url-pattern一般默认如上，filter-class就不能随便配置了 step3![在这里插入图片描述](https://img-blog.csdnimg.cn/20190514164509267.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)选中那些jar包( 提示：将鼠标移到第一个文件，然后shift键，再按下方向键中的下，以此类推 ），鼠标右击，选择 Build PathBuild Path后就会出现上图中的 Referenced Libraries ,点开它，在struts2-core-xxx.jar里面找到org.apache.struts2.dispatcher.filter![在这里插入图片描述](https://img-blog.csdnimg.cn/20190514164713696.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)如下：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190514164822899.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)在上面蓝色部分区域，右键， Copy Qualified Name ，然后黏贴到filter-class里面。","link":"/2019/05/14/struts2.5 eclipse环境配置 及 xml的一些坑/"},{"title":"一维多项式求值","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86645962 这里提供两种方法求一维多项式的值 一、代入法顾名思义，就是将未知量的值代入多项式中直接求解。同样的，我们还是用数组表示多项式的各个系数，用数组计算。 double polynomial_1(double A[], int n, double x) { int i; double result = A[0]; for (i = n - 1; i &gt;= 1; i--) { result += A[i] * pow(x, i); } return result; }二、秦九韶算法秦九韶算法是中国南宋时期的数学家秦九韶提出的一种多项式简化算法。 对于一个n次多项式：我们可以这样化简： ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190125143848241.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)它变成了若干次的加法与乘法运算，运算时从最里面的括号开始计算 。如 4x^4 - 2x^3 + x - 1 = (((4x - 2)x - 0)x + 1)x - 1 double polynomial_2(double A[], int n, double x) { int i; double result = A[n - 1]; for(i = n - 2;i&gt;=0;i--) { result = result * x + A[i]; } return result; }运行这两种算法： #include &lt;iostream&gt; #include &lt;cmath&gt; using namespace std; double polynomial_1(double A[], int n, double x) { int i; double result = A[0]; for (i = n - 1; i &gt;= 1; i--) { result += A[i] * pow(x, i); } return result; } double polynomial_2(double A[], int n, double x) { int i; double result = A[n - 1]; for(i = n - 2;i&gt;=0;i--) { result = result * x + A[i]; } return result; } //4x^4-2x^3+x-1 = (((4x - 2)x - 0)x+1)x - 1 int main() { double A[] = { -1,1,0,-2,4 }; cout &lt;&lt; polynomial_1(A, 5, 1)&lt;&lt;endl; cout &lt;&lt; polynomial_2(A, 5, 1) &lt;&lt; endl; }对于多项式 4x^4 - 2x^3 + x - 1 ，当 x = 1 时，多项式的值为2：","link":"/2019/01/25/一维多项式求值/"},{"title":"三种常见排序方法","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86163362 一、选择排序法1.1 可看可不看在了解这三种排序算法前，先解释一个概念：墙(wall)。 在这三中排序算法中，为了区分已排序序列与未排序序列，于是我们设置一堵墙把它们区分开来。 这堵墙的具体表现形式为它限制了排序的可操作范围，在程序中表现为在循环中变量的取值范围。 如： for (i = 0; i &lt; n; i++) { for (j = i + 1; j &lt; n; j++) { //...... } }在这段代码中，随着i的变化，每次j的初值都会发生变化，内层循环的次数也发生了变化。这个过程就像一堵无形的墙在不断移动，从而限制了行动。（这个概念不急于理解，观看以下内容，便不难理解） 1.2 算法描述1.2.1 算法思想 选择排序的基本思想是：每一趟在n-i+1（i=1，2，…n-1）个记录中选取关键字最小的记录作为有序序列中第i个记录。 简单来讲，给定n个无序的数第一趟：在这n个数中求得最小值，将其放在序列最左边。第二趟：在除第一个已排列好的数外的其它n-1个数继续求最小值，放在第二个位置。第三躺：在除已排列好的两个数外的其它n-2个数中求最小值，放在第三个位置。…1.2.2 动图演示 1.2.3 例子以下例子中的 “ { ” 就相当于是墙，墙左边是已排序部分，墙右边是未排序部分。 0 初始序列：{ 49 27 65 97 76 12 38 } 1 12与49交换：12 { 27 65 97 76 49 38 } 2 27不动 ：12 27 { 65 97 76 49 38 } 3 65与38交换：12 27 38 { 97 76 49 65 } 4 97与49交换：12 27 38 49 { 76 97 65 } 5 65与76交换：12 27 38 49 65 { 97 76 } 6 97与76交换：12 27 38 49 65 76 97 1.2.4 流程图 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190109170339646.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)1.2.5 代码示例 void selection(int a[], int n) { int i, j, temp; for (i = 0; i &lt; n; i++) { for (j = i + 1; j &lt; n; j++) { if (a[i] &gt; a[j]) { temp = a[i]; a[i] = a[j]; a[j] = temp; } } } }二、冒泡排序法2.1算法思想 1.比较相邻的元素。如果第一个比第二个大，就交换他们两个。 2.对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。 3.在这一点，最后的元素应该会是最大的数。 4.针对所有的元素重复以上的步骤，除了最后一个。 5.持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较 2.2 动图演示 2.3 例子从左往右排序和从右往左排序都可行，以下例子为从右到左排序。 0 原始序列： { 23，78，45，8，32，56 } 1.1 45与8交换：{ 23 78 8 45 32 56 } 1.2 78与8交换：{ 23 8 78 45 32 56 } 1.3 23与8交换：8 { 23 78 45 32 56 } 2 8 23 { 32 78 45 56 } 3 8 23 32 { 45 78 56 } 4 8 23 32 45 { 56 78 } 5 8 23 32 45 56 78 2.4 流程图以下流程图中出现的概念与上一张相同。![在这里插入图片描述](https://img-blog.csdnimg.cn/20190109170353971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 2.5 代码示例void bubble(int a[], int n) { int i, j,temp; for (i = 0; i &lt; n - 1; i++) { for (j = 0; j &lt; n - 1 - i; j++) { if (a[j] &gt; a[j + 1]) { temp = a[j]; a[j] = a[j + 1]; a[j + 1] = temp; } } } }三、插入排序法3.1算法描述 1.从第一个元素开始，该元素可以认为已经被排序 2.取出下一个元素，在已经排序的元素序列中从后向前扫描 3.如果该元素（已排序）大于新元素，将该元素移到下一位置 4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 5.将新元素插入到该位置后 6.重复步骤2~5 插入排序法的步骤就像我们平时玩卡牌游戏的时候对卡牌进行排序的步骤：拿出一张牌，寻找正确的位置插入。 3.2 动图演示 3.3 例子 0 原始序列： 23 { 78 45 8 32 56 } 1 23 78 { 45 8 32 56 } 2 23 45 78 { 8 32 56 } 3 8 23 45 78 { 32 56 } 4 8 23 32 45 78 {56} 5 8 23 32 45 56 78 3.4 流程图注： Found 起标记作用，用来判断是否需要执行内循环。![在这里插入图片描述](https://img-blog.csdnimg.cn/2019010917041514.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 3.5 代码示例void insert(int a[], int n) { for (int i = 1; i &lt; n; i++) { int temp = a[i], j; for (j = i; j &gt; 0 &amp;&amp; temp &lt; a[j - 1]; j--) { a[j] = a[j - 1]; } a[j] = temp; } }","link":"/2019/01/09/三种常见排序方法/"},{"title":"初识Java","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86529993 一、认识Java Java是一门 面向对象 编程语言，不仅吸收了C++语言的各种优点，还摒弃了C++里难以理解的多继承、指针等概念，因此Java语言具有功能强大和简单易用两个特征。 Java具有 简单性 、 面向对象 、 分布式 、 健壮性 、 安全性 、 平台独立与可移植性 、 多线程 、 动态性 等特点 。 Java编写的程序即是 编译型 的，又是 解释型 的。（ 关于这点，网上的各有各的说法） 我所理解的Java到底是解释型语言还是编译型语言 Java程序的编译与运行过程：C++的编译最终生成的是可直接执行的 exe 文件。源程序 → 编译预处理 → 编译 → 链接程序 → 可执行文件（ .exe ） Java的版本 Java SE Java的标准 Java EE Java的企业版 Java ME 主要应用于嵌入式系统开发 Java的应用领域主要有以下方面： 桌面应用系统开发 嵌入式系统开发 电子商务应用 企业级应用开发 交互式系统开发 多媒体系统开发 分布式系统开发 Web应用系统开发 二、Java环境的搭载（1）JREJRE的全称为 Java Runtime Environment ，是Java运行环境，主要负责Java程序的运行。其中包含着JVM（Java虚拟机）（2）JDKJDK 是 Java Development Kit 的缩写，它是 Java 语言的软件开发工具包(SDK)，包含了Java程序开发所需要的编译 、 调试 等工具，另外也包含了JDK的源代码。 在JDK中也包含着一个JRE 。 JRE与JDK的区别与联系： JRE只是个单纯的Java运行的环境，如果要开发Java程序的话就需要安装JDK。 JRE安装会自动添加PATH，JDK的安装需要配置 环境变量 。 JRE与JDK是Java运行和开发工具，其中JDK包括JRE，但是JRE也可以独立安装。 JDK文件可以通过访问官网下载，也可以根据博主提供的资源下载： 点击下载JDK，Eclipse与对应汉化包 三、IDE IDE的意思是集成开发环境，全称是Integrated DevelopmentEnvironment，集成开发环境是用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具。 Java的IDE有许多，博主现在用的是Eclipse。","link":"/2019/01/17/初识Java/"},{"title":"多项式的乘除法","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86632864 与上一期 多项式的加法与减法 相同，这期的乘除法也使用数组来操作。关于用数组表示：就是用数组将多项式的各个系数存储起来（以常数项为第一个元素） 如 x³+x²-1 ，对应数组为 double A[] = {-1,0,1,1}; 一、多项式的乘法回忆我们平时用纸笔是如何计算的呢？ 没错！ 就是将多项式的每一项与另外一个多项式的每一项相乘 。如：（x + 1）×（x + 1） = x(x+1) + (x + 1) = x² + 2x + 1在计算机中也可以模拟这种操作 用数组存储多项式的系数时，通过数组的对应下标我们可以得知对应项是几次项。所以我们可以通过对应下标相加从而达到与系数的同步。 //A[]和 m 分别为多项式A的系数矩阵和项数 //B[]和 n 分别为多项式 B 的系数矩阵和项数 //参数R[]和 k 分别为运算结果 R[] 的系数矩阵和项数。 void polynomial_mul(double A[], int m, double B[], int n, double R[], int k) { //k = m + n -1; int i, j; for (i = 0; i &lt; k; i++) //初始化 { R[i] = 0.0; } for (i = 0; i &lt; m; i++) //乘法运算 { for (j = 0; j &lt; n; j++) { R[i+j] += A[i] * B[j]; } } }二、多项式的除法注：被除的多项式的次数要大于等于除的多项式的次数原理：原理与我们日常用笔和纸手算一样代码如下： //函数参数列表相对于之前多了一个 L[] ，用于表示余多项式的系数 void polynomial_div(double A[], int m, double B[], int n, double R[], int k, double L[], int l) { // k = m - n + 1; l = n - 1; m &gt; n; int i, j, mm, ll; for (i = 0; i &lt; k; i++) //初值 { R[i] = 0.0; } ll = m - 1; for (i = k; i &gt; 0; i--) { R[i - 1] = A[ll] / B[n - 1]; //除法，计算商多项式系数 mm = ll; for (j = 1; j &lt;= n - 1; j++) { A[mm - 1] -= R[i - 1] * B[n - j - 1]; mm -= 1; } ll -= 1; } for (i = 0; i &lt; l; i++) //余多项式系数 { L[i] = A[i]; } }","link":"/2019/01/24/多项式的乘除法/"},{"title":"使 VC2013 编写的程序运行在其它电脑上","text":"VC2013 默认编写的 .exe 使用动态链接方式链接的运行时库，所以，编写的程序要在别的电脑上运行，需要在其它电脑安装 VC2013的运行时库，然后就可以完美运行你的 .exe 程序。当然，如果你觉得安装运行时库很麻烦，你可以 用静态链接的形式编译你的 .exe 程序。方法如下（以中文版 Visual Studio 2013 为例）： 1. 打开 Visual Studio 2013，创建 Win32 控制台应用程序（或者 Win32 项目）。 2. 编写程序。 3. 项目编译模式默认分为 Debug 和 Release 两种模式。Debug 模式带有各种调试信息，方便排查错误，使用的调试版本库。Release模式删除了调试信息，使得编译的文件更小，执行速度更快。因此，在调试程序的时候，要用 Debug 模式。在调试完毕需要发布程序的时候，用 Release模式。两种模式有不同的编译设置，我们现在需要将完成的程序发给别人，因此需要将项目设置为 Release 模式。 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190221131937422.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)4. 在 解决方案资源管理器 区域中，选中你的项目（通常第一行是 解决方案，第二行是 项目），右击，选 属性。 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190221132025984.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)*5. 左侧类别中选择“配置属性 - &gt; C/C++ -&gt; 代码生成”，右侧将“运行时库”设置为“多线程(/MT)”。 *![在这里插入图片描述](https://img-blog.csdnimg.cn/20190221132107364.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)*6. 如果你希望你的程序可以运行在 WinXP 中，还需要设置“配置属性 - &gt; 常规 -&gt; 平台工具集”为“Visual Studio 2013 -Windows XP (v120_xp)”。 * 7. 编译程序。在项目文件夹的 Release 文件夹里面，可以找到最终编译的 .exe 文件，拷贝出来即可在别的电脑上运行。![在这里插入图片描述](https://img-blog.csdnimg.cn/20190221132212353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)数据来源： [ EasyX官网 ](https://www.codeabc.cn/yangw/post/make-a-program-written-by-vc-run-on-another-computer)注：上述图中演示的IDE为 Visual Studio 2017.","link":"/2019/02/21/使 VC2013 编写的程序运行在其它电脑上/"},{"title":"多项式格式化输出器","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86633709 一、前言自从做了以下两个： 多项式的加法与减法 多项式的乘法与除法 emmm… ,我就在想虽然用数组表示各项系数的方法大大简化了多项式的计算，但最终输出的结果相对应的也只能输出一堆数字， 好不美观。所以我就在网上找有没有 以数组为原始数据格式化输出多项式的方法，但是似乎没有（或许是没找到，在网上看的多项式的运算绝大部分是用链表或什么模板等我没有学习过的东西做的，又有谁无聊到做这种东西呢？Σ(っ°Д°;)っ ） 最后的最后，我还是用我学过的东西做了一个，我叫她 多项式格式化输出器 。虽然感觉代码不是很美观规范，但毕竟是自己做的 (￣▽￣)／ 下面放出代码 二、代码区 这个 多项式格式化输出器 主要做了以下处理： 若某个项的系数为1或-1，则省略1这个数字，如：-x³ + x，而不是-1x³+1x，看起来很别扭 若某个项的系数为0，则该项不输出 （1与2 对系数的特殊情况进行处理 ） 若某个项的次数为1，则省略1，即 对次数的特殊情况 进行处理。如：x 而不是 x^1 若某个项（不包括最高次项）的系数为正数，则输出“+”，否则输出“-”，即 对项之间的符号做了处理 。如：-2x -1 ，而不是 -2x + (-1) 这段代码使用纯逻辑编写，目前使用还没有什么bug，要注意的是最高次项的系数不能为 0 /**************************** 对指数进行处理 函数参数为指数（即数组下标） ***************************/ void sign(int m) // { if (m == 0) { return; } else if (m == 1) { cout &lt;&lt; &quot;x&quot;; } else { cout &lt;&lt; &quot;x^&quot; &lt;&lt; m; } } /**************************** 对系数进行处理 函数第一个参数为系数（即数组下标对应的元素） 第二个参数用来接收信息（最后一项为0时，传参为2，否则为1） ***************************/ void coneff_1(int m,int n) { if (m &gt; 0) { if (m != 1||n==2) { cout &lt;&lt; &quot;+&quot; &lt;&lt; m; } else { cout &lt;&lt; &quot;+&quot;; } return; } else if (m &lt; 0) { if (m != -1||n==2) { cout &lt;&lt; &quot;-&quot; &lt;&lt; abs(m); } else { cout &lt;&lt; &quot;-&quot;; } return; } else return; } //用于判断系数是否为0 int coneff_2(int m) { return m==0?1:0; } /********************************** 功能主体，可调用其它函数，由一段逻辑组成 第一个参数为数组（从常数项开始的系数） 第二个参数为数组元素个数 ***********************************/ void print(double A[], int m) { int i; for (i = m - 1; i &gt;= 0; i--) { if (i == m - 1) { if (abs(A[i]) == 1) { cout &lt;&lt; ((A[i]) &gt; 0 ? &quot;&quot; : &quot;-&quot;); sign(i); } else { cout &lt;&lt; (A[i] &gt; 0 ? &quot;&quot; : &quot;-&quot;) &lt;&lt; abs(A[i]); sign(i); } } else if (i == 0) { if (coneff_2(A[i])) { cout &lt;&lt; endl; return; } else { coneff_1(A[i],2); cout &lt;&lt; endl; } } else { if(coneff_2(A[i])) continue; else { coneff_1(A[i],1); sign(i); } } } }","link":"/2019/01/24/多项式格式化输出器/"},{"title":"多项式的加法与减法","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86632690 一、多项式在了解多项式的加减法之前，我们先回顾一下多项式的基本概念。 什么叫多项式 在数学中，由若干个单项式相加组成的代数式叫做多项式（若有减法：减一个数等于加上它的相反数）。 如 x³ + x² - 4x + 3、x² + 1、x³ 等 多项式的一些名词多项式的项：多项式中的每个单项式多项式的次数：单项式中的最高项次数常数项：多项式中不含字母的项如 x³ + x² - 4x + 3 有 4项，次数为3，常数项为3. 二、多项式的加法OK，话不多说，直接展开正题。其实本质上多项式的加法与减法是同一种运算，例如 “1 - 2”可以转换成加法运算”1 + (-2)” ，事实上接下来要讲的多项式的减法也是这么做的。所以只要解决了加法，减法也不是什么问题。 那么如何解决多项式的加法呢 ？在这篇文章中，我们采用最简单的方法 —— 用数组表示多项式的系数，并且作加法运算。如 x³ + 4x 我们按常数项开始计数，它可以表示为： 0 4 0 1 x² - 4x + 3 可以表示为： 3 -4 1 对它们作加法运算：0 4 0 13 -4 1 ****3 0 1 1 就是最终结果，所以 (x³ + 4x) + ( x² - 4x + 3) = x³ + x² + 3注： 以常数项为基准对齐，不用进位 代码示例思路已经在上面了，接下来放出代码： / ************************************* A、B和R分别用于存储作运算的多项式和最终的结果 m、n和k是对应以上三个数组的长度 *************************************/ void polynomial_add(double A[], int m, double B[], int n, double R[], int k) { //k = max(m,n); int i, j; for (i = 0; i &lt; k; i++) //初始化 { R[i] = 0.0; } int max = m &gt; n ? m : n; int min = m &lt; n ? m : n; for (i = 0; i &lt; min; i++) //对齐部分的运算 { for (j = 0; j &lt; min; j++) { if (i == j) { R[i] += A[i] + B[j]; } } } if(max==m) //非对齐部分的运算 { for (i = min; i &lt; k; i++) { R[i] += A[i]; } } else { for (i = min; i &lt; k; i++) { R[i] += B[i]; } } }三、多项式的减法只需把减数（减号后面的多项式）的系数重置为对应的相反数即可。代码示例： void polynomial_sub(double A[], int m, double B[], int n, double R[], int k)//多项式减法 { int i; for (i = 0; i &lt; n; i++) { B[i] = -B[i]; } polynomial_add(A, m, B, n, R, k); }","link":"/2019/01/24/多项式的加法与减法/"},{"title":"大整数减法","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86766733 本篇介绍大整数相减（两个正数相减）与大整数加法运算相比，减法运算稍微复杂了些，因为要考虑当结果为负数时候的情况。根据减法运算法则可以得出两个整数相减为正数的情况。这样想来，只需要在两个正的大整数相减前比较大小即可得出另外一种情况。 例： 11 - 20 = - ( 20 - 11）只需算出 20 - 11 即可获得答案 为了确定最终结果得符号（+ / -），需要比较两个数得大小 所以最终功能的实现由以下部分组成： 逆序存放数字（对齐整数的个位，便于计算） 判断两个整数大小（确定最终结果为正数还是负数） 用数组计算结果 根据两个整数的大小输出结果 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; using namespace std; void swap(int a[], int len_a, int b[], int len_b) { int MAX = max(len_a, len_b); for (int i = 0; i &lt; MAX; i++) { swap(a[i], b[i]); } } int main() { int a[1001] = { 0 }; int b[1001] = { 0 }; string A, B; cin &gt;&gt; A &gt;&gt; B; int len1, len2; len1 = A.length(); len2 = B.length(); int flag = 0;//标记输出结果为正或是负 for (int i = len1 - 1, k = 0; i != -1; i--)//逆序存放 { a[k] = A[i] - &apos;0&apos;; k++; } for (int i = len2 - 1, k = 0; i != -1; i--) { b[k] = B[i] - &apos;0&apos;; k++; } if (len1 &lt; len2)//比较大小 { flag = 1; swap(a, len1, b, len2); swap(len1, len2); } else if (len1 == len2) { for (int i = len1 - 1; i &gt;= 0; i--) { if (a[i] == b[i]) continue; else if (a[i] &gt; b[i]) break; else { flag = 1; swap(a, len1, b, len2); swap(len1, len2); break; } } } int down = 0,max = len1 &gt;= len2 ? len1 : len2; for (int i = 0; i &lt; max; i++)//模拟减法 { a[i] =a[i] - b[i] - down; down = 0; if (a[i] &lt; 0) { down = 1; a[i] += 10; } } if (flag) { cout &lt;&lt; &quot;-&quot;; } int i; for (i = max - 1; a[i] == 0; i--);//忽略空格 for (;i &gt;= 0; i--) { cout &lt;&lt; a[i]; } return 0; }","link":"/2019/02/05/大整数减法/"},{"title":"大整数加减法","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86770733 大整数加法 大整数减法 本篇将以上两部分内容结合，使之能够真正计算大整数的加减法。大整数加法介绍了两个正的大整数相加，大整数减法介绍了两个正的大整数相减。 加法加法有以下情况，它们都可以转换为以上链接讲述的问题： 正 + 正 ，如 1 + 1 正 + 负，如 1 + (-1) = 1 - 1 负 + 正，如 -1 + 1 = 1 - 1 负 + 符，如 -1 + -1 = -(1 + 1) 减法同理，减法有如下情况： 正 - 正，如：1 - 1 正 - 负，如1 - (-1) = 1 + 1 负 - 正，如 -1 - 1 = -(1 + 1) 负 - 负，-1 - (-1) = 1 - 1根据以上规则，有如下代码： #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; using namespace std; void swap(int a[], int len_a, int b[], int len_b)//交换数组 { int MAX = max(len_a, len_b); for (int i = 0; i &lt; MAX; i++) { swap(a[i], b[i]); } } void reverseArr(string A, int a[])//逆序存放 { int len = A.length(); for (int i = len - 1, k = 0; i != -1; i--) { a[k] = A[i] - &apos;0&apos;; k++; } } void largeIntAdd(string A,string B) { int a[1001] = { 0 }; int b[1001] = { 0 }; reverseArr(A, a); reverseArr(B, b); int len_a = A.length(); int len_b = B.length(); int up = 0, max = len_a &gt;= len_b ? len_a : len_b; for (int i = 0; i &lt; max; i++)//模拟加法 { a[i] += b[i] + up; up = a[i] / 10; a[i] %= 10; } if (up &gt; 0) { a[max] += up; max += 1; } for (int i = max - 1; i &gt;= 0; i--) { cout &lt;&lt; a[i]; } cout &lt;&lt; endl; } void largeIntSub(string A,string B) { int a[1001] = { 0 }; int b[1001] = { 0 }; reverseArr(A, a); reverseArr(B, b); int len_a = A.length(); int len_b = B.length(); int flag = 0; int count = 0; if (len_a &lt; len_b) { flag = 1; swap(a, len_a, b, len_b); swap(len_a, len_b); } else if (len_a == len_b) { for (int i = len_a - 1; i &gt;= 0; i--) { if (a[i] == b[i]) { count++; continue; } else if (a[i] &gt; b[i]) break; else { flag = 1; swap(a, len_a, b, len_b); swap(len_a, len_b); break; } } } if (len_a == len_b &amp;&amp; count == len_a) { cout &lt;&lt; 0 &lt;&lt; endl; return; } int down = 0, max = len_a &gt;= len_b ? len_a : len_b; for (int i = 0; i &lt; max; i++)//模拟减法 { a[i] = a[i] - b[i] - down; down = 0; if (a[i] &lt; 0) { down = 1; a[i] += 10; } } if (flag) { cout &lt;&lt; &quot;-&quot;; } int i; for (i = max - 1; a[i] == 0; i--);//忽略空格 for (; i &gt;= 0; i--) { cout &lt;&lt; a[i]; } cout &lt;&lt; endl; } int control(string &amp;A, char op, string &amp;B)//控制调控函数 { switch (op) { case &apos;+&apos;: { if (A[0] == &apos;-&apos;&amp;&amp;B[0] == &apos;-&apos;)//负+负 = -(正 + 正） { A.erase(0, 1); B.erase(0, 1); cout &lt;&lt; &quot;-&quot;; largeIntAdd(A, B); } else if (A[0] == &apos;-&apos;&amp;&amp;B[0] != &apos;-&apos;)//一负一正 { A.erase(0, 1); largeIntSub(B, A); } else if (A[0] != &apos;-&apos;&amp;&amp;B[0] == &apos;-&apos;)//一正一负 { B.erase(0, 1); largeIntSub(A, B); } else//双正 { largeIntAdd(A, B); return 0; } break; } case &apos;-&apos;: { if (A[0] != &apos;-&apos;) { if (B[0] != &apos;-&apos;)//正 - 正 { largeIntSub(A, B); } else//正 - 负 { B.erase(0, 1); largeIntAdd(A, B); } } else { if (B[0] != &apos;-&apos;)//负 - 正 { A.erase(0, 1); cout &lt;&lt; &quot;-&quot;; largeIntAdd(A, B); } else//负 - 负 { A.erase(0, 1); B.erase(0, 1); largeIntSub(B, A); } } } default: return -1; } return 0; } int main() { string A, B; char op; while (cin &gt;&gt; A &gt;&gt; op &gt;&gt; B) { control(A, op, B); } }效果如下：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190207103027636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)","link":"/2019/02/07/大整数加减法/"},{"title":"搭载MyBatis环境 （带源码）","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/92086807 搭建MyBatis 所有代码 提取码：pukp 网页版 提取码：9ixn 结构图：![在这里插入图片描述](https://img-blog.csdnimg.cn/201906151446101.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 第一步，创建项目，导入jar包共需导入 14 个包： ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190615144415288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 第二步，建立数据库和表create database mybatis; use mybatis; DROP TABLE IF EXISTS tb_user1; CREATE TABLE tb_user1( ID INT(11) KEY AUTO_INCREMENT, NAME VARCHAR(18) DEFAULT NULL, SEX CHAR(2) DEFAULT NULL, AGE INT(11) DEFAULT NULL );第三步，建立实体类package com.ichliebedich.domain; import java.io.Serializable; public class User implements Serializable{ private Integer id; private String name; private String sex; private Integer age; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getSex() { return sex; } public void setSex(String sex) { this.sex = sex; } public Integer getAge() { return age; } public void setAge(Integer age) { this.age = age; } }第四步，建立Mapper接口package com.ichliebedich.dao; import com.ichliebedich.domain.User; public interface UserMapper { public void saveUser(User user); }第五步，建立sql映射文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;!-- 该文件编写 mybatis 中的 mapper 接口里面的方法提供对应的 sql 语句 --&gt; &lt;mapper namespace=&quot;com.ichliebedich.dao.UserMapper&quot;&gt; &lt;!-- 添加客户 --&gt; &lt;insert id=&quot;saveUser&quot; parameterType=&quot;com.ichliebedich.domain.User&quot;&gt; INSERT tb_user1 (name,sex,age) VALUES(#{name},#{sex},#{age}) &lt;/insert&gt; &lt;/mapper&gt; 该文件编写 mybatis 中的 mapper 接口里面的方法提供对应的 sql 语句 namespace对应mapper接口的完整名称 insert中的id对应接口中的函数名称，parameterType对应接口中函数传入的参数类型，insert间是sql语句 第六步，建立mybatis-config.xml文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!-- 和 spring 整合后 environments 配置将废除 --&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;!-- 使用 jdbc 事务管理 --&gt; &lt;transactionManager type=&quot;JDBC&quot; /&gt; &lt;!-- 数据库连接池 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;com/ichliebedich/mapper/UserMapper.xml&quot;&gt; &lt;/mapper&gt; &lt;/mappers&gt; &lt;/configuration&gt; 文件中需要改动的参数：dataSource里面的 proterty 和 mapper中的resource proterty对应jdbc中常见的四个属性,若使用Mysql版本6以上： driver改为 com.mysql.cj.jdbc.Driver name改为jdbc:mysql://localhost:3306/mysql?useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false&amp;serverTimezone=Asia/Shanghai 至于username和password就根据自己设置的值更改 resource对应sql映射文件名称 第七步，建立测试类package com.ichliebedich.test; import java.io.InputStream; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; import org.junit.jupiter.api.Test; import com.ichliebedich.dao.UserMapper; import com.ichliebedich.domain.User; public class InsertTest { @Test public void test() throws Exception { //1.创建 SqlSessionFactoryBuilder SqlSessionFactoryBuilder builer = new SqlSessionFactoryBuilder(); //加载 sqlMapConfig.xml 文件 InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); //2.创建 sqlSessionFactory SqlSessionFactory factory = builer.build(is); //3.打开 SqlSession SqlSession sqlSession = factory.openSession(); ///4.获取 Mapper 接口的对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //5.操作 User user = new User(); user.setName(&quot;Ich/liebe/dich&quot;); user.setSex(&quot;男&quot;); user.setAge(20); userMapper.saveUser(user); //6.提交事务 sqlSession.commit(); //7.关闭资源 sqlSession.close(); } }插入成功： SqlSessionFactory：MyBatis关键对象，通过 SqlSessionFactory 和 XML 配置文件生成（代码中的1,2） 一旦创建，一直存在，建议使用单例模式。 SqlSession：执行持久化操作的对象 单例模式： import java.io.InputStream; import org.apache.ibatis.io.Resources; import org.apache.ibatis.session.SqlSession; import org.apache.ibatis.session.SqlSessionFactory; import org.apache.ibatis.session.SqlSessionFactoryBuilder; public class FKSqlSessionFactory { private static SqlSessionFactory sqlSessionFactory = null; // 初始化创建SqlSessionFactory对象 static{ try (// 读取mybatis-config.xml文件 InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); ){ sqlSessionFactory = new SqlSessionFactoryBuilder() .build(is); } catch (Exception e) { e.printStackTrace(); } } // 获取SqlSession对象的静态方法 public static SqlSession getSqlSession(){ return sqlSessionFactory.openSession(); } // 获取SqlSessionFactory的静态方法 public static SqlSessionFactory getSqlSessionFactory() { return sqlSessionFactory; } }将SqlSessionFactory封装起来，之后就可以直接调用，在这里不作详细讲解。 在搭建过程中要注意一些配置名称是否正确，配置文件是否存放到正确位置。","link":"/2019/06/15/搭载MyBatis环境 （带源码）/"},{"title":"大整数加法","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86766672 大数相加其思路就是模拟加法计算，遵从加法计算原则，逢10进1。计算时将大整数的每一位用数组表示，用数组代替大整数计算。如： 12340表示为 int a[] = {0,4,3,2,1};数组首位元素是个位，用数组表示后，便于数字个位的对齐。 1234+8766 |—|—4 3 2 1 |6 6 7 8 |0 0 0 0 1 | 结果：10000 注意： 正如以上所示，两个大整数相加时要考虑最高位进位的情况 将字符串转换为数组时别忘记减 ‘0’ #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int main() { int a[1001] = { 0 }; int b[1001] = { 0 }; string A, B; cin &gt;&gt; A &gt;&gt; B; int len1, len2; len1 = A.length(); len2 = B.length(); for (int i = len1 - 1, k = 0; i != -1; i--)//逆序存放 { a[k] = A[i] - &apos;0&apos;; k++; } for (int i = len2 - 1, k = 0; i != -1; i--) { b[k] = B[i] - &apos;0&apos;; k++; } int up = 0, max = len1 &gt;= len2 ? len1 : len2; for (int i = 0; i &lt; max; i++)//模拟加法 { a[i] += b[i] + up; up = a[i] / 10; a[i] %= 10; } if (up &gt; 0)//考虑最高位进位的情况 { a[max] += up; max += 1; } for (int i = max-1; i &gt;= 0; i--) { cout &lt;&lt; a[i]; } return 0; }","link":"/2019/02/05/大整数加法/"},{"title":"将a字符串中的所有b字符串替换成c字符串,strcat函数，查找并返回第二个字符串在第一个字符串的位置","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86760915 emmm… 很久以前写的，现在发表出来将a字符串中的所有b字符串替换成c字符串的函数如下： void strReplace(char a[], char b[], char c[]) { int i, locate = 0, len1 = 0, len2 = 0, len3 = 0, flag; while (b[len2++]); len2--;//获取字符串长度 while (c[len3++]); len3--; while (a[locate]) { flag = 1; for (i = 0; i &lt; len2; i++) { if (a[locate + i] != b[i]) { flag = 0; break; } } if (flag == 1) { while (a[len1++] != 0); len1--; if (len3 - len2 &gt;= 0) { for (i = len1 - 1; i &gt; locate; i--) { a[i + len3 - len2] = a[i]; } } else { for (i = locate + len2; i &lt; len1; i++) { a[i + len2 - len3] = a[i]; } } a[len1 - len2 + len3] = 0; for (i = 0; i &lt; len3; i++) { a[locate + i] = c[i]; } locate += len3; } else { locate++; } } }strcat函数如下: void strcat(char *p, char *q) { while (*p) { p++; } while (*q) { *(p++) = *(q++); } *p = 0; }查找并返回第二个字符串在第一个字符串的位置的函数如下： int strAt(char *s, char *t) { int i = 0, j = 0, flag = 0, k; char *p = NULL; while (*(s + i)) { i++; } while (*(t + j)) j++; for (k = 0; k &lt;= i - j; k++) { p = s + k; flag = 1; for (int l = 0; l &lt; j; l++) { if (*p != *(t + l)) { flag = 0; break; } p++; } if (flag == 1) break; } if (flag == 1) return k + 1; return -1; }","link":"/2019/02/03/将a字符串中的所有b字符串替换成c字符串,strcat函数，查找并返回第二个字符串在第一个字符串的位置/"},{"title":"最大公约数与最小公倍数","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86083282 //传送门： 水仙花数、完数、回文数、素数（数论基础集合） 一、最大公约数（1）概念 ：最大公约数，也称最大公因数、最大公因子，指两个或多个整数共有 约数中最大的一个。（2）常见的方法 ： 质因数分解法、辗转相除法、 更相减损法 、短除法。 本文主要就质因数分解法，辗转相除法和更相减损法简单地展开讨论。 （3）解决方案1.质因数分解法 这种方法的思路是将两个数分解为若干个质因数的乘积，通过比较以此求得最大公约数。 受此启发，我们求最大公约数最简单的方法就是让计算机一个一个地去试，暴力穷举。代码如下： int gcd1(int a, int b) { a = abs(a); b = abs(b); int i; if (a &gt; b) { i = a; a = b; b = i; } for (i = a; i &gt;= 1; i--) { if (b / a * a == b) return a; } return 1; }2.辗转相除法辗转相除法，又称欧几里得算法，是求最大公约数的一种算法。算法描述：对于两个正整数m与n(m&gt;n)，它们的最大公约数等于m与n的余数 r 与n（较小的那个数）的最大公约数。 如：10 与 2525 % 10 = 510 % 5 = 0故 10 与 25 的最大公约数为5 基于这个算法原理，我们可以用循环或递归来求最大公约数，循环或递归的终止条件为余数为0。 int gcd2(int a, int b) { int t; if (a &lt; b) { t = a; a = b; b = t; } while (b != 0) { t = a % b; a = b; b = t; } return abs(a); }3.更相减损法更相减损法，出自《九章算术》，也是一种求最大公约数的算法。我们来看看百度百科上对这种算法的步骤描述： 第一步：任意给定两个正整数；判断它们是否都是偶数。若是，则用2约简；若不是则执行第二步。 第二步：以较大的数减较小的数，接着把所得的差与较小的数比较，并以大数减小数。继续这个操作，直到所得的减数和差相等为止。 则第一步中约掉的若干个2与第二步中等数的乘积就是所求的最大公约数。 其中所说的“等数”，就是最大公约数。求“等数”的办法是“更相减损”法。 如：45 与 2745 - 27 = 1827 - 18 = 918 - 9 = 99 - 9 = 0因此45与27的最大公约数为9 与辗转相除法类似，也用到循环或递归，终止条件也是两个数相等。 int gcd3(int a, int b) { a = abs(a); b = abs(b); while (a != b) { if (a &gt; b) { a = a - b; } else { b = b - a; } } return a; }注：本文中用到的fabs()函数的作用为对整数取绝对值，在C语言中头文件为 stdlib.h ,在C++中为 cmath 。 二、最小公倍数1.概念 两个或多个整数公有的倍数叫做它们的公倍数，其中除0以外最小的一个公倍数就叫做这几个整数的最小公倍数。 2.方法公式法：两个数的最小公倍数等于这两个数的乘积除与这两个数的最大公约数。 int hcf(int a, int b) { return a * b / gcd2(a, b); }","link":"/2019/01/08/最大公约数与最小公倍数/"},{"title":"数论（各种数）","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86408948 一本文收集了一些常用的基础的数的 简单 讲解，包括： 最大公约数与最小公倍数 、 素数 、水仙花数 、 完数 与 回文数 。最大公约数与最小公倍数之前已经出过，点击链接即可访问。 二、素数（1）什么叫素数？ 素数又称质数（prime number），有无限个。 质数定义为在大于1的自然数中，除了1和它本身以外不再有其他因数。 注意：定义中素数的范围为大于1的自然数，因此 1不是素数 。（2）关于求法？根据素数的概念（除了1和它本身以外不再有其他因数），使用穷举的方法即可解决。（3）代码示例以下代码可以参考： int isPrime(int a) { for (int i = 2; i &lt; (int)(sqrt(a)); i++) { if (a % i == 0) { return 0; } } return 1; }注意： 一个数的约数的范围为 *1 &lt; a &lt; 根号n * ，利用这点，便可以压缩寻找的范围； 此函数的作用是判断一个数是否为素数，若是则返回 1 ，否则返回 0 . 利用以上代码便可以打印1 ~ 1000内的素数： #include &lt;iostream&gt; #include &lt;iomanip&gt; using namespace std; int isPrime(int); int main() { cout &lt;&lt; right; //右对齐 int count = 0; //用于计数 for (int i = 2; i &lt; 1000; i++) { if (isPrime(i)) { count++; cout &lt;&lt; setw(6) &lt;&lt; i; if (count % 5 == 0) { cout &lt;&lt; endl; } } } cout &lt;&lt; endl &lt;&lt; &quot;共计：&quot; &lt;&lt; count &lt;&lt; &quot;个&quot; &lt;&lt; endl; } int isPrime(int a) { for (int i = 2; i &lt; (int)(sqrt(a)); i++) { if (a%i == 0) { return 0; } } return 1; }以下为运行结果，共计186个：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190113104507756.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 三、水仙花数（1）什么叫水仙花数？ 水仙花数是指一个 n 位数（n≥3 ），它的每个位上的数字的 n 次幂之和等于它本身（例如：1^3 + 5^3+ 3^3 = 153）。 水仙花数只是自幂数的一种，严格来说3位数的3次幂数才称为水仙花数。 （2）关于求法求法同上，暴力穷举。（3）代码示例 void Nar() { int sum,m,i; for (i = 100; i &lt;= 1000; i++) { m = i; sum = 0; while (m) //将数字逐位分解，并按水仙花概念相加 { sum += pow((double)(m % 10),3); m /= 10; } if (sum == i) { cout &lt;&lt; i &lt;&lt; &apos;\\t&apos;; } } }注意： pow函数原型：double pow (double _X , double _Y) 第一个参数为底数，第二个参数为指数 头文件：&lt; cmath &gt; 所以 pow((double)(m % 10),3) 中才需要将第一个参数转换,在这里将第二个参数转换也是可以的: pow( m % 10,3.0) . 四、完数（1）什么叫完数 完数，即完美数，一个数如果恰好等于除它本身外的因子之和，这个数就称为完数。例如6=1＋2＋3.(6的因子是1,2,3) 另外与完数相关的还有亏数与盈数 当一个自然数的所有真因子的和小于该自然数，那么该自然数便是亏数。 当一个自然数的所有真因子的和大于该自然数，那么该自然数便是盈数。 （2）方法只需找出数字的各个因子，相加后判断是否与原来的数相等即可。（3）代码示例 int perfect(int a) { int i, sum = 0; for (i = 1; i &lt; a; i++) { if (a / i * i == a) { sum += i; } } if (sum == a) { return 1; } return 0; }五、回文数（1）回文数 回文数(或回文数)是指一个像14641这样“对称”的数，即：将这个数的数字按相反的顺序重新排列后，所得到的数和原来的数一样。 （2）做法将这个数逆序后的数与逆序前的数作比较，即核心部分是将数字逆序。（3）代码示例下列代码的作用是找出一定范围内的回文数 void symm(int a, int b) { int i,m,sum; for (i = a; i &lt;= b; i++) { m = i; sum = 0; while (m) //核心算法 { sum = sum * 10 + m % 10; m /= 10; } if (sum == i) { cout &lt;&lt; i &lt;&lt; &quot; &quot;; } } }注意： sum记得在 使用前要赋初始值 ，且sum赋初值的位置必须在内层循环前； m 用来代替 原始数字 来完成逆序转换 ，如果不这样做，在完成逆序转换后原始数字将会变成0，无法进行比较。","link":"/2019/01/13/数论（各种数）/"},{"title":"计算球体积 HDU - 2002","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/84841802 计算球体积 HDU - 2002Problem Description：根据输入的半径值，计算球的体积。 Input：输入数据有多组，每组占一行，每行包括一个实数，表示球的半径。 Output：输出对应的球的体积，对于每组输入数据，输出一行，计算结果保留三位小数。 Sample Input：11.5 Sample Output：4.18914.137 Hint #define PI 3.1415927 问题链接： 计算球体积 HDU - 2002 问题分析：简单的浮点数运算，这里有三个点：（1）球体体积公式中的常数应表示为 4.0/3 或 4/3.0 或 4.0/3.0（其中一个一定要为浮点数）；（2）保留三位小数，调用了”iomanip.h”头文件；（3）有多组数据。AC代码如下： #include &lt;iostream&gt; #include &lt;iomanip&gt; #define PI 3.1415927 using namespace std; int main() { double r; while (cin &gt;&gt; r)//多组数据输入 { cout &lt;&lt;fixed&lt;&lt;setprecision(3)&lt;&lt; (4.0 / 3.0)*PI*r*r*r &lt;&lt; endl;//设置精度 } }","link":"/2018/12/05/计算球体积 HDU - 2002/"},{"title":"Java字符串","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86647342 一、创建字符串常用创建字符串的方法： String s1 = &quot;Ich liebe dich&quot;; String s2 = new String(); //空字符串 String s3 = new String(&quot;Ich liebe dich&quot;);也可以这样做： char a[] = {&apos;H&apos;,&apos;e&apos;,&apos;l&apos;,&apos;l&apos;,&apos;o&apos;}; String a1 = new String(a); char b[] = {&apos; &apos;,&apos;w&apos;,&apos;o&apos;,&apos;r&apos;,&apos;l&apos;,&apos;d&apos;}; String b1 = new String(b,1,5);//截取第2到第6对应字符二、Java字符串具有不变性String 对象创建后则不能被修改，是不可变的。那些看起来会修改String值的方法其实是创建了新的对象，所指向的内存空间不同。 来看看以下代码：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190125163715529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)运行结果：针对以上代码，有以下3点要注意：1、 通过 String s1 = “Ich liebe dich” 声明了一个字符串对象步骤大致是：首先在常量池（对于String来讲叫做串池）创建对象”Ich liebe dich”（在以上代码中声明s1前是没有这个对象的），s1再引用这个对象。 关于常量池 Java是一种动态链接的语言，常量池的作用非常重要，常量池中除了包含代码中所定义的各种基本类型（如int、long等等）和对象型（如String及数组）的常量值外，还包含一些以文本形式出现的符号引用，比如： 类和接口的全限定名； 字段的名称和描述符； 方法的名称和描述符。 在C语言中，如果一个程序要调用其它库中的函数，在链接时，该函数在库中的位置（即相对于库文件开头的偏移量）会被写在程序中，在运行时，直接去这个地址调用函数； 而在Java语言中不是这样，一切都是动态的。编译时，如果发现对其它类方法的调用或者对其它类字段的引用的语句，记录进class文件中的只能是一个文本形式的符号引用，在连接过程中，虚拟机根据这个文本信息去查找对应的方法或字段。 所以，与Java语言中的所谓“常量”不同，class文件中的“常量”内容很丰富，这些常量集中在class中的一个区域存放，一个紧接着一个，这里就称为“常量池”。 所以， s1 存放了到字符串对象的引用 。（常量池位于堆中，对象的引用在栈中）在内存中的存放引用关系如下图所示：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190125170542978.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 而当我们创建字符串s2时：String s2 = “Ich liebe dich”; 编译器会在堆内存中寻找是否存在”Ich liebedich”对象，若找到了这个对象。就引用这个对象，否则再创建对应的对象。如你所见，前面已经存在这个对象，所以此时内存中的存放引用关系如下图所示： ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190125170644863.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)所以 s1 == s2 的结果是true 2、一旦一个字符串在内存中创建，则这个字符串将不可改变。如果需要一个可以改变的字符串，我们可以使用StringBuffer或者StringBuilder。 3、 每次 new 一个字符串就是产生一个新的对象，即便两个字符串的内容相同，使用 ”==” 比较时也为 ”false”,如果只需比较内容是否相同，应使用 ”equals()” 方法。![在这里插入图片描述](https://img-blog.csdnimg.cn/20190125171634106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)正如注释你所看见的，运行结果如下：当 s1 是常量（即这样做： final String s1 = “you”;）时，最后一行输出结果为true。 emmmmm… 关于这种用“ == ”比较就先暂时讲到这里。 三、String类常用方法以下是String类常用的方法：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190125185105441.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)接下来按上述列表顺序展开讨论 3.1 length() 方法作用：获取字符串长度用法示例： String a = &quot; A &quot;; int len = a.length();3.2 indexOf() 与 lastIndexOf() 方法搜索字符串或字符首次出现的位置： str.indexOf(String s)搜索字符串或字符最后一次出现的位置： str.lastIndexOf(String s) 以上两个方法在没有找到指定字符或字符串的情况下均返回-1 字符串的下标范围是 0 ~ length() - 1 ，以上两个方法返回的是下标 3.3 substring()方法从指定位置开始截取字符串: str.substring(int beginIndex)从某一位置到另一位置截取： str.substring(int beginIndex,int endIndex)注： 对于第二种重载形式的第二个参数，在截取时不包括该位置。如： String a = &quot;Hello&quot;; String b = a.substring(0,3); //b的最终结果为 &quot;Hel&quot;3.4 trim()方法作用：去除字符串的前导空格和尾部空格如： String a = &quot; Hell o &quot;; String b = a.trim(); // b = &quot;Hell o&quot;;3.5 equals()方法作用：判断两个字符串是否相等 区分大小写比较： str.equals(String otherstr) 不区分大小写比较： str.equalsIngoreCase(String otherstr) 3.6 toLowerCase() 与 toUpperCase()方法 大写转小写： str.toLowerCase() 小写转大写： str.toUpperCase() 3.7 charAt()方法作用：将指定索引处的字符返回 3.8 split()方法 不限制次数： str.split(String sign) 限制次数： str.split(String sign,int limit) 注： 若想应用多个分割符，则可以使用”|”，例：”,|=“表示分割符为”,“和”=” 以某一些字符（”.”、”|”、”*”、”+”）作分割符时，必须在符号前加 “\\&quot; 分割后字符串内不包括分割符，分割符被“吃掉了” 如何包括并输出分割后的子字符串？ String a = &quot;hHappyCnew year&quot;; String[] c = a.split(&quot;H|C&quot;); for(String d:c){ System.out.println(d); }3.9 compareTo()方法作用：按字典顺序比较两个字符串 str.compareTo(String otherstring ) 结果 返回值 两字符串相等 0 String对象位于参数之前 负整数 String对象位于参数之后 正整数 3.10 replace()方法作用：将指定字符或字符串替换成新的字符或字符串语法： str.replace(char oldChar ,char newChar) 四、StringBuilder类前面说过，String类是不可变的。所以当频繁修改字符串时，就会额外产生很多临时变量，极大增加系统的开销。使用 StringBuilder 或StringBuffer 就可以避免这个问题。至于 StringBuilder 和StringBuffer，它们基本相似，不同之处，StringBuffer 是线程安全的，而 StringBuilder则没有实现线程安全功能，所以性能略高。因此一般情况下，如果需要创建一个内容可变的字符串对象，应优先考虑使用 StringBuilder 类。 通过以下代码我们可以验证字符串操作与字符串生成器操作的效率：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190125194051320.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)运行结果如下：StringBuilder类的常用方法如下：注意： delete()方法删除的位置是start ~ end - 1","link":"/2019/01/25/Java字符串/"},{"title":"Java语言基础","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86532404 在学习前先了解本篇的结构：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190118101411685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 一、Java主类结构1.1 类（1） Java是 面向对象 的程序设计语言，在Java中一切都是对象。（2） Java程序的基本组成单元是 类 。每一个应用程序必须包含一个 main()方法 ，含有main()方法的类叫做主类。 所谓方法，其实与C++中的 函数 的含义相同。 通常将类的属性称为类的 全局变量 （ 成员变量 ），将方法中的属性称为 局部变量 。即 全局变量申请在类体中，局部变量申请在方法体中 。 举个例子： public class hellojava { static String a = &quot;Hello &quot;; public static void main(String[] args) { String b = &quot;Java!&quot;; System.out.println(a+b); } }hellojava是主类的名字，它 与文件名同名 ，大小写保持一致（Java严格区分大小写）其中a为全局变量，b为局部变量（main()方法也是一种方法） 1.2 全局变量（1） 在声明全局变量时，若没有对其初始化，Java会给它一个 默认值 ，注意，这里仅仅只是对全局变量生效。对应默认值如下： 基本类型 默认值 boolean false char ‘\\u0000’(NULL) byte (byte)0 short (short)0 int 0 long 0L float 0.0f double 0.0d 1.3 主方法 public static void main (String[]args) 权限修饰符 静态修饰符 返回值修饰符 main()方法的参数 二、基本数据类型Java的基本数据类型如下所示：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190118103627202.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)C++的数据类型如下：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190118103915395.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 2.1 整数类型（1） 在Java中，整数类型有3种表示形式： 十进制 、 八进制 和 十六进制 。（2） 根据所占内存不同，可分为 byte 、 short 、 int 和 long 四种类型。 数据类型 内存空间 取值范围 byte 8位 -128~127 short 16位 -32768~32767 int 32位 -2147483648~2147483647 long 64位 -9223372036854775808~9223372036854775807 值得一提的是，在Java中所有的值都分正负，所以不存在C++中unsigned这种类型。另外，也没有long long和long double。（3） 在赋值时要注意变量的范围，如对于long型值，若要赋给它一个大于int的最大值的值或小于int最小值的值时，需要在数字后面加上L或l。 long i = 2147483650L; (4) 区别于C++，在C++中布尔类型（bool）与int型是兼容的，所以以下代码可以在C++中使用： int x = 1; while(x) { //... }而在Java中不能这样做，但可以这样做： boolean x = true; while(x){ //... }（5） 基本类型都有对应包装类，如 int 对应的 Integer。基本类型和包装类的转换由自动装箱和自动拆箱完成。（编译器帮你完成） Integer x = 2; //装箱 int y = x; //拆箱关于装箱与拆箱，后期在 包装类 中介绍。 2.2 浮点类型 数据类型 内存空间 取值范围 float 32位 1.4E-45 ~ 3.4028235E38 double 64位 4.9E-324 ~ 1.7976931348623157E308 （1） 默认情况下，浮点数被认为是double型，若要使用float型，需要在数值后面加f或F。（2） 使用double型时，浮点数后的d或D可加可不加。（3） 声明浮点数时必需在浮点数后加f或F ，否则编译器认为这是double型而出错。 float f1 = 14.12f; double f2 = 12.12d; double f3 = 12.11;2.3 字符型（1） 字符型变量占用16位（ 2字节 ）的内存空间（因为Unicode编码占用2个字节） char x = &apos;a&apos;; //char x = 97 （2） Java采用 Unicode 的编码方式，字符a在Unicode表的位置是97，区别与C++ AscII码 中字符a的位置。 思考：字符型变量能否储存中文汉字？答案是能，因为Unicode编码的字符集包含了汉字（排除某些特殊的汉字没有被包含在其中）。 （3） 转义字符，与C++中的转义序列是同一个道理。 字符名称 含义 1~3位八进制所表示的字符，如\\123 \\ddd 4位十六位进制所表示的字符，如\\u0052 \\uxxxx 换行符 \\n 水平制表符 \\t 垂直制表符 \\v 退格 \\b 换页 \\f 反斜杠 \\\\ 单引号 \\’ 双引号 &quot; 2.4 布尔类型（1） 关键字： boolean（2） 含义：true 或false 三、变量与常量3.1 标识符与关键字（1） 标识符就是你取的名字，如类名、变量名、方法名、数组名、文件名等。（2） 合法的标识符由字母、下划线( _ )、美元符号($)和数字组成，它们的顺序是任意的，但 标识符开头不能是数字 且标识符不能是关键字 。以下标识符是合法的： name $page user_name以下标识符是非法的： 4u String user name（3） 关键字：Java语言已经使用过的名字，不能作标识符使用。下面是Java的部分关键字 short int long float double boolean byte if else continue for do break case switch while default char goto return public this protected static class final finally import package private 3.2 常量（1） 常量即程序运行过程中不会改变的量，在Java中用 final 表示。 final double PI = 3.1415926;（2） 若定义的final变量属于“成员变量”，则必须在定义的时候就赋初始值。 public class hellojava { final static int a = 1; //成员变量 public static void main(String[] args) { final int num; num = 2; //num = 3; 错误，只能赋值一次 } }3.3 变量的有效范围（1） 成员变量在整个类中都是有效的 ，成员变量又可以分为静态变量与实例变量。 class var{ int x = 1; //实例变量 static int y = 2;//静态变量 } 静态变量与实例变量的区别？ 在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。 在程序运行时的区别：2.1 实例变量属于某个对象的属性， 必须创建了实例对象 ，其中的实例变量才会被分配空间， 才能使用这个实例变量 。2.2 静态变量不属于某个实例对象，而是属于类，所以也称为类变量， 只要程序加载了类的字节码 ，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了 。2.3 实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。 （2） 局部变量只在当前代码块中有效 ，当局部变量与成员变量同名时，成员变量将会被隐藏，而使用局部变量。 public class hellojava { static int a = 1; public static void main(String[] args) { int a = 2; System.out.println(&quot;a的值为&quot;+a); } }如图，成员变量被隐藏： 四、运算符4.1 运算符（1）赋值运算符： =（2）算数运算符： + - * / %（3）自增与自减运算符：”++” 与” –” 两者的操作对象必须是整型或浮点型的变量 ++ 与 - - 有两种情况，一种是前++（- -），另一种是后++（- -） 区别何在？ int a = 1; int b = a++;//先将a的值赋给5，然后a再加1 int a = 1; int b = ++a;//a加1后再赋值给b（4）比较运算符： ** &gt; &gt;= == &lt;= &lt; != **（5）逻辑运算符： ** &amp;&amp; || ！ **（6）位运算符： 按位与 ： ** &amp; ** 按位或： | 按位取反： ！ 按位异或： ~ 移位操作： ^ ** &lt;&lt; ** 左移 ** &gt;&gt; ** 右移 ** &gt;&gt;&gt; ** 无符号右移注： 移位运算符适用于byte、short、char、int 和 long 。 计算2 * 8的值，可以用 2 &lt;&lt; 3 表示，这种方法通过位操作，效率高。 （6）三元运算符：各位为 表达式?值1:值2 ，若表达式的值为真，则返回值1，否则返回值2。如以下表达式的值为false: boolean a = 2&gt;3?true:false;4.2 优先级运算符的优先级决定了一个表达式运算执行的先后顺序，有时候忽略了优先级会使表达式出现超乎预期的结果。 优先级 描述 运算符 1 括号 () 2 正负号 +、- 3 一元运算符 ++、- -、！ 4 乘除 *、/ 5 加减 +、- 6 移位运算 &gt;&gt;、&lt;&lt;、&gt;&gt;&gt; 7 比较大小 &gt;、&gt;=、&lt;、&lt;= 8 比较是否相等 == 9 按位与运算 &amp; 10 按位异或运算 ^ 11 按位或运算 ∣ 12 逻辑与运算 &amp;&amp; 13 逻辑或运算 ‖ 14 三元运算符 ?: 15 赋值运算符 = 五、类型转换低类型到高类型：byte &lt; short &lt; int &lt; long &lt; float &lt; double , char &lt; int &lt; float注意： byte不能隐式转化为char short和char之间不能相互转换 float和long之间不能相互转换 5.1 隐式类型转换系统自动执行的转换，转换的方向总是从低类型到高类型。 思考： short a = 1; a = a + 1;与 short a = 1; a += 1;有什么区别第一种方法钟a为short型，1为int型，所以a+1为int型，但原本a是short型，所以这样做编译器会显示错误。第二种方法中的 “+=” 比较特殊，会对表达式进行特殊处理，故编译通过。 5.2 显式类型转换与隐式类型转换相反，由程序员自己操作。当转换是从高精度到低精度时，必须使用显式类型转换。显式类型转换可能会有数据丢失甚至转换失败。如： int a = (int)12.12; int b = (int)&apos;d&apos;; 当赋值时变量超过范围时，必须使用显式类型转换。 byte a = (byte)130; 六、代码注释与编程规范6.1 代码注释Java中有三种注释方法： 单行注释如： int a = 1;//a是个整型变量，它的值为1 多行注释如： int a = 1; /* a是个整型变量，它的值为1 */ 文档注释如： /** 文档内容 */6.2 编程规范以下仅供参考： 每条语句单独占一行，一条命令要以分号结束。 声明变量时尽量一行一个变量声明，并添加注释。对于局部变量应该在声明时就初始化。 对于关键的方法要多加注释。 为方便日后维护，不要使用技术高、难懂、易混淆判断的语句。","link":"/2019/01/18/Java语言基础/"},{"title":"Spring 使用xml配置通知","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/97181444 先看看 结构 吧：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190725100520178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) Test.java 用来测试功能 com.test.aop 里面写了4个通知类 com.test.dao 和 com.test.service 里面是接口 com.test.dao.impl 和 con.test.service.impl 是接口的实现类 先写4个通知类：前置通知：实现 MethodBeforeAdvice后置通知：实现 AfterReturningAdvice异常通知：实现 ThrowsAdvice环绕通知：实现 MethodInterceptor logBefore.java import java.lang.reflect.Method; import org.springframework.aop.MethodBeforeAdvice; public class LogBefore implements MethodBeforeAdvice{ @Override public void before(Method method, Object[] args, Object obj) throws Throwable { System.out.println(&quot;前置通知！！！&quot;); } }logAfter.java import java.lang.reflect.Method; import org.springframework.aop.AfterReturningAdvice; public class LogAfter implements AfterReturningAdvice{ @Override public void afterReturning(Object returnValue, Method method, Object[] args, Object target) throws Throwable { System.out.println(&quot;后置通知：1.目标对象：&quot;+target+&quot;\\n2.参数个数：&quot;+args.length+&quot;\\n3.方法名：&quot;+method.getName()+&quot;\\n4.返回值：&quot;+returnValue); } }logException.java import java.lang.reflect.Method; import org.springframework.aop.ThrowsAdvice; public class LogException implements ThrowsAdvice{ public void afterThrowing(Method method, Object[] args ,Object target, NullPointerException ex) {//只捕获NullPointerException类型的异常 System.out.println(&quot;00000000000异常通知：目标对象:&quot;+target+&quot;,方法名：&quot;+method.getName()+&quot;,方法的参数个数：&quot;+args.length+&quot;,异常类型:&quot;+ex.getMessage()); } }logAround.java public class logAround implements MethodInterceptor{ @Override public Object invoke(MethodInvocation invocation) throws Throwable { try { //proceed之前 前置通知 System.out.println(&quot;环绕通知 - 前置通知&quot;); Object result = invocation.proceed(); //proceed之后 后置通知 System.out.println(&quot;环绕通知 - 后置通知&quot;); }catch(NullPointerException e) { System.out.println(&quot;环绕通知 - 空指针异常&quot;+invocation.getThis().toString()); } catch(Exception e) { //异常通知 System.out.println(&quot;环绕通知 - 异常通知&quot;); } return null; } } 然后再写dao和service类 public interface StudentDao { public void addStudent(Student student); } public interface StudentService { public void addStudent(Student student); public void deleteStudentById(int id); public void updateStudent(Student student); } public class StudentDaoImpl implements StudentDao{ @Override public void addStudent(Student student) { System.out.println(&quot;增加学生&quot;); } } package com.test.service.impl; import org.springframework.transaction.annotation.Propagation; import org.springframework.transaction.annotation.Transactional; import com.test.dao.impl.StudentDaoImpl; import com.test.entity.Student; import com.test.service.StudentService; public class StudentServiceImpl implements StudentService{ StudentDaoImpl studentDao; public StudentServiceImpl() { } public StudentServiceImpl(StudentDaoImpl studentDao) { super(); this.studentDao = studentDao; } public void setStudentDao(StudentDaoImpl studentDao) { this.studentDao = studentDao; } //可以增删改，传播行为... @Transactional(readOnly=false,propagation=Propagation.REQUIRED) @Override public void addStudent(Student student) { //studentDao = null; studentDao.addStudent(student); } public void deleteStudentById(int id) { System.out.println(&quot;模拟删除...&quot;); } public void updateStudent(Student student) { System.out.println(&quot;更新学生信息...&quot;); } } 配置：把StudentDaoImpl与StudentServiceImpl配置到容器中： &lt;bean id=&quot;studentDao&quot; class=&quot;com.test.dao.impl.StudentDaoImpl&quot;&gt; &lt;/bean&gt; &lt;bean id=&quot;studentService&quot; class=&quot;com.test.service.impl.StudentServiceImpl&quot;&gt; &lt;property name=&quot;studentDao&quot; ref=&quot;studentDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt;把通知配置到容器中 &lt;!-- 前置通知类 --&gt; &lt;bean id=&quot;logBefore&quot; class=&quot;com.test.aop.LogBefore&quot;&gt;&lt;/bean&gt; &lt;!-- 后置通知类 --&gt; &lt;bean id=&quot;logAfter&quot; class=&quot;com.test.aop.LogAfter&quot;&gt;&lt;/bean&gt; &lt;!-- 异常通知类 --&gt; &lt;bean id=&quot;logException&quot; class=&quot;com.test.aop.LogException&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;logAround&quot; class=&quot;com.test.aop.logAround&quot;&gt;&lt;/bean&gt;将方法与通知关联：expression里面写execution表达式，多个方法则用or隔开 &lt;aop:config&gt; &lt;!-- 配置切入点（在哪里执行通知） --&gt; &lt;aop:pointcut expression=&quot;execution(public void com.test.service.impl.StudentServiceImpl.addStudent(com.test.entity.Student)) or execution(public void com.test.service.impl.StudentServiceImpl.deleteStudentById(int))&quot; id=&quot;pointcut1&quot;/&gt; &lt;!-- 连接切入点与切面 --&gt; &lt;aop:advisor advice-ref=&quot;logBefore&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;/aop:config&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop-4.3.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx-4.3.xsd&quot;&gt; &lt;!-- 配置数据库相关 事务 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;&gt;&lt;/property&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/db_stu?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;useSSL=false&amp;amp;serverTimezone=Asia/Shanghai&quot;&gt;&lt;/property&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; &gt;&lt;/property&gt; &lt;property name=&quot;password&quot; value=&quot;333666999520&quot;&gt;&lt;/property&gt; &lt;property name=&quot;maxActive&quot; value=&quot;10&quot; &gt;&lt;/property&gt; &lt;property name=&quot;maxIdle&quot; value=&quot;6&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 配置事务管理器 txManager --&gt; &lt;bean id=&quot;txManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 增加对事务的支持 tx命名空间--&gt; &lt;tx:annotation-driven transaction-manager=&quot;txManager&quot;/&gt; &lt;bean id=&quot;studentDao&quot; class=&quot;com.test.dao.impl.StudentDaoImpl&quot;&gt; &lt;/bean&gt; &lt;bean id=&quot;studentService&quot; class=&quot;com.test.service.impl.StudentServiceImpl&quot;&gt; &lt;property name=&quot;studentDao&quot; ref=&quot;studentDao&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!-- 前置通知类 --&gt; &lt;bean id=&quot;logBefore&quot; class=&quot;com.test.aop.LogBefore&quot;&gt; &lt;/bean&gt; &lt;!-- 后置通知类 --&gt; &lt;bean id=&quot;logAfter&quot; class=&quot;com.test.aop.LogAfter&quot;&gt;&lt;/bean&gt; &lt;!-- 异常通知类 --&gt; &lt;bean id=&quot;logException&quot; class=&quot;com.test.aop.LogException&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;logAround&quot; class=&quot;com.test.aop.logAround&quot;&gt;&lt;/bean&gt; &lt;!-- 将addStudent()方法与通知关联 --&gt; &lt;aop:config&gt; &lt;!-- 配置切入点（在哪里执行通知） --&gt; &lt;aop:pointcut expression=&quot;execution(public void com.test.service.impl.StudentServiceImpl.addStudent(com.test.entity.Student)) or execution(public void com.test.service.impl.StudentServiceImpl.deleteStudentById(int))&quot; id=&quot;pointcut1&quot;/&gt; &lt;!-- 链接切入点与切面 --&gt; &lt;aop:advisor advice-ref=&quot;logBefore&quot; pointcut-ref=&quot;pointcut1&quot;/&gt; &lt;/aop:config&gt; &lt;aop:config&gt; &lt;aop:pointcut expression=&quot;execution(public void com.test.service.impl.StudentServiceImpl.updateStudent(com.test.entity.Student))&quot; id=&quot;pointcut2&quot;/&gt; &lt;aop:advisor advice-ref=&quot;logAfter&quot; pointcut-ref=&quot;pointcut2&quot;/&gt; &lt;/aop:config&gt; &lt;aop:config&gt; &lt;aop:pointcut expression=&quot;execution(public void com.test.service.impl.StudentServiceImpl.addStudent(com.test.entity.Student))&quot; id=&quot;pointcut3&quot;/&gt; &lt;aop:advisor advice-ref=&quot;logException&quot; pointcut-ref=&quot;pointcut3&quot;/&gt; &lt;/aop:config&gt; &lt;aop:config&gt; &lt;aop:pointcut expression=&quot;execution(public void com.test.service.impl.StudentServiceImpl.addStudent(com.test.entity.Student))&quot; id=&quot;pointcut4&quot;/&gt; &lt;aop:advisor advice-ref=&quot;logAround&quot; pointcut-ref=&quot;pointcut4&quot;/&gt; &lt;/aop:config&gt; 测试： public class Test { public static void main(String[] args) { ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;); StudentService studentService = (StudentService)context.getBean(&quot;studentService&quot;); studentService.addStudent(new Student()); studentService.deleteStudentById(1); studentService.updateStudent(new Student()); } } 前置通知！！！ 环绕通知 - 前置通知 增加学生 环绕通知 - 后置通知 前置通知！！！ 模拟删除... 更新学生信息... 后置通知：1.目标对象：com.test.service.impl.StudentServiceImpl@5fd4f8f5 2.参数个数：1 3.方法名：updateStudent 4.返回值：null","link":"/2019/07/25/Spring 使用xml配置通知/"},{"title":"久远的游戏","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86485271 一、关于这个游戏（或者说不算个游戏，简单的娱乐项目）是很久以前做的，==现在拿出来与大家分享。这个游戏包含了两个小的部分，一个是 猜数游戏 ，一个是 算术游戏 ，玩家可以任意挑选并重复游戏，配上了开头可有可无的独白（_φ(❐_❐✧ 人丑就要多读书 源代码在文章末 二、效果图无零头的开头 (｀・ω・´) ：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190114224023532.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)选择 (￣▽￣)／猜数游戏 (￣.￣) ：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190114224243772.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)算数游戏 ヽ(ー_ー)ノ ：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190114224432461.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)全对，送个大爱心 (￣^￣) ：![在这里插入图片描述](https://img-blog.csdnimg.cn/2019011422445014.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 三、源代码#define _CRT_SECURE_NO_WARNINGS #include &lt;iostream&gt; #include &lt;conio.h&gt; #include &lt;Windows.h&gt; #include &lt;cstring&gt; #include &lt;ctime&gt; #include &lt;cstdlib&gt; using namespace std; void screen(); void time(); void SetPos(COORD); void SetPos(int, int); void game1(); void game2(); char name[10]; int main() { screen();//界面 int a = 1; while (a) { int answer;//(游戏选择) cout &lt;&lt; &quot;输入数字选择冒险（1or2）：&quot; &lt;&lt; endl; cin &gt;&gt; answer; system(&quot;cls&quot;); switch (answer) { case 1:game1(); break; case 2:game2(); break; } time(); cout &lt;&lt; &quot;0 ———— 退出游戏 1 ———— 继续游戏&quot; &lt;&lt; endl; cin &gt;&gt; a; } } void screen() { srand(unsigned(time(NULL))); cout &lt;&lt; &apos;\\t&apos; &lt;&lt; &apos;\\t&apos; &lt;&lt; &apos;\\t&apos; &lt;&lt; &apos;\\t&apos; &lt;&lt; &quot;欢迎来到冒险岛！&quot; &lt;&lt; endl; system(&quot;pause&quot;); cout &lt;&lt; &apos;\\t&apos; &lt;&lt; &apos;\\t&apos; &lt;&lt; &quot;你只有完成此地冒险，才能回到现实世界。&quot; &lt;&lt; endl; system(&quot;pause&quot;); cout &lt;&lt; &apos;\\t&apos; &lt;&lt; &apos;\\t&apos; &lt;&lt; &quot;什么？不乐意？那么你将永远无法回到现实世界！！！&quot; &lt;&lt; endl; system(&quot;pause&quot;); cout &lt;&lt; &apos;\\t&apos; &lt;&lt; &apos;\\t&apos; &lt;&lt; &apos;\\t&apos; &lt;&lt; &apos;\\t&apos; &lt;&lt; &quot;请输入名字:&quot;; cin &gt;&gt; name; system(&quot;pause&quot;); cout &lt;&lt; &quot;&quot; &lt;&lt; endl; system(&quot;pause&quot;); system(&quot;cls&quot;); } void time()//获取系统时间 { time_t tm; time(&amp;tm); char tmp[128] = { NULL }; strcpy(tmp, ctime(&amp;tm)); cout &lt;&lt; &quot;当前时间：&quot; &lt;&lt; endl;; cout &lt;&lt; tmp &lt;&lt; endl; } void SetPos(COORD a)// set cursor //光标定位1 { HANDLE out = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleCursorPosition(out, a); } void SetPos(int i, int j)// set cursor//光标定位2 { COORD pos = { i, j }; SetPos(pos); } void game1() { cout &lt;&lt; &quot;规则如下：&quot; &lt;&lt; endl &lt;&lt; endl;//游戏规则 cout &lt;&lt; &quot;每个骰子有6面，这些面包含1、2、3、4、5、6个点&quot;; cout &lt;&lt; &quot;，投两枚骰子之后，计算点数之和。如果第一次投的点数和为7或11，则游戏者获胜；&quot;; cout &lt;&lt; &quot;如果第一次投的点数和为2、3或12，则游戏者输；如果第一次投的点数和为4、5、6、8、9或10，则&quot;; cout &lt;&lt; &quot;将这个和作为游戏者获胜需要掷出的点数，继续投骰子，&quot;; cout &lt;&lt; &quot;直到赚到该点数时算是游戏者获胜。如果投掷7次仍未赚到该点数，则游戏者输。&quot; &lt;&lt; endl &lt;&lt; endl; srand(unsigned(time(NULL)));//界面准备 int count = 7; int target; int a; cout &lt;&lt; &quot;target: 7or11&quot; &lt;&lt; endl &lt;&lt; endl; cout &lt;&lt; &quot;a&quot; &lt;&lt; &apos;\\t&apos; &lt;&lt; &quot;b&quot; &lt;&lt; &quot; &quot; &lt;&lt; &quot;a + b&quot; &lt;&lt; endl; while (count)//运行部分 { cin &gt;&gt; a; int b = rand() % 6 + 1; int sum = a + b; cout &lt;&lt; a &lt;&lt; &apos;\\t&apos; &lt;&lt; b &lt;&lt; &apos;\\t&apos; &lt;&lt; sum &lt;&lt; endl; if (count == 7)//第一次时的数 { if (sum == 7 || sum == 11) { cout &lt;&lt; &quot;You are win!&quot; &lt;&lt; endl; return ; } else if (sum == 2 || sum == 3 || sum == 12) { cout &lt;&lt; &quot;You are defeated!&quot; &lt;&lt; endl; return ; } else if (sum == 4 || sum == 5 || sum == 6 || sum == 8 || sum == 9 || sum == 10)//当第一次的点数之和位这些值时，改变目标值 { target = sum; cout &lt;&lt; endl &lt;&lt; &quot;target:&quot; &lt;&lt; target &lt;&lt; endl &lt;&lt; endl; } } else//非第一次后改变目标值 { if (sum == target) { cout &lt;&lt; &quot;You are win!&quot; &lt;&lt; endl; return ; } } count--; } if (count == 0)//7次后未达到目标，判定为输 { cout &lt;&lt; &quot;You are defeated!&quot; &lt;&lt; endl; } return; } void game2() { char start;//start the game int answer;//choose diffculty level char operation;//choose the operation int a, b, result, r; int mark = 0; cout &lt;&lt; &quot;************arithmetic game***************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Are you ready? input T to start game!&quot; &lt;&lt; endl; while (1) { cin &gt;&gt; start; if (start == &apos;T&apos;) { break; } else { cout &lt;&lt; &quot;error!\\n&quot;; } } cout &lt;&lt; &quot;*********************************************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Please choose diffculty level(1 or 2):&quot;; while (1) { cin &gt;&gt; answer; if (answer == 1 || answer == 2) { break; } else { cout &lt;&lt; &quot;error!\\n&quot;; continue; } } cout &lt;&lt; &quot;You have chosen diffculty level&quot; &lt;&lt; &quot; &quot; &lt;&lt; answer &lt;&lt; endl; cout &lt;&lt; &quot;*********************************************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;Please input the operation( + or - or * ):&quot;; while (1) { cin &gt;&gt; operation; if (operation == &apos;+&apos; || operation == &apos;-&apos; || operation == &apos;*&apos;) { break; } else { cout &lt;&lt; &quot;error!\\n&quot;; } } cout &lt;&lt; &quot;You have chosen operation&quot; &lt;&lt; &quot; &quot; &lt;&lt; operation &lt;&lt; endl; cout &lt;&lt; &quot;*********************************************&quot; &lt;&lt; endl; for (int i = 1; i &lt;= 10; i++) { while (1) { if (answer == 1) { a = rand() % 10 + 1; b = rand() % 10 + 1; } if (answer == 2) { a = rand() % 100 + 10; b = rand() % 100 + 10; } if (operation == &apos;-&apos;) { if (a &lt; b) continue; } break; } cout &lt;&lt; a &lt;&lt; operation &lt;&lt; b &lt;&lt; &quot;=&quot;; cin &gt;&gt; result; switch (operation) { case &apos;+&apos;: r = a + b; break; case &apos;-&apos;: r = a - b; break; case &apos;*&apos;: r = a * b; break; } if (r == result) { cout &lt;&lt; &quot;mark+10!!!!!!!!&quot; &lt;&lt; endl; mark += 10; } else cout &lt;&lt; &quot;Wrong~~~&quot; &lt;&lt; endl; } cout &lt;&lt; name &lt;&lt; &quot;,your mark is &quot; &lt;&lt; mark &lt;&lt; endl; if (mark &lt;= 100 &amp;&amp; mark &gt;= 90) { cout &lt;&lt; &quot;Your level is S!!!!!!!!&quot; &lt;&lt; endl; cout &lt;&lt; &quot;You are 666 and you get a heart! &quot; &lt;&lt; endl; for (float y = 1.5f; y &gt; -1.5f; y -= 0.1f) { for (float x = -1.5f; x &lt; 1.5f; x += 0.05f) { float a = x * x + y * y - 1; putchar(a * a * a - x * x * y * y * y &lt;= 0.0f ? &apos;*&apos; : &apos; &apos;); } putchar(&apos;\\n&apos;); } cout &lt;&lt; endl; } else if (mark &lt; 90 &amp;&amp; mark &gt;= 80) { cout &lt;&lt; &quot;Your level is A!!!!!!&quot; &lt;&lt; endl; cout &lt;&lt; &quot;You are excellent!you get a triangle! &quot; &lt;&lt; endl; for (int i = 0; i &lt;= 5; i++) { for (int j = 0; j &lt; 5 - i; j++) { putchar(&apos; &apos;); } for (int k = 0; k &lt; 2 * i - 1; k++) { cout &lt;&lt; &quot;*&quot;; } cout &lt;&lt; endl; } cout &lt;&lt; endl; } else if (mark &lt; 80 &amp;&amp; mark &gt;= 70) { cout &lt;&lt; &quot;Your level is B!!!!\\nAdd oil!&quot; &lt;&lt; endl; } else if (mark &lt; 70 &amp;&amp; mark &gt;= 60) { cout &lt;&lt; &quot;Your level is C!!&quot; &lt;&lt; endl; } else { cout &lt;&lt; &quot;Your fail to this test!&quot; &lt;&lt; endl; } }","link":"/2019/01/14/久远的游戏/"},{"title":"基于TCP的双向聊天","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/94321727 先运行服务端，再运行客户端。效果图：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190630145432330.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)![在这里插入图片描述](https://img-blog.csdnimg.cn/20190630145444798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 客户端 import java.awt.BorderLayout; import java.awt.Color; import java.awt.Container; import java.awt.FlowLayout; import java.awt.Font; import java.awt.GridLayout; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.DataInputStream; import java.io.DataOutputStream; import java.io.IOException; import java.io.InputStreamReader; import java.io.OutputStream; import java.io.OutputStreamWriter; import java.io.PrintWriter; import java.net.InetAddress; import java.net.ServerSocket; import java.net.Socket; import java.net.UnknownHostException; import javax.swing.BorderFactory; import javax.swing.BoxLayout; import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JPanel; import javax.swing.JScrollPane; import javax.swing.JTextArea; import javax.swing.JTextField; import javax.swing.border.BevelBorder; import javax.swing.border.Border; import javax.swing.border.LineBorder; import javax.swing.border.TitledBorder; import javax.swing.plaf.TextUI; /* 基于TCP协议的Socket编程 * 双向通信 * 通过IO流传输数据 */ //客户端 public class MyChat1 extends JFrame{ private static final long serialVersionUID = 1L; private PrintWriter writer; //输出流 private BufferedReader br; //输入流 private ServerSocket server; //ServerSocket Socket socket; //ServerSocket生成的Socket private JTextArea ta = new JTextArea(); private JTextArea tf = new JTextArea(); Container cc; public MyChat1(String title) { super(title); //JFrame布局与一些组件的设置 setLayout(new GridLayout(2,1)); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); cc = this.getContentPane(); ta.setFocusable(false); ta.setLineWrap(true); tf.setLineWrap(true); Font f1 = new Font(&quot;等线&quot;, 50, 20); ta.setFont(f1); tf.setFont(f1); //设置聊天显示界面 final JScrollPane scrollPane1 = new JScrollPane(); scrollPane1.setBorder(new LineBorder(Color.gray,1)); getContentPane().add(scrollPane1,BorderLayout.CENTER); scrollPane1.setViewportView(ta); //输入界面的一些设置：p = p1 + p2 JPanel p = new JPanel(); p.setLayout(new BorderLayout()); JPanel p1 = new JPanel(); JPanel p2 = new JPanel(new BorderLayout()); p1.setBackground(Color.white); //发送按钮 JButton btn1 = new JButton(&quot;发送&quot;); Color btnBag = new Color(71,200,248); btn1.setBackground(btnBag); btn1.setFont(new Font(&quot;宋体&quot;,15,15)); btn1.setForeground(Color.white); //清空按钮 JButton btn2 = new JButton(&quot;清空&quot;); btn2.setBackground(Color.white); btn2.setFont(new Font(&quot;宋体&quot;,15,15)); JLabel lab1 = new JLabel(&quot; &quot;); JLabel lab2 = new JLabel(&quot; &quot;); //聊天输入界面布局 p1.add(lab1); p1.add(lab2); p1.add(btn1); p1.add(btn2); p2.add(tf,BorderLayout.CENTER); p.add(p2,BorderLayout.CENTER); p.add(p1,BorderLayout.SOUTH); cc.add(p,BorderLayout.SOUTH); //绑定事件 btn1.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent arg0) { writer.println(tf.getText()); if(!&quot;&quot;.equals(tf.getText())) { ta.append(&quot;我：&quot;+tf.getText()+&quot;\\n&quot;); } ta.setSelectionEnd(ta.getText().length()); tf.setText(&quot;&quot;); } }); btn2.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { tf.setText(&quot;&quot;); } }); } //等待连接 - 获取输入输出流 - 接收信息 void getServer() throws IOException { server = new ServerSocket(8866); System.out.println(&quot;成功创建套接字连接&quot;); while(true) { System.out.println(&quot;等待客户端连接&quot;); socket = server.accept(); br = new BufferedReader(new InputStreamReader(socket.getInputStream())); writer = new PrintWriter(socket.getOutputStream(),true); getClientMessage(); } } //接收信息 void getClientMessage() throws IOException { while(true) { String text = br.readLine(); if(!&quot;&quot;.equals(text)) { ta.append(&quot;对方：&quot;+text+&quot;\\n&quot;); } if(&quot;exit&quot;.equals(text)) { break; } } if(br != null) { br.close(); } if(socket != null) { socket.close(); } } public static void main(String[] args) throws UnknownHostException, IOException { MyChat1 clien = new MyChat1(&quot;QQ&quot;); clien.setSize(610,630); clien.setVisible(true); clien.getServer(); } }服务端 import java.awt.BorderLayout; import java.awt.Color; import java.awt.Container; import java.awt.Font; import java.awt.GridLayout; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.io.PrintWriter; import java.net.Socket; import java.net.UnknownHostException; import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JPanel; import javax.swing.JScrollPane; import javax.swing.JTextArea; import javax.swing.border.LineBorder; public class MyChat2 extends JFrame { private PrintWriter writer; //输出流 private BufferedReader br; //输入流 Socket socket; //ServerSocket生成的Socket private JTextArea ta = new JTextArea(); private JTextArea tf = new JTextArea(); Container cc; public MyChat2(String title) { super(title); //JFrame布局与一些组件的设置 setLayout(new GridLayout(2,1)); setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); cc = this.getContentPane(); ta.setFocusable(false); ta.setLineWrap(true); tf.setLineWrap(true); Font f1 = new Font(&quot;等线&quot;, 50, 20); ta.setFont(f1); tf.setFont(f1); //设置聊天显示界面 final JScrollPane scrollPane1 = new JScrollPane(); scrollPane1.setBorder(new LineBorder(Color.gray,1)); getContentPane().add(scrollPane1,BorderLayout.CENTER); scrollPane1.setViewportView(ta); //输入界面的一些设置：p = p1 + p2 JPanel p = new JPanel(); p.setLayout(new BorderLayout()); JPanel p1 = new JPanel(); JPanel p2 = new JPanel(new BorderLayout()); p1.setBackground(Color.white); //发送按钮 JButton btn1 = new JButton(&quot;发送&quot;); Color btnBag = new Color(71,200,248); btn1.setBackground(btnBag); btn1.setFont(new Font(&quot;宋体&quot;,15,15)); btn1.setForeground(Color.white); //清空按钮 JButton btn2 = new JButton(&quot;清空&quot;); btn2.setBackground(Color.white); btn2.setFont(new Font(&quot;宋体&quot;,15,15)); JLabel lab1 = new JLabel(&quot; &quot;); JLabel lab2 = new JLabel(&quot; &quot;); //聊天输入界面布局 p1.add(lab1); p1.add(lab2); p1.add(btn1); p1.add(btn2); p2.add(tf,BorderLayout.CENTER); p.add(p2,BorderLayout.CENTER); p.add(p1,BorderLayout.SOUTH); cc.add(p,BorderLayout.SOUTH); //绑定事件 btn1.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent arg0) { writer.println(tf.getText()); if(!&quot;&quot;.equals(tf.getText())) { ta.append(&quot;我：&quot;+tf.getText()+&quot;\\n&quot;); } ta.setSelectionEnd(ta.getText().length()); tf.setText(&quot;&quot;); } }); btn2.addActionListener(new ActionListener() { @Override public void actionPerformed(ActionEvent e) { tf.setText(&quot;&quot;); } }); } private void connect() throws UnknownHostException, IOException { ta.append(&quot;尝试连接\\n&quot;); socket = new Socket(&quot;localhost&quot;,8866); writer = new PrintWriter(socket.getOutputStream(),true); ta.append(&quot;连接完成\\n&quot;); br = new BufferedReader(new InputStreamReader(socket.getInputStream())); getClientMessage(); } void getClientMessage() throws IOException { while(true) { String text = br.readLine(); if(&quot;exit&quot;.equals(text)) { break; } if(!&quot;&quot;.equals(text)) { ta.append(&quot;对方：&quot;+text+&quot;\\n&quot;); } writer.println(tf.getText()); } if(br != null) { br.close(); } if(socket != null) { socket.close(); } } public static void main(String[] args) throws UnknownHostException, IOException { MyChat2 mychat2 = new MyChat2(&quot;QQ&quot;); mychat2.setSize(600,500); mychat2.setVisible(true); mychat2.connect(); } }","link":"/2019/06/30/基于TCP的双向聊天/"},{"title":"多项式运算集合","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86634054 一、前言这篇文章用来集合之前写的 多项式的加减乘除 、 多项式格式化输出器 和一个用来 控制它们的主程序。（主程序的源代码在后文，源代码主体部分还是在以下链接中） 多项式的加减法 多项式的乘除法 多项式格式化输出器 二、效果用户在输入每一个多项式之前需要提供最高项的次数，之后按规则依次输入系数，输入完成后，系统会生成一个多项式，供用户确认，若错误，可以选择重新输入。另外，用户可重复运算。 效果图如下 加法运算![在这里插入图片描述](https://img-blog.csdnimg.cn/20190124215916207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 减法运算![在这里插入图片描述](https://img-blog.csdnimg.cn/20190124215926844.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 乘法运算![在这里插入图片描述](https://img-blog.csdnimg.cn/20190124215936595.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 除法运算![在这里插入图片描述](https://img-blog.csdnimg.cn/20190124215945534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 三、源代码#include &lt;iostream&gt; #include &lt;algorithm&gt; using namespace std;//数组首个元素为常数项 const int MAX = 100; void polynomial_mul(double A[], int m, double B[], int n, double R[], int k)//多项式乘法 {//k = m + n -1; int i, j; for (i = 0; i &lt; k; i++) { R[i] = 0.0; } for (i = 0; i &lt; m; i++) { for (j = 0; j &lt; n; j++) { R[i+j] += A[i] * B[j]; } } } void polynomial_add(double A[], int m, double B[], int n, double R[], int k)//多项式加法 {//k = max(m,n); int i, j; for (i = 0; i &lt; k; i++) { R[i] = 0.0; } int max = m &gt; n ? m : n; int min = m &lt; n ? m : n; for (i = 0; i &lt; min; i++) { for (j = 0; j &lt; min; j++) { if (i == j) { R[i] += A[i] + B[j]; } } } if(max==m) { for (i = min; i &lt; k; i++) { R[i] += A[i]; } } else { for (i = min; i &lt; k; i++) { R[i] += B[i]; } } } void polynomial_sub(double A[], int m, double B[], int n, double R[], int k)//多项式减法 { int i; for (i = 0; i &lt; n; i++) { B[i] = -B[i]; } polynomial_add(A, m, B, n, R, k); } void polynomial_div(double A[], int m, double B[], int n, double R[], int k, double L[], int l)//多项式除法 {//k = m - n + 1;l = n - 1;m &gt; n; int i, j, mm, ll; for (i = 0; i &lt; k; i++) //初值 { R[i] = 0.0; } ll = m - 1; for (i = k; i &gt; 0; i--) { R[i - 1] = A[ll] / B[n - 1]; //除法，计算商多项式系数 mm = ll; for (j = 1; j &lt;= n - 1; j++) { A[mm - 1] -= R[i - 1] * B[n - j - 1]; mm -= 1; } ll -= 1; } for (i = 0; i &lt; l; i++) //余多项式系数 { L[i] = A[i]; } } void sign(int m) { if (m == 0) { return; } else if (m == 1) { cout &lt;&lt; &quot;x&quot;; } else { cout &lt;&lt; &quot;x^&quot; &lt;&lt; m; } } void coneff_1(int m,int n) { if (m &gt; 0) { if (m != 1||n==2) { cout &lt;&lt; &quot;+&quot; &lt;&lt; m; } else { cout &lt;&lt; &quot;+&quot;; } return; } else if (m &lt; 0) { if (m != -1||n==2) { cout &lt;&lt; &quot;-&quot; &lt;&lt; abs(m); } else { cout &lt;&lt; &quot;-&quot;; } return; } else return; } int coneff_2(int m) { return m==0?1:0; } void print(double A[], int m) { int i; for (i = m - 1; i &gt;= 0; i--) { if (i == m - 1) { if (abs(A[i]) == 1) { cout &lt;&lt; ((A[i]) &gt; 0 ? &quot;&quot; : &quot;-&quot;); sign(i); } else { cout &lt;&lt; (A[i] &gt; 0 ? &quot;&quot; : &quot;-&quot;) &lt;&lt; abs(A[i]); sign(i); } } else if (i == 0) { if (coneff_2(A[i])) { cout &lt;&lt; endl; return; } else { coneff_1(A[i],2); cout &lt;&lt; endl; } } else { if(coneff_2(A[i])) continue; else { coneff_1(A[i],1); sign(i); } } } } void input(double A[], int m) { int i; int make_sure = 1; while(1) { cout &lt;&lt; &quot;请依次输入常数项至最高次项的系数，若系数为0，请输入0\\n&quot;; cout &lt;&lt; &quot; e.g: x^2 + 1 ,依次输入 1 0 1\\n&quot;; if(make_sure) { for (i = 0; i &lt; MAX; i++) { A[i] = 0.0; } for (i = 0; i &lt; m; i++) { cin &gt;&gt; A[i]; } cout &lt;&lt; &quot;您输入的多项式为：&quot;; print(A, m); cout &lt;&lt; &quot;是否选择重新输入？ 0 ———— 否 1 ———— 是\\n\\n&quot;; cin &gt;&gt; make_sure; } if (make_sure == 0) { break; } } } int main() { double A[MAX] = { 0.0 }; double B[MAX] = { 0.0 }; double R[MAX] = { 0.0 }; double L[MAX] = { 0.0 }; int choice;//用户的选择操作 int A_size,B_size;//A,B分别为作运算的两个多项式 int R_size,L_size;//R用于存储运算结果，L用于存储除法时的余项 while (1) { cout &lt;&lt; &quot; ☆请选择操作☆ \\n&quot; &lt;&lt; &quot;Ⅰ加法运算 ———— 输入1\\n&quot; &lt;&lt; &quot;Ⅱ减法运算 ———— 输入2\\n&quot; &lt;&lt; &quot;Ⅲ乘法运算 ———— 输入3\\n&quot; &lt;&lt; &quot;Ⅳ除法运算 ———— 输入4\\n&quot; &lt;&lt; &quot;Ⅴ退出程序 ———— 输入5\\n&quot;; cout &lt;&lt; &quot;请输入:&quot;; cin &gt;&gt; choice; switch (choice) { case 1: { cout &lt;&lt; &quot;请输入第一个多项式的最高项的次数：&quot;; cin &gt;&gt; A_size; input(A, A_size+1); cout &lt;&lt; &quot;请输入第二个多项式的最高项的次数：&quot;; cin &gt;&gt; B_size; input(B, B_size + 1); R_size = max(A_size + 1, B_size + 1); cout &lt;&lt; &quot;\\n多项式1：&quot;; print(A, A_size + 1); cout &lt;&lt; &quot;\\n多项式2：&quot;; print(B, B_size + 1); cout &lt;&lt; &quot;\\n相加后：&quot;; polynomial_add(A, A_size + 1, B, B_size + 1, R, R_size); print(R, R_size); system(&quot;pause&quot;); system(&quot;cls&quot;); break; } case 2: { cout &lt;&lt; &quot;请输入第一个多项式的最高项的次数：&quot;; cin &gt;&gt; A_size; input(A, A_size + 1); cout &lt;&lt; &quot;请输入第二个多项式的最高项的次数：&quot;; cin &gt;&gt; B_size; input(B, B_size + 1); R_size = max(A_size + 1, B_size + 1); cout &lt;&lt; &quot;\\n多项式1：&quot;; print(A, A_size + 1); cout &lt;&lt; &quot;\\n多项式2：&quot;; print(B, B_size + 1); cout &lt;&lt; &quot;\\n相减后：&quot;; polynomial_sub(A, A_size + 1, B, B_size + 1, R, R_size); print(R, R_size); system(&quot;pause&quot;); system(&quot;cls&quot;); break; } case 3: { cout &lt;&lt; &quot;请输入第一个多项式的最高项的次数：&quot;; cin &gt;&gt; A_size; input(A, A_size + 1); cout &lt;&lt; &quot;请输入第二个多项式的最高项的次数：&quot;; cin &gt;&gt; B_size; input(B, B_size + 1); R_size = A_size + B_size + 1; cout &lt;&lt; &quot;\\n多项式1：&quot;; print(A, A_size + 1); cout &lt;&lt; &quot;\\n多项式2：&quot;; print(B, B_size + 1); cout &lt;&lt; &quot;\\n相乘后：&quot;; polynomial_mul(A, A_size + 1, B, B_size + 1, R, R_size); print(R, R_size); system(&quot;pause&quot;); system(&quot;cls&quot;); break; } case 4: { cout &lt;&lt; &quot;请输入第一个多项式的最高项的次数：&quot;; cin &gt;&gt; A_size; input(A, A_size + 1); cout &lt;&lt; &quot;请输入第二个多项式的最高项的次数：&quot;; cin &gt;&gt; B_size; input(B, B_size + 1); R_size = A_size - B_size + 1; L_size = B_size; cout &lt;&lt; &quot;\\n多项式1：&quot;; print(A, A_size + 1); cout &lt;&lt; &quot;\\n多项式2：&quot;; print(B, B_size + 1); cout &lt;&lt; &quot;\\n相除后：&quot;; polynomial_div(A, A_size + 1, B, B_size + 1, R, R_size,L,L_size); cout &lt;&lt; &quot;商多项式：&quot;; print(R, R_size); cout &lt;&lt; &quot;余多项式：&quot;; print(L, L_size); system(&quot;pause&quot;); system(&quot;cls&quot;); break; } case 5: { system(&quot;cls&quot;); cout &lt;&lt; &quot;再见！&quot;; return 0; } default: cout &lt;&lt; &quot;输入错误，请重新输入\\n&quot;; system(&quot;pause&quot;); system(&quot;cls&quot;); } } }","link":"/2019/01/24/多项式运算集合/"},{"title":"c++ 简易人员信息管理系统","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/88876425 一、内容编写一个人员信息管理系统。这个系统的功能是：交互式的实现校园人员信息的录入与显示。 二、类分析 学校里，主要有四类人员：大学本科学生、教师、研究生和助教。 大学本科生每周有固定的学时数。教师除了固定的学时数外，还有每周的教学时数。研究生除了固定的学时数外，每周还可以自由做一定的研究。助教生除了上课外，还要做研究和一定的教学工作。 人员的基本信息包括姓名、编号、性别、身份证号、总学时数以及每周固定学时数。各个人员之间的关系： people类派生出student类和teacher类，student 类派生出graduate类， graduate类和teacher类派生出TA类。 三、代码剖析3.1 各种类的实现根据以上分析，不难写出其对应的类。people类： class people { public: people() {} virtual ~people(){} virtual void print(); protected: string name; string number; int isGril; string id; double totalHours; double fixedPerWeekHours; }; void people::print() { cout &lt;&lt; name &lt;&lt; &quot;信息表:\\n&quot;; cout &lt;&lt; &quot;姓名：&quot;&lt;&lt; name &lt;&lt;endl &lt;&lt; &quot;编号：&quot;&lt;&lt; number &lt;&lt; endl &lt;&lt; &quot;性别：&quot; &lt;&lt; ( isGril ==0 ? &quot;♀&quot; : &quot;♂&quot;) &lt;&lt; endl &lt;&lt; &quot;身份证号：&quot; &lt;&lt; id &lt;&lt; endl &lt;&lt; &quot;总学时数：&quot; &lt;&lt; totalHours &lt;&lt; endl &lt;&lt; &quot;每周固定学时数：&quot; &lt;&lt; fixedPerWeekHours &lt;&lt; endl; }student类： class student : virtual public people { public: student(){} friend istream &amp; operator&gt;&gt;(istream &amp;in, student &amp;p); void print() { people::print(); } }; istream &amp; operator&gt;&gt;(istream &amp;in, student &amp;p) { cout &lt;&lt; &quot;请分别输入姓名、编号、性别(女：1,男：0)、身份证号、总学时数以及每周固定学时数（Tips:每项空格隔开）\\n&quot;; in &gt;&gt; p.name &gt;&gt; p.number &gt;&gt; p.isGril &gt;&gt; p.id &gt;&gt; p.totalHours &gt;&gt; p.fixedPerWeekHours; return in; }teacher类： class teacher :virtual public people { public: teacher(){} friend istream &amp; operator&gt;&gt;(istream &amp;in, teacher &amp;p); void print() { people::print(); cout &lt;&lt; &quot;每周教学时数：&quot; &lt;&lt; teachHours; cout &lt;&lt; endl; } protected: double teachHours; }; istream &amp; operator&gt;&gt;(istream &amp;in, teacher &amp;p) { cout &lt;&lt; &quot;请分别输入姓名、编号、性别(女：1,男：0)、身份证号、总学时数、每周固定学时数以及每周教学时数（Tips:每项空格隔开）\\n&quot;; in &gt;&gt; p.name &gt;&gt; p.number &gt;&gt; p.isGril &gt;&gt; p.id &gt;&gt; p.totalHours &gt;&gt; p.fixedPerWeekHours &gt;&gt; p.teachHours; return in; }graduate类： class graduate : virtual public student { public: graduate(){} friend istream &amp; operator&gt;&gt;(istream &amp;in, graduate &amp;p); void print() { student::print(); cout &lt;&lt; &quot;每周研究时数：&quot; &lt;&lt; studyHours; cout &lt;&lt; endl; } protected: double studyHours; }; istream &amp; operator&gt;&gt;(istream &amp;in, graduate &amp;p) { cout &lt;&lt; &quot;请分别输入姓名、编号、性别(女：1,男：0)、身份证号、总学时数、每周固定学时数以及每周研究时数（Tips:每项空格隔开）\\n&quot;; in &gt;&gt; p.name &gt;&gt; p.number &gt;&gt; p.isGril &gt;&gt; p.id &gt;&gt; p.totalHours &gt;&gt; p.fixedPerWeekHours &gt;&gt; p.studyHours; return in; }TA类： class TA : public graduate, public teacher { public: friend istream &amp; operator&gt;&gt;(istream &amp;in, TA &amp;p); void print() { teacher::print(); cout &lt;&lt; &quot;每周教学时数：&quot; &lt;&lt; teachHours &lt;&lt; endl &lt;&lt; &quot;每周研究时数：&quot; &lt;&lt; studyHours &lt;&lt; endl; } }; istream &amp; operator&gt;&gt;(istream &amp;in, TA &amp;p) { cout &lt;&lt; &quot;请分别输入姓名、编号、性别(女：1,男：0)、身份证号、总学时数、每周固定学时数、每周教学时数以及每周研究时数（Tips:每项空格隔开）\\n&quot;; in &gt;&gt; p.name &gt;&gt; p.number &gt;&gt; p.isGril &gt;&gt; p.id &gt;&gt; p.totalHours &gt;&gt; p.fixedPerWeekHours &gt;&gt; p.teachHours &gt;&gt; p.studyHours; return in; }3.2 交互式界面结构剖析如你所见到的，这些类已经可以完成信息的输入与输出，所以接下来我们要做的就是做一个交互式的界面。鄙人代码中大量使用了switch()语句，以实现交互。如下main()方法里的代码展示了整个系统的结构。 int main() { system(&quot;title 人员信息管理系统&quot;); while(1) { cout &lt;&lt; &quot;*********** 请输入您的选择 **********\\n&quot;; cout &lt;&lt; &quot; 1 录入 \\n&quot;; cout &lt;&lt; &quot; 2 显示 \\n&quot;; cout &lt;&lt; &quot; 3 退出 \\n&quot;; cout &lt;&lt; &quot;*********************************************\\n&quot;; cout &lt;&lt; &quot;&gt;&quot;; int choose1; cin &gt;&gt; choose1; switch (choose1) { case 1://录入 { system(&quot;cls&quot;); input(); system(&quot;pause&quot;); system(&quot;cls&quot;); break; } case 2://显示 { system(&quot;cls&quot;); print(); system(&quot;pause&quot;); system(&quot;cls&quot;); break; } case 3://退出 return 0; default: { cin.clear(); cin.ignore(1024, &apos;\\n&apos;); cout &lt;&lt; &quot;输入错误！可输入选项：[1,2,3]&quot;; system(&quot;pause&quot;); break; } } } }如你所见，代码中有大量文字以提示用户操作。这里面有几点需要说明的： system(“pause”) 用于暂停，目的是使用户能看见他的操作 system(“cls”)用于清屏，这样做可以实现界面的跳转操作（看起来是这样）。如果你对这个概念不清楚，没关系，你可以在文末下载打包好的exe程序体验一下，或者是自己动手试一下 cin.clear()和cin.ignore(1024, ‘\\n’)的作用是防止用户输入的东西与你规定使用的不一致而导致的程序崩溃 input()和print()函数里面也大量使用了switch()语句（ 实现交互 ），且代码结构与如上代码大致相同，这里不做分析,读者可在源代码中查看 input()与print()函数里面使用虚函数与指针实现了多态，由于笔者水平有限，这里也不做讲解，如有错误，欢迎斧正 四、效果演示用户主界面![在这里插入图片描述](https://img-blog.csdnimg.cn/20190328194858758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)选择2，进入显示界面![在这里插入图片描述](https://img-blog.csdnimg.cn/20190328194904661.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)按任意键后停留在原界面![在这里插入图片描述](https://img-blog.csdnimg.cn/20190328194919187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)输入e返回上一级，并选择1进行录入![在这里插入图片描述](https://img-blog.csdnimg.cn/201903281952277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)按任意键后仍然停留在原界面，再次输入![在这里插入图片描述](https://img-blog.csdnimg.cn/20190328195403526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)输入完成后，进入显示界面：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190328195412359.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)以上就是界面展示 五、源代码 源程序下载 提取码：hk46 #include &lt;iostream&gt; #include &lt;string&gt; using namespace std; int stuNum = 0; int teachNum = 0; int gradNum = 0; int taNum = 0; class people { public: people() {} virtual ~people(){} virtual void print(); protected: string name; string number; int isGril; string id; double totalHours; double fixedPerWeekHours; }; void people::print() { cout &lt;&lt; name &lt;&lt; &quot;信息表:\\n&quot;; cout &lt;&lt; &quot;姓名：&quot;&lt;&lt; name &lt;&lt;endl &lt;&lt; &quot;编号：&quot;&lt;&lt; number &lt;&lt; endl &lt;&lt; &quot;性别：&quot; &lt;&lt; ( isGril ==0 ? &quot;♀&quot; : &quot;♂&quot;) &lt;&lt; endl &lt;&lt; &quot;身份证号：&quot; &lt;&lt; id &lt;&lt; endl &lt;&lt; &quot;总学时数：&quot; &lt;&lt; totalHours &lt;&lt; endl &lt;&lt; &quot;每周固定学时数：&quot; &lt;&lt; fixedPerWeekHours &lt;&lt; endl; } class student : virtual public people { public: student(){} friend istream &amp; operator&gt;&gt;(istream &amp;in, student &amp;p); void print() { people::print(); } }; istream &amp; operator&gt;&gt;(istream &amp;in, student &amp;p) { cout &lt;&lt; &quot;请分别输入姓名、编号、性别(女：1,男：0)、身份证号、总学时数以及每周固定学时数（Tips:每项空格隔开）\\n&quot;; in &gt;&gt; p.name &gt;&gt; p.number &gt;&gt; p.isGril &gt;&gt; p.id &gt;&gt; p.totalHours &gt;&gt; p.fixedPerWeekHours; return in; } class teacher :virtual public people { public: teacher(){} friend istream &amp; operator&gt;&gt;(istream &amp;in, teacher &amp;p); void print() { people::print(); cout &lt;&lt; &quot;每周教学时数：&quot; &lt;&lt; teachHours; cout &lt;&lt; endl; } protected: double teachHours; }; istream &amp; operator&gt;&gt;(istream &amp;in, teacher &amp;p) { cout &lt;&lt; &quot;请分别输入姓名、编号、性别(女：1,男：0)、身份证号、总学时数、每周固定学时数以及每周教学时数（Tips:每项空格隔开）\\n&quot;; in &gt;&gt; p.name &gt;&gt; p.number &gt;&gt; p.isGril &gt;&gt; p.id &gt;&gt; p.totalHours &gt;&gt; p.fixedPerWeekHours &gt;&gt; p.teachHours; return in; } class graduate : virtual public student { public: graduate(){} friend istream &amp; operator&gt;&gt;(istream &amp;in, graduate &amp;p); void print() { student::print(); cout &lt;&lt; &quot;每周研究时数：&quot; &lt;&lt; studyHours; cout &lt;&lt; endl; } protected: double studyHours; }; istream &amp; operator&gt;&gt;(istream &amp;in, graduate &amp;p) { cout &lt;&lt; &quot;请分别输入姓名、编号、性别(女：1,男：0)、身份证号、总学时数、每周固定学时数以及每周研究时数（Tips:每项空格隔开）\\n&quot;; in &gt;&gt; p.name &gt;&gt; p.number &gt;&gt; p.isGril &gt;&gt; p.id &gt;&gt; p.totalHours &gt;&gt; p.fixedPerWeekHours &gt;&gt; p.studyHours; return in; } class TA : public graduate, public teacher { public: friend istream &amp; operator&gt;&gt;(istream &amp;in, TA &amp;p); void print() { teacher::print(); cout &lt;&lt; &quot;每周教学时数：&quot; &lt;&lt; teachHours &lt;&lt; endl &lt;&lt; &quot;每周研究时数：&quot; &lt;&lt; studyHours &lt;&lt; endl; } }; istream &amp; operator&gt;&gt;(istream &amp;in, TA &amp;p) { cout &lt;&lt; &quot;请分别输入姓名、编号、性别(女：1,男：0)、身份证号、总学时数、每周固定学时数、每周教学时数以及每周研究时数（Tips:每项空格隔开）\\n&quot;; in &gt;&gt; p.name &gt;&gt; p.number &gt;&gt; p.isGril &gt;&gt; p.id &gt;&gt; p.totalHours &gt;&gt; p.fixedPerWeekHours &gt;&gt; p.teachHours &gt;&gt; p.studyHours; return in; } void input(); void print(); student stu[50]; teacher tech[20]; graduate grad[50]; TA ta[50]; int main() { system(&quot;title 人员信息管理系统&quot;); while(1) { cout &lt;&lt; &quot;*********** 请输入您的选择 **********\\n&quot;; cout &lt;&lt; &quot; 1 录入 \\n&quot;; cout &lt;&lt; &quot; 2 显示 \\n&quot;; cout &lt;&lt; &quot; 3 退出 \\n&quot;; cout &lt;&lt; &quot;*********************************************\\n&quot;; cout &lt;&lt; &quot;&gt;&quot;; int choose1; cin &gt;&gt; choose1; switch (choose1) { case 1://录入 { system(&quot;cls&quot;); input(); system(&quot;pause&quot;); system(&quot;cls&quot;); break; } case 2://显示 { system(&quot;cls&quot;); print(); system(&quot;pause&quot;); system(&quot;cls&quot;); break; } case 3://退出 return 0; default: { cin.clear(); cin.ignore(1024, &apos;\\n&apos;); cout &lt;&lt; &quot;输入错误！可输入选项：[1,2,3]&quot;; system(&quot;pause&quot;); break; } } } } void print() { while(1) { system(&quot;cls&quot;); char choose; cout &lt;&lt; &quot;********** 当前位置：主菜单-&gt;输出 *********\\n&quot;; cout &lt;&lt; &quot;*********** 请输入您的选择 **********\\n&quot;; cout &lt;&lt; &quot; A/a 学生 \\n&quot;; cout &lt;&lt; &quot; B/b 教师 \\n&quot;; cout &lt;&lt; &quot; C/c 研究生 \\n&quot;; cout &lt;&lt; &quot; D/d 助教生 \\n&quot;; cout &lt;&lt; &quot; E/e 返回上一级 \\n&quot;; cout &lt;&lt; &quot;*********************************************\\n&quot;; cout &lt;&lt; &quot;&gt;&gt;&quot;; cin &gt;&gt; choose; switch (choose) { case &apos;a&apos;: case &apos;A&apos;: { people *p; cout &lt;&lt; &quot;****** 学生列表&quot; &lt;&lt; &quot; 共 &quot; &lt;&lt; stuNum &lt;&lt; &quot; 项 ******\\n&quot;; for (int i = 0; i &lt; stuNum; i++) { p = &amp;stu[i]; p-&gt;print(); cout &lt;&lt; endl; } system(&quot;pause&quot;); break; } case &apos;b&apos;: case &apos;B&apos;: { people *p; cout &lt;&lt; &quot;****** 教师列表&quot; &lt;&lt; &quot; 共 &quot; &lt;&lt; teachNum &lt;&lt; &quot; 项 ******\\n&quot;; for (int i = 0; i &lt; teachNum; i++) { p = &amp;tech[i]; p-&gt;print(); cout &lt;&lt; endl; } system(&quot;pause&quot;); break; } case &apos;c&apos;: case &apos;C&apos;: { people *p; cout &lt;&lt; &quot;****** 研究生列表&quot; &lt;&lt; &quot; 共 &quot; &lt;&lt; gradNum &lt;&lt; &quot; 项 ******\\n&quot;; for (int i = 0; i &lt; gradNum; i++) { p = &amp;grad[i]; p-&gt;print(); cout &lt;&lt; endl; } system(&quot;pause&quot;); break; } case &apos;d&apos;: case &apos;D&apos;: { people *p; cout &lt;&lt; &quot;****** 助教生列表&quot; &lt;&lt; &quot; 共 &quot; &lt;&lt; taNum &lt;&lt; &quot; 项 ******\\n&quot;; for (int i = 0; i &lt; taNum; i++) { p = &amp;ta[i]; p-&gt;print(); cout &lt;&lt; endl; } system(&quot;pause&quot;); break; } case &apos;e&apos;: case &apos;E&apos;: { return; } default: { cin.clear(); cin.ignore(1024, &apos;\\n&apos;); cout &lt;&lt; &quot;输入错误！可输入选项：[A ~ E内任意字母的大小写]&quot;; system(&quot;pause&quot;); system(&quot;cls&quot;); break; } } } } void input() { while (1) { system(&quot;cls&quot;); char choose; cout &lt;&lt; &quot;********** 当前位置：主菜单-&gt;录入 *********\\n&quot;; cout &lt;&lt; &quot;*********** 请输入您的选择 **********\\n&quot;; cout &lt;&lt; &quot; A/a 学生 \\n&quot;; cout &lt;&lt; &quot; B/b 教师 \\n&quot;; cout &lt;&lt; &quot; C/c 研究生 \\n&quot;; cout &lt;&lt; &quot; D/d 助教生 \\n&quot;; cout &lt;&lt; &quot; E/e 返回上一级 \\n&quot;; cout &lt;&lt; &quot;*********************************************\\n&quot;; cout &lt;&lt; &quot;&gt;&gt;&quot;; cin &gt;&gt; choose; switch (choose) { case &apos;a&apos;: case &apos;A&apos;: { int n; cout &lt;&lt; &quot;请输入录入学生数目 &gt;&gt;&gt;&quot;; cin &gt;&gt; n; cout &lt;&lt; endl; for (int i = stuNum; i &lt; n + stuNum; i++) { cin &gt;&gt; stu[i]; } stuNum += n; system(&quot;pause&quot;); break; } case &apos;b&apos;: case &apos;B&apos;: { int n; cout &lt;&lt; &quot;请输入录入教师数目 &gt;&gt;&gt;&quot;; cin &gt;&gt; n; cout &lt;&lt; endl; for (int i = teachNum; i &lt; n + teachNum; i++) { cin &gt;&gt; tech[i]; } teachNum += n; system(&quot;pause&quot;); break; } case &apos;c&apos;: case &apos;C&apos;: { int n; cout &lt;&lt; &quot;请输入录入研究生数目 &gt;&gt;&gt;&quot;; cin &gt;&gt; n; cout &lt;&lt; endl; for (int i = gradNum; i &lt; n + gradNum; i++) { cin &gt;&gt; grad[i]; } gradNum += n; system(&quot;pause&quot;); break; } case &apos;d&apos;: case &apos;D&apos;: { int n; cout &lt;&lt; &quot;请输入录入助教生数目 &gt;&gt;&gt;&quot;; cin &gt;&gt; n; cout &lt;&lt; endl; for (int i = taNum; i &lt; n + taNum; i++) { cin &gt;&gt; ta[i]; } taNum += n; system(&quot;pause&quot;); break; } case &apos;e&apos;: case &apos;E&apos;: { return; } default: { cin.clear(); cin.ignore(1024, &apos;\\n&apos;); cout &lt;&lt; &quot;输入错误！可输入选项：[A ~ E内任意字母的大小写]&quot;; system(&quot;pause&quot;); system(&quot;cls&quot;); break; } } } }","link":"/2019/03/28/c++ 简易人员信息管理系统/"},{"title":"用C++类做的奇怪的日历","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/86742006 一、欧拉欧拉欧拉欧拉欧拉用伪C++的面向对象的方法做了个日历（ 设计得完全不像类 ），功能主要如下： 跳转到某年某月某天 查看某年的全部日历 推算几天前是什么日子 推算几天后是什么日子 推算两个日期之间的间隔 查询星座 程序内的每一处都做了输出检测（包括日期输出与选择时输入的数字） 二、效果图（可能有潜在bug，虽然改了很多次了…(T ^ T) )话不多说，直接上效果图： 2.1 主界面![在这里插入图片描述](https://img-blog.csdnimg.cn/20190201155206239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 2.2 功能1 —— 日期跳转 ![在这里插入图片描述](https://img-blog.csdnimg.cn/20190201155332244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 如果输入的年月日为负数或者日期超过月份的最大天数时会报错，就像这样：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190201155505663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 2.3 功能 2 —— 日历查看打印方式为双列打印![在这里插入图片描述](https://img-blog.csdnimg.cn/20190203102815357.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 2.4 功能3 —— 日期向前推算![在这里插入图片描述](https://img-blog.csdnimg.cn/201902011603429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)打开手机日历验证以下：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190201160444399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 2.5 功能4 —— 日期向后推算![在这里插入图片描述](https://img-blog.csdnimg.cn/20190201160709239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)同样，手机验证：![在这里插入图片描述](https://img-blog.csdnimg.cn/20190201160729755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 2.6 功能5 —— 计算日期间隔![在这里插入图片描述](https://img-blog.csdnimg.cn/20190201161128280.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)![在这里插入图片描述](https://img-blog.csdnimg.cn/2019020116121711.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)![在这里插入图片描述](https://img-blog.csdnimg.cn/20190201161235895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 2.7 功能6 —— 查询星座![在这里插入图片描述](https://img-blog.csdnimg.cn/20190201161339250.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 三、不说了，直接看代码吧为什么说是伪C++的面向对象呢 ？（至少自己感觉不像），来看看 Calender类 吧： //Calender.h #include &lt;iostream&gt; #include &lt;tchar.h&gt; #include &lt;time.h&gt; #include &lt;Windows.h&gt; #include &lt;iomanip&gt; #include &lt;string&gt; using namespace std; extern int arrDays[12][6][7]; class Calender { public: Calender();//默认获取系统时间 Calender(int year, int month, int day);//自行定义 ~Calender(); static bool isLegalDate(int y, int m, int d); //判断输入的日期是否合法 static void changeFebDay(int y);//根据年份改变2月份天数 static bool isLeapYear(int y);//判断是否为闰年 static int isWeek(int y,int m,int d);//判断某年某月某日设计星期几 static int totalDay(int y, int m, int d);//计算某天是第几天 static string returnWeek(int w);//返回星期几的中文 static int returnDay(int y,int m);//返回某年某月的天数 static int returnYear(int y);//返回对应年份的总天数 static string returnSX(int y);//返回生肖 static void initCalender(int y);//初始化日历 static void print(int arrDay[]); static void printMonth(int y,int m,int d);//打印某年某月的日历 static void printCalender(int y);//双行打印年份对应的日历 static void dateForwardReckon(int y, int m, int d, int numOfDay);//日期向前推算 static void dateBackReckon(int y, int m, int d,int numOfDay);//日期向后推算 static int dateInterval(int y1, int m1, int d1, int y2, int m2, int d2);//推算日期间隔天数 static void isConstell(int y,int m, int d);//查询星座 void showDate();//显示时间 int dateInterval(int y1, int m1, int d1); void setYear(int y); void setMonth(int m); void setDay(int d); int getYear(); int getMonth(); int getDay(); private: static string months[12]; static int days[13]; static string weeks[7]; static string sx[12]; int year; int month; int day; };很多都是静态函数，而且函数超级多有木有（设计得不太合理），运算符重载、继承、多态什么的都没有（这些都没学，甚至类也还没学…)（不要在意这些细节(〃‘▽’〃)） 前方高能… //Calender.cpp #include &quot;pch.h&quot; #include &quot;Calender.h&quot; int arrDays[12][6][7] = { 0 }; int Calender::days[13] = { 0,31,28,31,30,31,30,31,31,30,31,30,31}; string Calender::weeks[7] = {&quot;星期天&quot; ,&quot;星期一&quot;,&quot;星期二&quot;, &quot;星期三&quot;, &quot;星期四&quot;, &quot;星期五&quot;, &quot;星期六&quot;}; string Calender::months[12] = { &quot;January&quot;,&quot;February&quot;, &quot;March&quot;, &quot;April&quot;, &quot;May&quot;, &quot;June&quot;, &quot;July&quot;, &quot;August&quot;, &quot;September&quot;, &quot;October&quot;, &quot;November&quot;, &quot;December&quot; }; string Calender::sx[12] = { &quot;猴&quot;,&quot;鸡&quot;,&quot;狗&quot;,&quot;猪&quot;,&quot;鼠&quot;,&quot;牛&quot;,&quot;虎&quot;,&quot;兔&quot;,&quot;龙&quot;,&quot;蛇&quot;,&quot;马&quot;,&quot;羊&quot; }; Calender::Calender() { time_t timer; time(&amp;timer); tm *t_tm = localtime(&amp;timer); year = t_tm-&gt;tm_year + 1900; month = t_tm-&gt;tm_mon + 1; day = t_tm-&gt;tm_mday; } Calender::Calender(int year = 2019, int month = 1, int day = 1) { this-&gt;year = year; this-&gt;month = month; this-&gt;day = day; } Calender::~Calender() { cout &lt;&lt; &quot;Loading...&quot; &lt;&lt; endl; } bool Calender::isLegalDate(int y, int m = 1, int d = 1) { if (y &lt; 0||m&lt;=0||d&lt;=0) { MessageBox(NULL, _T(&quot; 非法日期！日期中可能含有负数或者月份和日期为0！&quot;), _T(&quot;警告&quot;), MB_OK | MB_ICONEXCLAMATION); system(&quot;pause&quot;); return false; } if (d &gt; returnDay(y, m)) { MessageBox(NULL, _T(&quot; 非法日期！天数超过该月最大天数，请重新输入！&quot;), _T(&quot;警告&quot;), MB_OK | MB_ICONEXCLAMATION); system(&quot;pause&quot;); return false; } if (m &gt; 12) { MessageBox(NULL, _T(&quot; 非法日期！月份范围：1 ~ 12！&quot;), _T(&quot;警告&quot;), MB_OK | MB_ICONEXCLAMATION); system(&quot;pause&quot;); return false; } return true; } void Calender::changeFebDay(int y) { if (isLeapYear(y)) { days[2] = 29; } else { days[2] = 28; } } bool Calender::isLeapYear(int y) { if ((y % 4 == 0 &amp;&amp; y % 100 != 0) || y % 400 == 0) { return true; } else { return false; } } int Calender::isWeek(int y, int m = 1, int d = 1) { if (m == 1 &amp;&amp; d == 1)//一年第一天 { return ((y - 1) + (y - 1) / 4 - (y - 1) / 100 + (y - 1) / 400 + 1) % 7; } int _day = totalDay(y, m, d); return ((y - 1) + (y - 1) / 4 - (y - 1) / 100 + (y - 1) / 400 + _day) % 7; } int Calender::totalDay(int y, int m, int d = 1) { int sum = 0; for (int i = 0; i &lt; m; i++) { sum += days[i]; } sum += d; if (m &gt; 2 &amp;&amp; isLeapYear(y)) { sum += 1; } return sum; } void Calender::isConstell(int y,int m, int d) { cout &lt;&lt; &quot;你属&quot; &lt;&lt; returnSX(y) &lt;&lt; endl; switch(m) { case 1:if (d &lt;= 20) cout &lt;&lt; &quot;你是魔羯座&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;你是水瓶座&quot; &lt;&lt; endl; break; case 2:if (d &lt;= 19) cout &lt;&lt; &quot;你是水瓶座&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;你是双鱼座&quot; &lt;&lt; endl; break; case 3:if (d &lt;= 20) cout &lt;&lt; &quot;你是双鱼座&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;你是白羊座&quot; &lt;&lt; endl; break; case 4:if (d &lt;= 20) cout &lt;&lt; &quot;你是白羊座&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;你是金牛座&quot; &lt;&lt; endl; break; case 5:if (d &lt;= 21) cout &lt;&lt; &quot;你是金牛座&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;你是双子座&quot; &lt;&lt; endl; break; case 6:if (d &lt;= 21) cout &lt;&lt; &quot;你是双子座&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;你是巨蟹座&quot; &lt;&lt; endl; break; case 7:if (d &lt;= 22) cout &lt;&lt; &quot;你是巨蟹座&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;你是狮子座&quot; &lt;&lt; endl; break; case 8:if (d &lt;= 23) cout &lt;&lt; &quot;你是狮子座&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;你是处女座&quot; &lt;&lt; endl; break; case 9:if (d &lt;= 23) cout &lt;&lt; &quot;你是处女座&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;你是天秤座&quot; &lt;&lt; endl; break; case 10:if (d &lt;= 23) cout &lt;&lt; &quot;你是天秤座&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;你是天蝎座&quot; &lt;&lt; endl; break; case 11:if (d &lt;= 22) cout &lt;&lt; &quot;你是天蝎座&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;你是射手座&quot; &lt;&lt; endl; break; case 12:if (d &lt;= 21) cout &lt;&lt; &quot;你是射手座&quot; &lt;&lt; endl; else cout &lt;&lt; &quot;你是魔羯座&quot; &lt;&lt; endl; break; } } int Calender::returnDay(int y,int m) { if (m == 2 &amp;&amp; isLeapYear(y)) { return days[m] + 1; } else { return days[m]; } } string Calender::returnWeek(int w) { return weeks[w]; } int Calender::returnYear(int y) { if (isLeapYear(y)) return 366; else return 365; } string Calender::returnSX(int y) { return sx[y % 12]; } void Calender::initCalender(int y) { int i = 0; for (; i &lt; 12; i++) { for (int j = 0; j &lt; 6; j++) { for (int k = 0; k &lt; 7; k++) { arrDays[i][j][k] = 0; } } } int week = (isWeek(y)); int _week = ((isWeek(y) + 1) % 7 - 1); week = (week == 6 ? 6 : _week); int count; changeFebDay(y); i = 0; for (; i &lt; 12; i++) { count = 1; for (int j = 0; j &lt; 6; j++) { if (count &gt; days[i + 1]) break; for (int k = 0; k &lt; week; k++) arrDays[i][j][k] = 0; for (int k = week; k &lt; 7; k++) { arrDays[i][j][k] = count++; week++; if (week &gt;= 7) { week = 0; } if (count &gt; days[i + 1]) break; } } } } void Calender::print(int arrDay[]) { for (int k = 0; k &lt; 7; k++) { if (arrDay[k] == 0) { cout &lt;&lt; &quot; &quot;; } else { cout &lt;&lt; setw(3) &lt;&lt; arrDay[k] &lt;&lt; &quot; &quot;; } } } void Calender::printMonth(int y, int m, int d = 1) { initCalender(y); int week = isWeek(y, m); HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN);//黄字 cout &lt;&lt; endl &lt;&lt; setw(5) &lt;&lt; y &lt;&lt; &quot;/&quot; &lt;&lt; setw(2) &lt;&lt; m &lt;&lt; &quot;/&quot; &lt;&lt; setw(2) &lt;&lt; d &lt;&lt; weeks[isWeek(y, m, d)] &lt;&lt; endl; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE);//回复白色 cout &lt;&lt; endl &lt;&lt;setw(27) &lt;&lt; months[m-1] &lt;&lt; endl; cout &lt;&lt; &quot;---------------------------\\n&quot;; cout &lt;&lt; &quot;Sun Mon Tue Wed Thu Fri Sat\\n&quot;; for (int k = 0; k &lt; week; k++) printf(&quot; &quot;); // 每月一号对齐它的星期数 int days = returnDay(y, m); for (int j = 1; j &lt;= days; j++) { if(j==d) { HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_GREEN); cout &lt;&lt; setw(3) &lt;&lt; j &lt;&lt; &quot; &quot;; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE); } else { cout &lt;&lt; setw(3) &lt;&lt; j &lt;&lt; &quot; &quot;; } week++; if (week &gt;= 7) { cout &lt;&lt; endl; week %= 7; } } cout &lt;&lt; endl; } void Calender::printCalender(int y) { HANDLE handle = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleTextAttribute(handle, FOREGROUND_INTENSITY | FOREGROUND_RED | FOREGROUND_GREEN);//黄字 cout &lt;&lt; endl &lt;&lt; setw(28) &lt;&lt; y &lt;&lt; &quot;年日历&quot; &lt;&lt; endl &lt;&lt; endl; SetConsoleTextAttribute(GetStdHandle(STD_OUTPUT_HANDLE), FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_BLUE);//回复白色 initCalender(y); for (int i = 1; i &lt;= 11; i += 2) { cout &lt;&lt; setw(27) &lt;&lt; months[i-1] &lt;&lt; &quot;\\t&quot; &lt;&lt; setw(27) &lt;&lt; months[i]&lt;&lt; endl; cout &lt;&lt; &quot;---------------------------\\t---------------------------\\n&quot;; cout &lt;&lt; &quot;Sun Mon Tue Wed Thu Fri Sat\\tSun Mon Tue Wed Thu Fri Sat\\n&quot;; for (int j = 0; j &lt; 6; j++) { print(arrDays[i-1][j]); cout &lt;&lt; &quot;\\t&quot;; print(arrDays[i][j]); cout &lt;&lt; endl; } } } void Calender::dateForwardReckon(int y, int m, int d, int numOfDay) { cout &lt;&lt; y &lt;&lt; &quot;/&quot; &lt;&lt; m &lt;&lt; &quot;/&quot; &lt;&lt; d &lt;&lt; &quot; &quot; &lt;&lt; weeks[isWeek(y, m, d)] &lt;&lt; &quot;的&quot; &lt;&lt; numOfDay &lt;&lt; &quot;天前是：&quot;; if (numOfDay == 0) { cout &lt;&lt; y &lt;&lt; &quot;/&quot; &lt;&lt; m &lt;&lt; &quot;/&quot; &lt;&lt; d &lt;&lt; &quot; &quot; &lt;&lt; weeks[isWeek(y, m, d)] &lt;&lt; endl; return; } if (d &gt;= numOfDay) { d -= numOfDay; if (d == 0) { m--; if (m == 0) { y--; m = 12; } d = returnDay(y, m); } cout &lt;&lt; y &lt;&lt; &quot;/&quot; &lt;&lt; m &lt;&lt; &quot;/&quot; &lt;&lt; d &lt;&lt; &quot; &quot; &lt;&lt; weeks[isWeek(y, m, d)] &lt;&lt; endl; } else { numOfDay -= d; m -= 1; if (m &lt;= 0) { y--; m = 12; } for (int i = m;; i--) { changeFebDay(y); int temp = numOfDay; numOfDay -= days[i]; if (numOfDay &lt; 0) { d = returnDay(y,m)-temp; m = i; break; } if (i &lt;= 1) { y--; i = 13; } } cout &lt;&lt; y &lt;&lt; &quot;/&quot; &lt;&lt; m &lt;&lt; &quot;/&quot; &lt;&lt; d &lt;&lt; &quot; &quot; &lt;&lt; weeks[isWeek(y, m, d)] &lt;&lt; endl; } } void Calender::dateBackReckon(int y, int m, int d, int numOfDay) { cout &lt;&lt; y &lt;&lt; &quot;/&quot; &lt;&lt; m &lt;&lt; &quot;/&quot; &lt;&lt; d &lt;&lt; &quot; &quot; &lt;&lt; weeks[isWeek(y, m, d)] &lt;&lt; &quot;的&quot; &lt;&lt; numOfDay &lt;&lt; &quot;天后是：&quot;; if(numOfDay == 0) { cout &lt;&lt; y &lt;&lt; &quot;/&quot; &lt;&lt; m &lt;&lt; &quot;/&quot; &lt;&lt; d &lt;&lt; &quot; &quot; &lt;&lt; weeks[isWeek(y, m, d)] &lt;&lt; endl; return; } int end = returnDay(y, m) - d;//参数所传日期距离月尾end天 if (end &gt;= numOfDay) { d += numOfDay; cout &lt;&lt; y &lt;&lt; &quot;/&quot; &lt;&lt; m &lt;&lt; &quot;/&quot; &lt;&lt; d &lt;&lt; &quot; &quot; &lt;&lt; weeks[isWeek(y, m, d)] &lt;&lt; endl; } else { numOfDay -= end; m += 1; if (m &gt;= 13)// { y++; m = 1; } for (int i = m;;i++) { changeFebDay(y); int temp = numOfDay; numOfDay -= days[i]; if (numOfDay &lt;= 0) { d = temp; m = i; break; } if (i &gt;= 12)//月份满12，年份进1 { y++; i = 0; } } cout &lt;&lt; y &lt;&lt; &quot;/&quot; &lt;&lt; m &lt;&lt; &quot;/&quot; &lt;&lt; d &lt;&lt; &quot; &quot; &lt;&lt; weeks[isWeek(y,m,d)]&lt;&lt;endl; } } void Calender::showDate() { cout &lt;&lt; &quot; 当前日期：&quot; &lt;&lt; year &lt;&lt; &quot;/&quot; &lt;&lt; month &lt;&lt; &quot;/&quot; &lt;&lt; day &lt;&lt; endl &lt;&lt; endl; } int Calender::dateInterval(int y1, int m1, int d1, int y2, int m2, int d2) { int max = y1 &gt; y2 ? y1 : y2; int min = y1 &lt; y2 ? y1 : y2; int day1, day2; int sum = 0; if(max==min)//年份相同 { day1 = totalDay(y1, m1, d1); day2 = totalDay(y2, m2, d2); sum = abs(day1 - day2); return sum; } if (max == y1)//第一个日期比较小 { day1 = totalDay(y1, m1, d1); day2 = returnYear(y2) - totalDay(y2, m2, d2); } else//第二个日期比较小 { day1 = returnYear(y1) - totalDay(y1, m1, d1); day2 = totalDay(y2, m2, d2); } int temp = (max - min - 1) * 365; if (temp &lt; 0) sum = 0; else sum = temp; for (int i = min + 1; i &lt; max; i++) { if (isLeapYear(i)) { sum += 1; } } sum += day1 + day2; return sum; } int Calender::dateInterval(int y1, int m1, int d1) { int y2 = year, m2 = month, d2 = day; return dateInterval(y1, m1, d1, y2, d2, m2); } void Calender::setYear(int y) { year = y; } void Calender::setMonth(int m) { month = m; } void Calender::setDay(int d) { day = d; } int Calender::getYear() { return year; } int Calender::getMonth() { return month; } int Calender::getDay() { return day; }主程序 ： !!!∑(ﾟДﾟノ)ノ小伙只，你能看到这，厉害了！#include &quot;Calender.h&quot; void input(int &amp;a) { cin &gt;&gt; a; while (cin.fail() || a &lt; 0) { MessageBox(NULL, _T(&quot;输入错误,请重新输入！&quot;), _T(&quot;警告&quot;), MB_OK | MB_ICONEXCLAMATION); cin.clear(); while (cin.get() != &apos;\\n&apos;) { continue; } cin &gt;&gt; a; } } int main() { system(&quot;title 奇怪的日历&quot;); int year, month, day, _day; int choose; while (1) { system(&quot;cls&quot;); Calender mycalender; mycalender.showDate(); mycalender.printMonth(mycalender.getYear(), mycalender.getMonth(),mycalender.getDay()); cout &lt;&lt; &quot;***********************************************************************************&quot; &lt;&lt; endl; cout &lt;&lt; &quot;〓〓〓〓〓〓〓〓〓〓 ☆ 主 菜 单 ☆ 〓〓〓〓〓〓〓〓〓〓&quot; &lt;&lt; endl; cout &lt;&lt; &quot;〓〓〓〓〓〓〓★★★★★ ★★★★★★★ ★★★★★〓〓〓〓〓〓〓&quot; &lt;&lt; endl; cout &lt;&lt; &quot;〓〓〓〓〓〓〓〓〓★ ☆ 1.跳转到某年某月某天 ☆ ★〓〓〓〓〓〓〓〓〓&quot; &lt;&lt; endl; cout &lt;&lt; &quot;〓〓〓〓〓〓〓〓〓★ ☆ 2.查看某年的全部日历 ☆ ★〓〓〓〓〓〓〓〓〓&quot; &lt;&lt; endl; cout &lt;&lt; &quot;〓〓〓〓〓〓〓〓〓★ ☆ 3.推算几天前是什么日子 ☆ ★〓〓〓〓〓〓〓〓〓&quot; &lt;&lt; endl; cout &lt;&lt; &quot;〓〓〓〓〓〓〓〓〓★ ☆ 4.推算几天后是什么日子 ☆ ★〓〓〓〓〓〓〓〓〓&quot; &lt;&lt; endl; cout &lt;&lt; &quot;〓〓〓〓〓〓〓〓〓★ ☆ 5.推算两个日期之间的间隔 ☆ ★〓〓〓〓〓〓〓〓〓&quot; &lt;&lt; endl; cout &lt;&lt; &quot;〓〓〓〓〓〓〓〓〓★ ☆ 6.查询星座 ☆ ★〓〓〓〓〓〓〓〓〓&quot; &lt;&lt; endl; cout &lt;&lt; &quot;〓〓〓〓〓〓〓〓〓★ ☆ 7.安全退出日历 ☆ ★〓〓〓〓〓〓〓〓〓&quot; &lt;&lt; endl; cout &lt;&lt; &quot;\\n\\t\\t\\n\\t\\t请选择：&quot;; input(choose); switch (choose) { case 1: while (1) { cout &lt;&lt; &quot;\\t\\t请输入合法年份：&quot;; input(year); cout &lt;&lt; &quot;\\t\\t请输入合法月份：&quot;; input(month); cout &lt;&lt; &quot;\\t\\t请输入合法日期：&quot;; input(day); if (Calender::isLegalDate(year, month, day)) { mycalender.printMonth(year, month, day); system(&quot;pause&quot;); break; } } break; case 2: while (1) { cout &lt;&lt; &quot;\\t\\t请输入合法年份：&quot;; input(year); if (Calender::isLegalDate(year,1,1)) { mycalender.printCalender(year); system(&quot;pause&quot;); break; } } break; case 3: while (1) { cout &lt;&lt; &quot;\\t\\t请输入合法年份：&quot;; input(year); cout &lt;&lt; &quot;\\t\\t请输入合法月份：&quot;; input(month); cout &lt;&lt; &quot;\\t\\t请输入合法日期：&quot;; input(day); if (Calender::isLegalDate(year, month, day)) { cout &lt;&lt; &quot;\\t\\t请输入天数：&quot;; input(_day); mycalender.dateForwardReckon(year, month, day, _day); system(&quot;pause&quot;); break; } } break; case 4: while (1) { cout &lt;&lt; &quot;\\t\\t请输入合法年份：&quot;; input(year); cout &lt;&lt; &quot;\\t\\t请输入合法月份：&quot;; input(month); cout &lt;&lt; &quot;\\t\\t请输入合法日期：&quot;; input(day); if (Calender::isLegalDate(year, month, day)) { cout &lt;&lt; &quot;\\t\\t请输入天数：&quot;; input(_day); mycalender.dateBackReckon(year, month, day, _day); system(&quot;pause&quot;); break; } } break; case 5: while (1) { cout &lt;&lt; &quot;\\t\\t请输入合法年份：&quot;; input(year); cout &lt;&lt; &quot;\\t\\t请输入合法月份：&quot;; input(month); cout &lt;&lt; &quot;\\t\\t请输入合法日期：&quot;; input(day); if (Calender::isLegalDate(year, month, day)) { int _year, _month, _day; while(1) { cout &lt;&lt; &quot;\\t\\t请输入合法年份：&quot;; input(_year); cout &lt;&lt; &quot;\\t\\t请输入合法月份：&quot;; input(_month); cout &lt;&lt; &quot;\\t\\t请输入合法日期：&quot;; input(_day); if (Calender::isLegalDate(_year, _month, _day)) { cout &lt;&lt; year &lt;&lt; &quot; - &quot; &lt;&lt; month &lt;&lt; &quot; - &quot; &lt;&lt; day &lt;&lt; Calender::returnWeek(Calender::isWeek(year, month, day))&lt;&lt; &quot; 与 &quot; &lt;&lt; _year &lt;&lt; &quot; - &quot; &lt;&lt; _month &lt;&lt; &quot; - &quot; &lt;&lt; _day &lt;&lt; Calender::returnWeek(Calender::isWeek(_year, _month, _day)) &lt;&lt; &quot;相隔&quot; &lt;&lt; Calender::dateInterval(year,month,day,_year,_month,_day) &lt;&lt; &quot;天&quot; &lt;&lt; endl; system(&quot;pause&quot;); break; } } break; } } break; case 6: while (1) { cout &lt;&lt; &quot;\\t\\t请输入合法年份：&quot;; input(year); cout &lt;&lt; &quot;\\t\\t请输入合法月份：&quot;; input(month); cout &lt;&lt; &quot;\\t\\t请输入合法日期：&quot;; input(day); if (Calender::isLegalDate(year, month, day)) { mycalender.isConstell(year, month, day); system(&quot;pause&quot;); break; } } break; case 7: return 0; default: MessageBox(NULL, _T(&quot;不在指定输入范围内，请重新输入!&quot;), _T(&quot;警告&quot;), MB_OK | MB_ICONEXCLAMATION); break; } } }","link":"/2019/02/01/用C++类做的奇怪的日历/"},{"title":"学生成绩管理系统（简易本地版）","text":"版权声明：本文为博主原创文章，遵循 CC 4.0BY-SA 版权协议，转载请附上原文出处链接和本声明。 本文链接： https://blog.csdn.net/weixin_43894577/article/details/85317488 学生成绩管理系统（简易本地版）一、概述 平台：Windows 10 ，Microsoft Visual Studio 2017语言：C++，面向过程完成日期：2018/12/27主要功能：1. 添加学生的信息（包括 学号，姓名，性别，成绩） **_2. 显示学生的信息** __3.查询学生的信息（ 以学号或姓名的方式查询） __4.修改学生的信息 __5.保存学生的信息（txt文件） __*6.删除和排序学生的信息 ，暂不支持 * _除此外还用Windows.h头文件里面的光标定位函数做了一个键盘操作界面和小动画。 二、 用到了哪些知识？1.C++基本的语法（结构体，函数，输入输出流，文件操作流等）2.system函数 函数原型:int system(const char *command); 头文件：&lt; cstdlib &gt; 或 &lt; process.h &gt; 功能:在C++代码中执行 DOS (Disk Operation System,磁盘操作系统) 指令。 常用的函数：system(“cls”) //清屏system(“pause”) //按任意键system(“title xxx”)//设置标题为xxxsystem(“color 02”)// 黑底绿字![在这里插入图片描述](https://img-blog.csdnimg.cn/2018122810141758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 三、主要功能的说明1. 头文件预览 //student.h #pragma once #include &lt;iostream&gt; #include &lt;cstdlib&gt;//exit()函数 #include &lt;Windows.h&gt;//光标定位 #include &lt;fstream&gt;//C++ I/O流 #include &lt;string&gt; #include &lt;conio.h&gt; using namespace std; void SetPos(COORD a);//光标定位 void SetPos(int i, int j); void HideCursor();//隐藏光标 void show();//展现学生信息 void input();//录入信息 void search();//查找信息 void print();//保存本地txt文件 void load();//加载动画 void modify();//修改信息 void menu_flash();//菜单子模块 int menu_choose(); void theme();//选择背景色 void menu();//主菜单 void help();//开局动画之一2.关于一些变量的说明首先定义了一个结构体student，并申明了一个students。 struct student { string Number; string Name; string Sex; int Clanguage; int English; int Math; }; student students; const char *txtfile = &quot;2333.txt&quot;;//文件名 const char *datfile = &quot;2333.dat&quot;; ifstream a;//a和b都对dat操作 ofstream b; ofstream d;//d对txt操作 string file;//对txt重命名 string endline = &quot;.txt&quot;;//添加后缀，保存为txt文件时用于重命名 int ct = 1;//指针位置+1，用于修改时确认指针的位置3.主要函数说明(1)录入学生信息直接打开dat文件进行输入，最后记得要关闭文件。 void input() { system(&quot;cls&quot;); b.open(datfile, ios_base::binary | ios_base::out | ios_base::app); if (!b.is_open()) { cout &lt;&lt; &quot;\\a文件打开失败,请稍后重试.&quot; &lt;&lt; endl; exit(EXIT_FAILURE); } int c = 1; cout &lt;&lt; &quot;格式:\\t&quot;; cout &lt;&lt; &quot;学号\\t\\t姓名\\t性别\\t\\tC++成绩\\t\\t英语成绩\\t\\t高等数学&quot; &lt;&lt; endl; cout &lt;&lt; &quot; 各项信息间以空格隔开\\n&quot;; while (c) { cin &gt;&gt; students.Number; cin &gt;&gt; students.Name; cin &gt;&gt; students.Sex; cin &gt;&gt; students.Clanguage; cin &gt;&gt; students.English; cin &gt;&gt; students.Math; b.write((char *)&amp;students, sizeof students); cout &lt;&lt; &quot;0 ———— 退出 1 ———— 继续输入:&quot;; cin &gt;&gt; c; } b.close(); }（2）显示学生的信息其中的变量ct为序号，用于修改信息时确认指针的位置。 void show()//打开dat文件并输出到界面上 { system(&quot;cls&quot;); ct = 1; a.open(datfile, ios_base::binary | ios_base::in); if (a.is_open()) { cout &lt;&lt; &quot;\\t\\t\\t学生信息表:\\n\\n&quot;; cout &lt;&lt; &quot;序号\\t学号\\t\\t姓名\\t性别\\tC++\\t英语\\t高等数学&quot; &lt;&lt; endl; while (a.read((char *)&amp;students, sizeof students)) { cout &lt;&lt; ct++ &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Number &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Name &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Sex &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Clanguage &lt;&lt; &quot;\\t&quot; &lt;&lt; students.English &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Math &lt;&lt; endl; } a.close(); } else { cout &lt;&lt; &quot;\\a信息加载失败!请初始化后重试！&quot;; } }（3）查询学生的信息打开dat文件，获取学生的信息，根据用户的选择来搜索比较对应信息。如果相等，则输出该学生信息，否则代表无该学生的信息。变量choose用来响应用户的操作（退出，姓名查找和学号查找）；变量flag用来确认是否查找成功；最后别忘了关闭文件。 void search()// { system(&quot;cls&quot;); int choose; while (1) { a.open(datfile, ios_base::binary | ios_base::in); cout &lt;&lt; &quot;0 ———— 退出 1 ———— 按姓名查找 2 ———— 按学号查找\\n&quot;; cin &gt;&gt; choose; string name; string num; if (choose == 0) { a.close(); return; } if (choose == 1) { cout &lt;&lt; &quot;请输入查找姓名:&quot;; cin &gt;&gt; name; } if (choose == 2) { cout &lt;&lt; &quot;请输入查找学号&quot;; cin &gt;&gt; num; } if (a.is_open()) { int flag = 0;//判断是否找到 cout &lt;&lt; &quot;学号\\t姓名\\t性别\\tC++\\t英语\\t高等数学&quot; &lt;&lt; endl; while (a.read((char *)&amp;students, sizeof students)) { if (choose == 1 &amp;&amp; students.Name == name) { cout &lt;&lt; students.Number &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Name &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Sex &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Clanguage &lt;&lt; &quot;\\t&quot; &lt;&lt; students.English &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Math &lt;&lt; endl; flag = 1; } if (choose == 2 &amp;&amp; students.Number == num) { cout &lt;&lt; students.Number &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Name &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Sex &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Clanguage &lt;&lt; &quot;\\t&quot; &lt;&lt; students.English &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Math &lt;&lt; endl; flag = 1; } } if (flag == 0) { cout &lt;&lt; &quot;查询不到此信息！\\n&quot;; } } else { cout &lt;&lt; &quot;\\a信息加载失败!请初始化后重试！&quot;; } a.close(); } }（4）修改学生的信息变量a_1的类型为fstream，可读可写。根据序号确认被修改的学生的信息在文件中的位置，并进行重新输入。 void modify()//修改 { fstream a_1; a_1.open(datfile, ios_base::in | ios_base::out | ios_base::binary); if (a_1.is_open()) { int point;//想修改的数字 int end = 1;// while (end) { show(); cout &lt;&lt; &quot;0 ———— 退出&quot;; cout &lt;&lt; &quot;请输入对应序号:&quot;; cin &gt;&gt; point; if (point &gt;= 1 &amp;&amp; point &lt;= ct - 1) { streampos place = (point - 1) * sizeof students; a_1.seekg(place); if (a_1.fail()) { cout &lt;&lt; &quot;查找错误...\\n&quot;; exit(EXIT_FAILURE); } a_1.read((char *)&amp;students, sizeof students); cout &lt;&lt; &quot;您即将修改的信息如下:\\n&quot;; cout &lt;&lt; point &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; students.Number &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Name &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Sex &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Clanguage &lt;&lt; &quot;\\t&quot; &lt;&lt; students.English &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Math &lt;&lt; endl; if (a_1.eof()) { a_1.clear(); } cout &lt;&lt; &quot;学号:________\\b\\b\\b\\b\\b\\b&quot;; cin &gt;&gt; students.Number; cout &lt;&lt; &quot;姓名:________\\b\\b\\b\\b\\b\\b&quot;; cin &gt;&gt; students.Name; cout &lt;&lt; &quot;性别:___\\b\\b\\b&quot;; cin &gt;&gt; students.Sex; cout &lt;&lt; &quot;C++:___\\b\\b\\b&quot;; cin &gt;&gt; students.Clanguage; cout &lt;&lt; &quot;英语:___\\b\\b\\b&quot;; cin &gt;&gt; students.English; cout &lt;&lt; &quot;高等数学:___\\b\\b\\b&quot;; cin &gt;&gt; students.Math; a_1.seekp(place); a_1.write((char *)&amp;students, sizeof students); if (a_1.fail()) { cout &lt;&lt; &quot;写入错误\\n&quot;; exit(EXIT_FAILURE); } show(); cout &lt;&lt; &quot;是否继续修改？\\n&quot; &lt;&lt; &quot;0 ———— 退出 1 ———— 继续&quot;; cin &gt;&gt; end; if (end == 0) a_1.close(); system(&quot;cls&quot;); } else if (point == 0) { a_1.close(); return; } else { cout &lt;&lt; &quot;\\a输入的数字不在有效范围&quot; &lt;&lt; &quot;(&quot; &lt;&lt; 1 &lt;&lt; &quot;~&quot; &lt;&lt; ct - 1 &lt;&lt; &quot;)&quot; &lt;&lt; &quot;内,请重新输入.\\n&quot;; system(&quot;pause&quot;); system(&quot;cls&quot;); } } } else { cout &lt;&lt; &quot;\\a无法打开&quot; &lt;&lt; datfile &lt;&lt; endl; } }（5）保存学生的信息打开dat文件，创建并打开txt文件，将dat文件内的信息写入txt文件，写入后关闭dat和txt文件，完成操作。在这里，提供了重命名操作，最终文件会以txt格式保存在程序所在的目录。 void print() { system(&quot;cls&quot;); a.open(datfile, ios_base::binary | ios_base::in); if (a.is_open()) { cout &lt;&lt; &quot;文件名:&quot; &lt;&lt; txtfile &lt;&lt; &quot;,是否修改文件名？\\n&quot;; cout &lt;&lt; &quot; /\\\\ 0 ———— 否&quot; &lt;&lt; endl; cout &lt;&lt; &quot; /!!\\\\ 1 ———— 是&quot; &lt;&lt; endl; cout &lt;&lt; &quot;/ \\\\若文件夹中出现同名文件,可能将其覆盖.\\n&quot; &lt;&lt; &quot;￣￣￣\\n&quot;; int answer; while (1)//修改文件名 { cin &gt;&gt; answer; if (answer == 1) { cout &lt;&lt; &quot;请输入文件名 (不要加后缀）:&quot;; cin &gt;&gt; file; d.open((file + endline), ios_base::out); break; } else if (answer == 0) { d.open(txtfile, ios_base::out); break; } else { cout &lt;&lt; &quot;输入错误,请重新输入!\\n&quot;; continue; } } if (d.is_open()) { d &lt;&lt; &quot;学号\\t姓名\\t性别\\t\\tC++\\t\\t英语\\t\\t高等数学\\n&quot;; while (a.read((char *)&amp;students, sizeof students)) { d &lt;&lt; students.Number &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Name &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Sex &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; students.Clanguage &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; students.English &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; students.Math &lt;&lt; endl; } cout &lt;&lt; &quot;保存成功!&quot;; cout &lt;&lt; &quot;您的文件名为&quot; &lt;&lt; (answer == 1 ? (file + endline) : txtfile); cout &lt;&lt; &quot;请及时提取相关文件，以免文件失效或损坏\\n&quot;; d.close(); } a.close(); } else { cout &lt;&lt; &quot;\\a文件载入失败,请稍后重试.\\n&quot;; } }（6）其他部分加载动画 void load()//动画1 { system(&quot;pause&quot;); system(&quot;cls&quot;); SetPos(50, 14); string LOAD = &quot;加载中&quot;; cout &lt;&lt; LOAD; for (int i = 0; i &lt; 6; i++) { Sleep(150); cout &lt;&lt; &quot;.&quot;; } system(&quot;cls&quot;); } void help()//动画2 { Sleep(100); system(&quot;cls&quot;); system(&quot;color 0E&quot;); SetPos(12, 7); cout &lt;&lt; &quot;☆☆★★★★★★★★★★★★★★★★★★★☆☆&quot;; SetPos(12, 8); cout &lt;&lt; &quot;☆★ ★☆&quot;; SetPos(12, 9); cout &lt;&lt; &quot;☆★ ★★★ ★★★ ★☆&quot;; SetPos(12, 10); cout &lt;&lt; &quot;☆★ ★☆☆☆★☆★☆☆☆★ ★☆ &quot;; SetPos(12, 11); cout &lt;&lt; &quot;☆★ ★★ ★★☆☆☆★☆☆☆☆★ ★☆&quot;; SetPos(12, 12); cout &lt;&lt; &quot;☆★ ★☆☆★ ★★☆★☆☆☆☆☆☆☆★ ★☆ &quot;; SetPos(12, 13); cout &lt;&lt; &quot;☆★ ★☆☆☆★☆☆★★☆☆☆☆☆☆★ ★☆ &quot;; SetPos(12, 14); cout &lt;&lt; &quot;☆★ ★☆☆☆☆☆★★☆☆☆☆☆★ ★☆&quot;; SetPos(12, 15); cout &lt;&lt; &quot;☆★ ★☆☆☆★ ★☆☆☆★ ★☆ &quot;; SetPos(12, 16); cout &lt;&lt; &quot;☆★ ★☆★ ★ ★☆ &quot;; SetPos(12, 17); cout &lt;&lt; &quot;☆★ ★ ★☆ &quot;; SetPos(12, 18); cout &lt;&lt; &quot;☆★ Ich/liebe/dich制作 ★☆&quot;; SetPos(12, 19); cout &lt;&lt; &quot;☆☆★★★★★★★★★★★★★★★★★★★☆☆★★★&quot;; Sleep(1000); system(&quot;cls&quot;); system(&quot;color 0F&quot;); }菜单界面（键盘操作）主要思路:用户输入操作时，光标会向指定方向移动，移动后对应的值会发生改变，当用户确认操作时，对应的值会代入特定函数计算,并返回这个计算出的值，根据这个值来确认要调用哪一个函数（switch）。 /*************************** *****以下为菜单操作子模块*** *************************/ void menu_flash() { for (int i = 12; i &lt;= 18; i++) { SetPos(42, i); cout &lt;&lt; &quot; &quot;; } } /*************************** *****以下为菜单操作模块***** **************************/ int menu_choose() { int j = 13; while (1) { if (_kbhit()) { char x = _getch(); switch (x) { case &apos;w&apos;: { if (j == 13 || j == 14 || j == 15 || j == 16 || j == 17 || j == 18 || j == 19) { menu_flash(); j = j - 1; SetPos(42, j); cout &lt;&lt; &quot;&gt;&gt;&quot;; } else if (j == 12 &amp;&amp; x == &apos;w&apos;) { j = 19; } break; } case &apos;s&apos;: { if (j == 11 || j == 12 || j == 13 || j == 14 || j == 15 || j == 16 || j == 17) { menu_flash(); j = j + 1; SetPos(42, j); cout &lt;&lt; &quot;&gt;&gt;&quot;; } else if (j == 18 &amp;&amp; x == &apos;s&apos;) { j = 11; } break; } case &apos;k&apos;: { return j - 11; } } } } } /*************************** *******以下为菜单界面******* **************************/ void menu() { system(&quot;cls&quot;); SetPos(43, 5); string title = &quot;学生成绩管理系统&quot;; for (int i = 0; i &lt; title.size(); i++) { Sleep(40); cout &lt;&lt; title[i]; } SetPos(12, 7); cout &lt;&lt; &quot; ______________________________________________________________________________ &quot;; SetPos(12, 8); cout &lt;&lt; &quot;| w : 上 s : 下 k : 确认 |&quot;; for (int i = 9; i &lt;= 10; i++) { SetPos(12, i); cout &lt;&lt; &quot;| |&quot;; } SetPos(12, 11); cout &lt;&lt; &quot;| *************************************************************************** |&quot;; SetPos(12, 12); cout &lt;&lt; &quot;| ************************ 1.录入信息 ****************************** |&quot;; SetPos(12, 13); cout &lt;&lt; &quot;| ************************ 2.查看信息 ****************************** |&quot;; SetPos(12, 14); cout &lt;&lt; &quot;| ************************ 3.修改信息 ****************************** |&quot;; SetPos(12, 15); cout &lt;&lt; &quot;| ************************ 4.打印文件 ****************************** |&quot;; SetPos(12, 16); cout &lt;&lt; &quot;| ************************ 5. 搜索 ****************************** |&quot;; SetPos(12, 17); cout &lt;&lt; &quot;| ************************ 6. 主题 ****************************** |&quot;; SetPos(12, 18); cout &lt;&lt; &quot;| ************************ 7. 关于 ****************************** |&quot;; SetPos(12, 19); cout &lt;&lt; &quot;| *************************************************************************** |&quot;; for (int i = 20; i &lt;= 22; i++) { SetPos(12, i); cout &lt;&lt; &quot;| |&quot;; } SetPos(12, 23); cout &lt;&lt; &quot; ￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣ &quot;; }四，效果打开界面时的动画![在这里插入图片描述](https://img-blog.csdnimg.cn/20181228111708867.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)主界面![在这里插入图片描述](https://img-blog.csdnimg.cn/20181228111943907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)在没有初始化（录入信息）前进行操作![在这里插入图片描述](https://img-blog.csdnimg.cn/20181228112013188.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)录入信息![在这里插入图片描述](https://img-blog.csdnimg.cn/20181228113218895.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)查看信息![在这里插入图片描述](https://img-blog.csdnimg.cn/20181228113141181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70)保存本地文档:![在这里插入图片描述](https://img-blog.csdnimg.cn/20181228113239596.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 保存本地txt文档：![在这里插入图片描述](https://img-blog.csdnimg.cn/20181228113047458.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg5NDU3Nw==,size_16,color_FFFFFF,t_70) 五，源代码1.头文件（student.h) #pragma once #include &lt;iostream&gt; #include &lt;cstdlib&gt;//exit()函数 #include &lt;Windows.h&gt;//光标定位 #include &lt;fstream&gt;//C++ I/O流 #include &lt;string&gt; #include &lt;conio.h&gt; using namespace std; void SetPos(COORD a);//光标定位 void SetPos(int i, int j); void HideCursor();//隐藏光标 void show();//展现学生信息 void input();//录入信息 void search();//查找信息 void print();//保存本地txt文件 void load();//加载动画 void modify();//修改信息 void menu_flash();//菜单子模块 int menu_choose(); void theme();//选择背景色 void menu();//主菜单 void help();//开局动画之一2.student.cpp #include &quot;student.h&quot; struct student { string Number; string Name; string Sex; int Clanguage; int English; int Math; }; const char *txtfile = &quot;2333.txt&quot;;//文件名 const char *datfile = &quot;2333.dat&quot;; student students; ifstream a;//a和b都对dat操作 ofstream b; ofstream d;//d对txt操作 string file;//对txt重命名 string endline = &quot;.txt&quot;;//添加后缀 int ct = 1;//指针位置+1 void SetPos(COORD a)// set cursor { HANDLE out = GetStdHandle(STD_OUTPUT_HANDLE); SetConsoleCursorPosition(out, a); } void SetPos(int i, int j)// set cursor { COORD pos = { i, j }; SetPos(pos); } void show()//打开dat文件并输出到界面上 { system(&quot;cls&quot;); ct = 1; a.open(datfile, ios_base::binary | ios_base::in); if (a.is_open()) { cout &lt;&lt; &quot;\\t\\t\\t学生信息表:\\n\\n&quot;; cout &lt;&lt; &quot;序号\\t学号\\t\\t姓名\\t性别\\tC++\\t英语\\t高等数学&quot; &lt;&lt; endl; while (a.read((char *)&amp;students, sizeof students)) { cout &lt;&lt; ct++ &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; students.Number &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Name &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Sex &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Clanguage &lt;&lt; &quot;\\t&quot; &lt;&lt; students.English &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Math &lt;&lt; endl; } a.close(); } else { cout &lt;&lt; &quot;\\a信息加载失败!请初始化后重试！&quot;; } } /*************************** *****输出为录入信息模块***** *************************/ void input() { system(&quot;cls&quot;); b.open(datfile, ios_base::binary | ios_base::out | ios_base::app); if (!b.is_open()) { cout &lt;&lt; &quot;\\a文件打开失败,请稍后重试.&quot; &lt;&lt; endl; exit(EXIT_FAILURE); } int c = 1; cout &lt;&lt; &quot;格式:\\t&quot;; cout &lt;&lt; &quot;学号\\t\\t姓名\\t性别\\t\\tC++成绩\\t\\t英语成绩\\t\\t高等数学&quot; &lt;&lt; endl; cout &lt;&lt; &quot; 各项信息间以空格隔开\\n&quot;; while (c) { cin &gt;&gt; students.Number; cin &gt;&gt; students.Name; cin &gt;&gt; students.Sex; cin &gt;&gt; students.Clanguage; cin &gt;&gt; students.English; cin &gt;&gt; students.Math; b.write((char *)&amp;students, sizeof students); cout &lt;&lt; &quot;0 ———— 退出 1 ———— 继续输入:&quot;; cin &gt;&gt; c; } b.close(); } /*************************** *****输出为搜索信息模块***** *************************/ void search()// { system(&quot;cls&quot;); int choose; while (1) { a.open(datfile, ios_base::binary | ios_base::in); cout &lt;&lt; &quot;0 ———— 退出 1 ———— 按姓名查找 2 ———— 按学号查找\\n&quot;; cin &gt;&gt; choose; string name; string num; if (choose == 0) { a.close(); return; } if (choose == 1) { cout &lt;&lt; &quot;请输入查找姓名:&quot;; cin &gt;&gt; name; } if (choose == 2) { cout &lt;&lt; &quot;请输入查找学号&quot;; cin &gt;&gt; num; } if (a.is_open()) { int flag = 0;//判断是否找到 cout &lt;&lt; &quot;学号\\t姓名\\t性别\\tC++\\t英语\\t高等数学&quot; &lt;&lt; endl; while (a.read((char *)&amp;students, sizeof students)) { if (choose == 1 &amp;&amp; students.Name == name) { cout &lt;&lt; students.Number &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Name &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Sex &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Clanguage &lt;&lt; &quot;\\t&quot; &lt;&lt; students.English &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Math &lt;&lt; endl; flag = 1; } if (choose == 2 &amp;&amp; students.Number == num) { cout &lt;&lt; students.Number &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Name &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Sex &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Clanguage &lt;&lt; &quot;\\t&quot; &lt;&lt; students.English &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Math &lt;&lt; endl; flag = 1; } } if (flag == 0) { cout &lt;&lt; &quot;查询不到此信息！\\n&quot;; } } else { cout &lt;&lt; &quot;\\a信息加载失败!请初始化后重试！&quot;; } a.close(); } } /*************************** *****输出为本地txt文件***** *************************/ void print() { system(&quot;cls&quot;); a.open(datfile, ios_base::binary | ios_base::in); if (a.is_open()) { cout &lt;&lt; &quot;文件名:&quot; &lt;&lt; txtfile &lt;&lt; &quot;,是否修改文件名？\\n&quot;; cout &lt;&lt; &quot; /\\\\ 0 ———— 是&quot; &lt;&lt; endl; cout &lt;&lt; &quot; /!!\\\\ 1 ———— 否&quot; &lt;&lt; endl; cout &lt;&lt; &quot;/ \\\\若文件夹中出现同名文件,可能将其覆盖.\\n&quot; &lt;&lt; &quot;￣￣￣\\n&quot;; int answer; while (1)//修改文件名 { cin &gt;&gt; answer; if (answer == 1) { cout &lt;&lt; &quot;请输入文件名 (不要加后缀）:&quot;; cin &gt;&gt; file; d.open((file + endline), ios_base::out); break; } else if (answer == 0) { d.open(txtfile, ios_base::out); break; } else { cout &lt;&lt; &quot;输入错误,请重新输入!\\n&quot;; continue; } } if (d.is_open()) { d &lt;&lt; &quot;学号\\t姓名\\t性别\\t\\tC++\\t\\t英语\\t\\t高等数学\\n&quot;; while (a.read((char *)&amp;students, sizeof students)) { d &lt;&lt; students.Number &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Name &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Sex &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; students.Clanguage &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; students.English &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; students.Math &lt;&lt; endl; } cout &lt;&lt; &quot;保存成功!&quot;; cout &lt;&lt; &quot;您的文件名为&quot; &lt;&lt; (answer == 1 ? (file + endline) : txtfile); cout &lt;&lt; &quot;请及时提取相关文件，以免文件失效或损坏\\n&quot;; d.close(); } a.close(); } else { cout &lt;&lt; &quot;\\a文件载入失败,请稍后重试.\\n&quot;; } } /*************************** *****以下为界面加载动画***** **************************/ void load() { system(&quot;pause&quot;); system(&quot;cls&quot;); SetPos(50, 14); string LOAD = &quot;加载中&quot;; cout &lt;&lt; LOAD; for (int i = 0; i &lt; 6; i++) { Sleep(150); cout &lt;&lt; &quot;.&quot;; } system(&quot;cls&quot;); } /*************************** *****以下为修改信息模块***** *************************/ void modify()//修改 { fstream a_1; a_1.open(datfile, ios_base::in | ios_base::out | ios_base::binary); if (a_1.is_open()) { int point;//想修改的数字 int end = 1; while (end) { show(); cout &lt;&lt; &quot;0 ———— 退出&quot;; cout &lt;&lt; &quot;请输入对应序号:&quot;; cin &gt;&gt; point; if (point &gt;= 1 &amp;&amp; point &lt;= ct - 1) { streampos place = (point - 1) * sizeof students; a_1.seekg(place); if (a_1.fail()) { cout &lt;&lt; &quot;查找错误...\\n&quot;; exit(EXIT_FAILURE); } a_1.read((char *)&amp;students, sizeof students); cout &lt;&lt; &quot;您即将修改的信息如下:\\n&quot;; cout &lt;&lt; point &lt;&lt; &quot;\\t\\t&quot; &lt;&lt; students.Number &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Name &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Sex &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Clanguage &lt;&lt; &quot;\\t&quot; &lt;&lt; students.English &lt;&lt; &quot;\\t&quot; &lt;&lt; students.Math &lt;&lt; endl; if (a_1.eof()) { a_1.clear(); } cout &lt;&lt; &quot;学号:________\\b\\b\\b\\b\\b\\b&quot;; cin &gt;&gt; students.Number; cout &lt;&lt; &quot;姓名:________\\b\\b\\b\\b\\b\\b&quot;; cin &gt;&gt; students.Name; cout &lt;&lt; &quot;性别:___\\b\\b\\b&quot;; cin &gt;&gt; students.Sex; cout &lt;&lt; &quot;C++:___\\b\\b\\b&quot;; cin &gt;&gt; students.Clanguage; cout &lt;&lt; &quot;英语:___\\b\\b\\b&quot;; cin &gt;&gt; students.English; cout &lt;&lt; &quot;高等数学:___\\b\\b\\b&quot;; cin &gt;&gt; students.Math; a_1.seekp(place); a_1.write((char *)&amp;students, sizeof students); if (a_1.fail()) { cout &lt;&lt; &quot;写入错误\\n&quot;; exit(EXIT_FAILURE); } show(); cout &lt;&lt; &quot;是否继续修改？\\n&quot; &lt;&lt; &quot;0 ———— 退出 1 ———— 继续&quot;; cin &gt;&gt; end; if (end == 0) a_1.close(); system(&quot;cls&quot;); } else if (point == 0) { a_1.close(); return; } else { cout &lt;&lt; &quot;\\a输入的数字不在有效范围&quot; &lt;&lt; &quot;(&quot; &lt;&lt; 1 &lt;&lt; &quot;~&quot; &lt;&lt; ct - 1 &lt;&lt; &quot;)&quot; &lt;&lt; &quot;内,请重新输入.\\n&quot;; system(&quot;pause&quot;); system(&quot;cls&quot;); } } } else { cout &lt;&lt; &quot;\\a无法打开&quot; &lt;&lt; datfile &lt;&lt; endl; } } /*************************** *****以下为菜单操作子模块*** *************************/ void menu_flash() { for (int i = 12; i &lt;= 18; i++) { SetPos(42, i); cout &lt;&lt; &quot; &quot;; } } /*************************** *****以下为菜单操作模块***** **************************/ int menu_choose() { int j = 13; while (1) { if (_kbhit()) { char x = _getch(); switch (x) { case &apos;w&apos;: { if (j == 13 || j == 14 || j == 15 || j == 16 || j == 17 || j == 18 || j == 19) { menu_flash(); j = j - 1; SetPos(42, j); cout &lt;&lt; &quot;&gt;&gt;&quot;; } else if (j == 12 &amp;&amp; x == &apos;w&apos;) { j = 19; } break; } case &apos;s&apos;: { if (j == 11 || j == 12 || j == 13 || j == 14 || j == 15 || j == 16 || j == 17) { menu_flash(); j = j + 1; SetPos(42, j); cout &lt;&lt; &quot;&gt;&gt;&quot;; } else if (j == 18 &amp;&amp; x == &apos;s&apos;) { j = 11; } break; } case &apos;k&apos;: { return j - 11; } } } } } void theme() { system(&quot;cls&quot;); cout &lt;&lt; &quot;0.退出\\n1.黄色\\n2.绿色\\n3.典雅白\\n4.经典黑(默认)\\n&quot;; cout &lt;&lt; &quot;请选择:&quot;; int i; cin &gt;&gt; i; switch (i) { case 4: { cout &lt;&lt; &quot;经典黑&quot;; system(&quot;color 07&quot;);//黑底白字 system(&quot;pause&quot;); break; } case 3: { cout &lt;&lt; &quot;典雅白&quot;; system(&quot;color F0&quot;);//白底黑字 system(&quot;pause&quot;); break; } case 2: { cout &lt;&lt; &quot;绿色&quot;; system(&quot;color 0A&quot;);//黑的浅绿 system(&quot;pause&quot;); break; } case 1: { cout &lt;&lt; &quot;黄色&quot;; system(&quot;color E0&quot;);//浅黄底黑字 system(&quot;pause&quot;); break; } case 0: return; } } /*************************** *******以下为菜单界面******* **************************/ void menu() { system(&quot;cls&quot;); SetPos(43, 5); string title = &quot;学生成绩管理系统&quot;; for (int i = 0; i &lt; title.size(); i++) { Sleep(40); cout &lt;&lt; title[i]; } SetPos(12, 7); cout &lt;&lt; &quot; ______________________________________________________________________________ &quot;; SetPos(12, 8); cout &lt;&lt; &quot;| w : 上 s : 下 k : 确认 |&quot;; for (int i = 9; i &lt;= 10; i++) { SetPos(12, i); cout &lt;&lt; &quot;| |&quot;; } SetPos(12, 11); cout &lt;&lt; &quot;| *************************************************************************** |&quot;; SetPos(12, 12); cout &lt;&lt; &quot;| ************************ 1.录入信息 ****************************** |&quot;; SetPos(12, 13); cout &lt;&lt; &quot;| ************************ 2.查看信息 ****************************** |&quot;; SetPos(12, 14); cout &lt;&lt; &quot;| ************************ 3.修改信息 ****************************** |&quot;; SetPos(12, 15); cout &lt;&lt; &quot;| ************************ 4.打印文件 ****************************** |&quot;; SetPos(12, 16); cout &lt;&lt; &quot;| ************************ 5. 搜索 ****************************** |&quot;; SetPos(12, 17); cout &lt;&lt; &quot;| ************************ 6. 主题 ****************************** |&quot;; SetPos(12, 18); cout &lt;&lt; &quot;| ************************ 7. 关于 ****************************** |&quot;; SetPos(12, 19); cout &lt;&lt; &quot;| *************************************************************************** |&quot;; for (int i = 20; i &lt;= 22; i++) { SetPos(12, i); cout &lt;&lt; &quot;| |&quot;; } SetPos(12, 23); cout &lt;&lt; &quot; ￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣￣ &quot;; } /***************** **开局动画之一**** ****************/ void help() { Sleep(100); system(&quot;cls&quot;); system(&quot;color 0E&quot;); SetPos(12, 7); cout &lt;&lt; &quot;☆☆★★★★★★★★★★★★★★★★★★★☆☆&quot;; SetPos(12, 8); cout &lt;&lt; &quot;☆★ ★☆&quot;; SetPos(12, 9); cout &lt;&lt; &quot;☆★ ★★★ ★★★ ★☆&quot;; SetPos(12, 10); cout &lt;&lt; &quot;☆★ ★☆☆☆★☆★☆☆☆★ ★☆ &quot;; SetPos(12, 11); cout &lt;&lt; &quot;☆★ ★★ ★★☆☆☆★☆☆☆☆★ ★☆&quot;; SetPos(12, 12); cout &lt;&lt; &quot;☆★ ★☆☆★ ★★☆★☆☆☆☆☆☆☆★ ★☆ &quot;; SetPos(12, 13); cout &lt;&lt; &quot;☆★ ★☆☆☆★☆☆★★☆☆☆☆☆☆★ ★☆ &quot;; SetPos(12, 14); cout &lt;&lt; &quot;☆★ ★☆☆☆☆☆★★☆☆☆☆☆★ ★☆&quot;; SetPos(12, 15); cout &lt;&lt; &quot;☆★ ★☆☆☆★ ★☆☆☆★ ★☆ &quot;; SetPos(12, 16); cout &lt;&lt; &quot;☆★ ★☆★ ★ ★☆ &quot;; SetPos(12, 17); cout &lt;&lt; &quot;☆★ ★ ★☆ &quot;; SetPos(12, 18); cout &lt;&lt; &quot;☆★ Ich/liebe/dich制作 ★☆&quot;; SetPos(12, 19); cout &lt;&lt; &quot;☆☆★★★★★★★★★★★★★★★★★★★☆☆★★★&quot;; Sleep(1000); system(&quot;cls&quot;); system(&quot;color 0F&quot;); }3.main.cpp #include &quot;student.h&quot; void main() { system(&quot;title 学生成绩管理系统&quot;); cout &lt;&lt; right; help(); while (1) { load(); menu(); int k = menu_choose(); switch (k) { case 1: { input(); break; } { case 2: show(); break; } case 3: { modify(); break; } case 4: { print(); break; } case 5: { search(); break; } case 6: { theme(); break; } case 7: help(); } } }","link":"/2018/12/28/学生成绩管理系统（简易本地版）/"}],"tags":[{"name":"b'2048'","slug":"b-2048","link":"/tags/b-2048/"},{"name":"b'2048 Easyx'","slug":"b-2048-Easyx","link":"/tags/b-2048-Easyx/"},{"name":"b'\\xe6\\x84\\x9f\\xe6\\x83\\xb3'","slug":"b-xe6-x84-x9f-xe6-x83-xb3","link":"/tags/b-xe6-x84-x9f-xe6-x83-xb3/"},{"name":"b'Leetcode231 2\\xe7\\x9a\\x84\\xe5\\xb9\\x82'","slug":"b-Leetcode231-2-xe7-x9a-x84-xe5-xb9-x82","link":"/tags/b-Leetcode231-2-xe7-x9a-x84-xe5-xb9-x82/"},{"name":"b'\\xe6\\xa8\\xa1\\xe6\\x9d\\xbf\\xe7\\xb1\\xbb'","slug":"b-xe6-xa8-xa1-xe6-x9d-xbf-xe7-xb1-xbb","link":"/tags/b-xe6-xa8-xa1-xe6-x9d-xbf-xe7-xb1-xbb/"},{"name":"b'\\xe5\\x8d\\x95\\xe9\\x93\\xbe\\xe8\\xa1\\xa8'","slug":"b-xe5-x8d-x95-xe9-x93-xbe-xe8-xa1-xa8","link":"/tags/b-xe5-x8d-x95-xe9-x93-xbe-xe8-xa1-xa8/"},{"name":"b'C++\\xe5\\x87\\xbd\\xe6\\x95\\xb0'","slug":"b-C-xe5-x87-xbd-xe6-x95-xb0","link":"/tags/b-C-xe5-x87-xbd-xe6-x95-xb0/"},{"name":"b'\\xe6\\x89\\x8b\\xe5\\x86\\x99LinkedList'","slug":"b-xe6-x89-x8b-xe5-x86-x99LinkedList","link":"/tags/b-xe6-x89-x8b-xe5-x86-x99LinkedList/"},{"name":"b'Java'","slug":"b-Java","link":"/tags/b-Java/"},{"name":"b'java\\xe5\\x8c\\x85'","slug":"b-java-xe5-x8c-x85","link":"/tags/b-java-xe5-x8c-x85/"},{"name":"b'Java\\xe6\\x95\\xb0\\xe7\\xbb\\x84'","slug":"b-Java-xe6-x95-xb0-xe7-xbb-x84","link":"/tags/b-Java-xe6-x95-xb0-xe7-xbb-x84/"},{"name":"b'\\xe5\\x8f\\xaa\\xe5\\x87\\xba\\xe7\\x8e\\xb0\\xe4\\xb8\\x80\\xe6\\xac\\xa1\\xe7\\x9a\\x84\\xe6\\x95\\xb0\\xe5\\xad\\x97'","slug":"b-xe5-x8f-xaa-xe5-x87-xba-xe7-x8e-xb0-xe4-xb8-x80-xe6-xac-xa1-xe7-x9a-x84-xe6-x95-xb0-xe5-xad-x97","link":"/tags/b-xe5-x8f-xaa-xe5-x87-xba-xe7-x8e-xb0-xe4-xb8-x80-xe6-xac-xa1-xe7-x9a-x84-xe6-x95-xb0-xe5-xad-x97/"},{"name":"b'Visual Studio 2017\\xe4\\xbf\\xae\\xe6\\x94\\xb9\\xe5\\xad\\x97\\xe4\\xbd\\x93'","slug":"b-Visual-Studio-2017-xe4-xbf-xae-xe6-x94-xb9-xe5-xad-x97-xe4-xbd-x93","link":"/tags/b-Visual-Studio-2017-xe4-xbf-xae-xe6-x94-xb9-xe5-xad-x97-xe4-xbd-x93/"},{"name":"b'Visual Studio 2017\\xe5\\x9b\\xbe\\xe7\\x89\\x87\\xe8\\x83\\x8c\\xe6\\x99\\xaf'","slug":"b-Visual-Studio-2017-xe5-x9b-xbe-xe7-x89-x87-xe8-x83-x8c-xe6-x99-xaf","link":"/tags/b-Visual-Studio-2017-xe5-x9b-xbe-xe7-x89-x87-xe8-x83-x8c-xe6-x99-xaf/"},{"name":"b'css \\xe5\\xb8\\xb8\\xe8\\xa7\\x81\\xe9\\x97\\xae\\xe9\\xa2\\x98'","slug":"b-css-xe5-xb8-xb8-xe8-xa7-x81-xe9-x97-xae-xe9-xa2-x98","link":"/tags/b-css-xe5-xb8-xb8-xe8-xa7-x81-xe9-x97-xae-xe9-xa2-x98/"},{"name":"b'poj 1005'","slug":"b-poj-1005","link":"/tags/b-poj-1005/"},{"name":"b'poj 1003'","slug":"b-poj-1003","link":"/tags/b-poj-1003/"},{"name":"b'\\xe4\\xb8\\x80\\xe7\\xbb\\xb4\\xe5\\xa4\\x9a\\xe9\\xa1\\xb9\\xe5\\xbc\\x8f\\xe6\\xb1\\x82\\xe5\\x80\\xbc'","slug":"b-xe4-xb8-x80-xe7-xbb-xb4-xe5-xa4-x9a-xe9-xa1-xb9-xe5-xbc-x8f-xe6-xb1-x82-xe5-x80-xbc","link":"/tags/b-xe4-xb8-x80-xe7-xbb-xb4-xe5-xa4-x9a-xe9-xa1-xb9-xe5-xbc-x8f-xe6-xb1-x82-xe5-x80-xbc/"},{"name":"b'\\xe5\\xa4\\xa7\\xe6\\x95\\xb4\\xe6\\x95\\xb0\\xe5\\x8a\\xa0\\xe6\\xb3\\x95\\xe8\\xbf\\x90\\xe7\\xae\\x97'","slug":"b-xe5-xa4-xa7-xe6-x95-xb4-xe6-x95-xb0-xe5-x8a-xa0-xe6-xb3-x95-xe8-xbf-x90-xe7-xae-x97","link":"/tags/b-xe5-xa4-xa7-xe6-x95-xb4-xe6-x95-xb0-xe5-x8a-xa0-xe6-xb3-x95-xe8-xbf-x90-xe7-xae-x97/"},{"name":"b'\\xe6\\x9c\\x80\\xe5\\xa4\\xa7\\xe5\\x85\\xac\\xe7\\xba\\xa6\\xe6\\x95\\xb0'","slug":"b-xe6-x9c-x80-xe5-xa4-xa7-xe5-x85-xac-xe7-xba-xa6-xe6-x95-xb0","link":"/tags/b-xe6-x9c-x80-xe5-xa4-xa7-xe5-x85-xac-xe7-xba-xa6-xe6-x95-xb0/"},{"name":"b'\\xe6\\x9c\\x80\\xe5\\xb0\\x8f\\xe5\\x85\\xac\\xe5\\x80\\x8d\\xe6\\x95\\xb0'","slug":"b-xe6-x9c-x80-xe5-xb0-x8f-xe5-x85-xac-xe5-x80-x8d-xe6-x95-xb0","link":"/tags/b-xe6-x9c-x80-xe5-xb0-x8f-xe5-x85-xac-xe5-x80-x8d-xe6-x95-xb0/"},{"name":"b'\\xe5\\xae\\x8c\\xe6\\x95\\xb0'","slug":"b-xe5-xae-x8c-xe6-x95-xb0","link":"/tags/b-xe5-xae-x8c-xe6-x95-xb0/"},{"name":"b'\\xe6\\xb0\\xb4\\xe4\\xbb\\x99\\xe8\\x8a\\xb1\\xe6\\x95\\xb0'","slug":"b-xe6-xb0-xb4-xe4-xbb-x99-xe8-x8a-xb1-xe6-x95-xb0","link":"/tags/b-xe6-xb0-xb4-xe4-xbb-x99-xe8-x8a-xb1-xe6-x95-xb0/"},{"name":"b'\\xe5\\x9b\\x9e\\xe6\\x96\\x87\\xe6\\x95\\xb0'","slug":"b-xe5-x9b-x9e-xe6-x96-x87-xe6-x95-xb0","link":"/tags/b-xe5-x9b-x9e-xe6-x96-x87-xe6-x95-xb0/"},{"name":"b'\\xe7\\xb4\\xa0\\xe6\\x95\\xb0'","slug":"b-xe7-xb4-xa0-xe6-x95-xb0","link":"/tags/b-xe7-xb4-xa0-xe6-x95-xb0/"},{"name":"b'\\xe6\\x9c\\x80\\xe5\\xa4\\xa7\\xe5\\x85\\xac\\xe7\\xba\\xa6\\xe6\\x95\\xb0\\xe4\\xb8\\x8e\\xe6\\x9c\\x80\\xe5\\xb0\\x8f\\xe5\\x85\\xac\\xe5\\x80\\x8d\\xe6\\x95\\xb0'","slug":"b-xe6-x9c-x80-xe5-xa4-xa7-xe5-x85-xac-xe7-xba-xa6-xe6-x95-xb0-xe4-xb8-x8e-xe6-x9c-x80-xe5-xb0-x8f-xe5-x85-xac-xe5-x80-x8d-xe6-x95-xb0","link":"/tags/b-xe6-x9c-x80-xe5-xa4-xa7-xe5-x85-xac-xe7-xba-xa6-xe6-x95-xb0-xe4-xb8-x8e-xe6-x9c-x80-xe5-xb0-x8f-xe5-x85-xac-xe5-x80-x8d-xe6-x95-xb0/"},{"name":"b'Java\\xe5\\xad\\x97\\xe7\\xac\\xa6\\xe4\\xb8\\xb2'","slug":"b-Java-xe5-xad-x97-xe7-xac-xa6-xe4-xb8-xb2","link":"/tags/b-Java-xe5-xad-x97-xe7-xac-xa6-xe4-xb8-xb2/"}],"categories":[{"name":"b'2048'","slug":"b-2048","link":"/categories/b-2048/"},{"name":"b'Leetcode231 2\\xe7\\x9a\\x84\\xe5\\xb9\\x82'","slug":"b-Leetcode231-2-xe7-x9a-x84-xe5-xb9-x82","link":"/categories/b-Leetcode231-2-xe7-x9a-x84-xe5-xb9-x82/"},{"name":"b'oj - selftrain'","slug":"b-oj-selftrain","link":"/categories/b-oj-selftrain/"},{"name":"b'Java EE'","slug":"b-Java-EE","link":"/categories/b-Java-EE/"},{"name":"b'2048 Easyx'","slug":"b-2048/b-2048-Easyx","link":"/categories/b-2048/b-2048-Easyx/"},{"name":"b'Review'","slug":"b-Review","link":"/categories/b-Review/"},{"name":"b'C++'","slug":"b-C","link":"/categories/b-C/"},{"name":"b'\\xe6\\xa8\\xa1\\xe6\\x9d\\xbf\\xe7\\xb1\\xbb'","slug":"b-xe6-xa8-xa1-xe6-x9d-xbf-xe7-xb1-xbb","link":"/categories/b-xe6-xa8-xa1-xe6-x9d-xbf-xe7-xb1-xbb/"},{"name":"b'Spring'","slug":"b-Java-EE/b-Spring","link":"/categories/b-Java-EE/b-Spring/"},{"name":"b'C++\\xe5\\x87\\xbd\\xe6\\x95\\xb0'","slug":"b-C-xe5-x87-xbd-xe6-x95-xb0","link":"/categories/b-C-xe5-x87-xbd-xe6-x95-xb0/"},{"name":"b'\\xe6\\x84\\x9f\\xe6\\x83\\xb3'","slug":"b-2048/b-2048-Easyx/b-xe6-x84-x9f-xe6-x83-xb3","link":"/categories/b-2048/b-2048-Easyx/b-xe6-x84-x9f-xe6-x83-xb3/"},{"name":"b'Strange'","slug":"b-Strange","link":"/categories/b-Strange/"},{"name":"b'Java'","slug":"b-Java","link":"/categories/b-Java/"},{"name":"b'\\xe5\\x8d\\x95\\xe9\\x93\\xbe\\xe8\\xa1\\xa8'","slug":"b-xe6-xa8-xa1-xe6-x9d-xbf-xe7-xb1-xbb/b-xe5-x8d-x95-xe9-x93-xbe-xe8-xa1-xa8","link":"/categories/b-xe6-xa8-xa1-xe6-x9d-xbf-xe7-xb1-xbb/b-xe5-x8d-x95-xe9-x93-xbe-xe8-xa1-xa8/"},{"name":"b'\\xe6\\x89\\x8b\\xe5\\x86\\x99LinkedList'","slug":"b-xe6-x89-x8b-xe5-x86-x99LinkedList","link":"/categories/b-xe6-x89-x8b-xe5-x86-x99LinkedList/"},{"name":"b'JavaScript'","slug":"b-JavaScript","link":"/categories/b-JavaScript/"},{"name":"b'java\\xe5\\x8c\\x85'","slug":"b-java-xe5-x8c-x85","link":"/categories/b-java-xe5-x8c-x85/"},{"name":"b'Java\\xe6\\x95\\xb0\\xe7\\xbb\\x84'","slug":"b-Java-xe6-x95-xb0-xe7-xbb-x84","link":"/categories/b-Java-xe6-x95-xb0-xe7-xbb-x84/"},{"name":"b'Leetcode'","slug":"b-Leetcode","link":"/categories/b-Leetcode/"},{"name":"b'\\xe5\\x8f\\xaa\\xe5\\x87\\xba\\xe7\\x8e\\xb0\\xe4\\xb8\\x80\\xe6\\xac\\xa1\\xe7\\x9a\\x84\\xe6\\x95\\xb0\\xe5\\xad\\x97'","slug":"b-xe5-x8f-xaa-xe5-x87-xba-xe7-x8e-xb0-xe4-xb8-x80-xe6-xac-xa1-xe7-x9a-x84-xe6-x95-xb0-xe5-xad-x97","link":"/categories/b-xe5-x8f-xaa-xe5-x87-xba-xe7-x8e-xb0-xe4-xb8-x80-xe6-xac-xa1-xe7-x9a-x84-xe6-x95-xb0-xe5-xad-x97/"},{"name":"b'MySQL'","slug":"b-MySQL","link":"/categories/b-MySQL/"},{"name":"b'problems'","slug":"b-problems","link":"/categories/b-problems/"},{"name":"b'Java'","slug":"b-xe6-x89-x8b-xe5-x86-x99LinkedList/b-Java","link":"/categories/b-xe6-x89-x8b-xe5-x86-x99LinkedList/b-Java/"},{"name":"b'problems'","slug":"b-Java-EE/b-problems","link":"/categories/b-Java-EE/b-problems/"},{"name":"b'Visual Studio 2017\\xe4\\xbf\\xae\\xe6\\x94\\xb9\\xe5\\xad\\x97\\xe4\\xbd\\x93'","slug":"b-Visual-Studio-2017-xe4-xbf-xae-xe6-x94-xb9-xe5-xad-x97-xe4-xbd-x93","link":"/categories/b-Visual-Studio-2017-xe4-xbf-xae-xe6-x94-xb9-xe5-xad-x97-xe4-xbd-x93/"},{"name":"b'css \\xe5\\xb8\\xb8\\xe8\\xa7\\x81\\xe9\\x97\\xae\\xe9\\xa2\\x98'","slug":"b-css-xe5-xb8-xb8-xe8-xa7-x81-xe9-x97-xae-xe9-xa2-x98","link":"/categories/b-css-xe5-xb8-xb8-xe8-xa7-x81-xe9-x97-xae-xe9-xa2-x98/"},{"name":"b'poj 1005'","slug":"b-poj-1005","link":"/categories/b-poj-1005/"},{"name":"b'poj 1003'","slug":"b-poj-1003","link":"/categories/b-poj-1003/"},{"name":"b'Strange'","slug":"b-Java/b-Strange","link":"/categories/b-Java/b-Strange/"},{"name":"b'\\xe4\\xb8\\x80\\xe7\\xbb\\xb4\\xe5\\xa4\\x9a\\xe9\\xa1\\xb9\\xe5\\xbc\\x8f\\xe6\\xb1\\x82\\xe5\\x80\\xbc'","slug":"b-xe4-xb8-x80-xe7-xbb-xb4-xe5-xa4-x9a-xe9-xa1-xb9-xe5-xbc-x8f-xe6-xb1-x82-xe5-x80-xbc","link":"/categories/b-xe4-xb8-x80-xe7-xbb-xb4-xe5-xa4-x9a-xe9-xa1-xb9-xe5-xbc-x8f-xe6-xb1-x82-xe5-x80-xbc/"},{"name":"b'Algorithm'","slug":"b-Algorithm","link":"/categories/b-Algorithm/"},{"name":"b'\\xe5\\xa4\\xa7\\xe6\\x95\\xb4\\xe6\\x95\\xb0\\xe5\\x8a\\xa0\\xe6\\xb3\\x95\\xe8\\xbf\\x90\\xe7\\xae\\x97'","slug":"b-xe5-xa4-xa7-xe6-x95-xb4-xe6-x95-xb0-xe5-x8a-xa0-xe6-xb3-x95-xe8-xbf-x90-xe7-xae-x97","link":"/categories/b-xe5-xa4-xa7-xe6-x95-xb4-xe6-x95-xb0-xe5-x8a-xa0-xe6-xb3-x95-xe8-xbf-x90-xe7-xae-x97/"},{"name":"b'\\xe6\\x9c\\x80\\xe5\\xa4\\xa7\\xe5\\x85\\xac\\xe7\\xba\\xa6\\xe6\\x95\\xb0'","slug":"b-xe6-x9c-x80-xe5-xa4-xa7-xe5-x85-xac-xe7-xba-xa6-xe6-x95-xb0","link":"/categories/b-xe6-x9c-x80-xe5-xa4-xa7-xe5-x85-xac-xe7-xba-xa6-xe6-x95-xb0/"},{"name":"b'\\xe5\\xae\\x8c\\xe6\\x95\\xb0'","slug":"b-xe5-xae-x8c-xe6-x95-xb0","link":"/categories/b-xe5-xae-x8c-xe6-x95-xb0/"},{"name":"b'Visual Studio 2017\\xe5\\x9b\\xbe\\xe7\\x89\\x87\\xe8\\x83\\x8c\\xe6\\x99\\xaf'","slug":"b-Visual-Studio-2017-xe4-xbf-xae-xe6-x94-xb9-xe5-xad-x97-xe4-xbd-x93/b-Visual-Studio-2017-xe5-x9b-xbe-xe7-x89-x87-xe8-x83-x8c-xe6-x99-xaf","link":"/categories/b-Visual-Studio-2017-xe4-xbf-xae-xe6-x94-xb9-xe5-xad-x97-xe4-xbd-x93/b-Visual-Studio-2017-xe5-x9b-xbe-xe7-x89-x87-xe8-x83-x8c-xe6-x99-xaf/"},{"name":"b'\\xe6\\x9c\\x80\\xe5\\xb0\\x8f\\xe5\\x85\\xac\\xe5\\x80\\x8d\\xe6\\x95\\xb0'","slug":"b-xe6-x9c-x80-xe5-xa4-xa7-xe5-x85-xac-xe7-xba-xa6-xe6-x95-xb0/b-xe6-x9c-x80-xe5-xb0-x8f-xe5-x85-xac-xe5-x80-x8d-xe6-x95-xb0","link":"/categories/b-xe6-x9c-x80-xe5-xa4-xa7-xe5-x85-xac-xe7-xba-xa6-xe6-x95-xb0/b-xe6-x9c-x80-xe5-xb0-x8f-xe5-x85-xac-xe5-x80-x8d-xe6-x95-xb0/"},{"name":"b'\\xe6\\xb0\\xb4\\xe4\\xbb\\x99\\xe8\\x8a\\xb1\\xe6\\x95\\xb0'","slug":"b-xe5-xae-x8c-xe6-x95-xb0/b-xe6-xb0-xb4-xe4-xbb-x99-xe8-x8a-xb1-xe6-x95-xb0","link":"/categories/b-xe5-xae-x8c-xe6-x95-xb0/b-xe6-xb0-xb4-xe4-xbb-x99-xe8-x8a-xb1-xe6-x95-xb0/"},{"name":"b'\\xe5\\x9b\\x9e\\xe6\\x96\\x87\\xe6\\x95\\xb0'","slug":"b-xe5-xae-x8c-xe6-x95-xb0/b-xe6-xb0-xb4-xe4-xbb-x99-xe8-x8a-xb1-xe6-x95-xb0/b-xe5-x9b-x9e-xe6-x96-x87-xe6-x95-xb0","link":"/categories/b-xe5-xae-x8c-xe6-x95-xb0/b-xe6-xb0-xb4-xe4-xbb-x99-xe8-x8a-xb1-xe6-x95-xb0/b-xe5-x9b-x9e-xe6-x96-x87-xe6-x95-xb0/"},{"name":"b'\\xe7\\xb4\\xa0\\xe6\\x95\\xb0'","slug":"b-xe5-xae-x8c-xe6-x95-xb0/b-xe6-xb0-xb4-xe4-xbb-x99-xe8-x8a-xb1-xe6-x95-xb0/b-xe5-x9b-x9e-xe6-x96-x87-xe6-x95-xb0/b-xe7-xb4-xa0-xe6-x95-xb0","link":"/categories/b-xe5-xae-x8c-xe6-x95-xb0/b-xe6-xb0-xb4-xe4-xbb-x99-xe8-x8a-xb1-xe6-x95-xb0/b-xe5-x9b-x9e-xe6-x96-x87-xe6-x95-xb0/b-xe7-xb4-xa0-xe6-x95-xb0/"},{"name":"b'\\xe6\\x9c\\x80\\xe5\\xa4\\xa7\\xe5\\x85\\xac\\xe7\\xba\\xa6\\xe6\\x95\\xb0\\xe4\\xb8\\x8e\\xe6\\x9c\\x80\\xe5\\xb0\\x8f\\xe5\\x85\\xac\\xe5\\x80\\x8d\\xe6\\x95\\xb0'","slug":"b-xe5-xae-x8c-xe6-x95-xb0/b-xe6-xb0-xb4-xe4-xbb-x99-xe8-x8a-xb1-xe6-x95-xb0/b-xe5-x9b-x9e-xe6-x96-x87-xe6-x95-xb0/b-xe7-xb4-xa0-xe6-x95-xb0/b-xe6-x9c-x80-xe5-xa4-xa7-xe5-x85-xac-xe7-xba-xa6-xe6-x95-xb0-xe4-xb8-x8e-xe6-x9c-x80-xe5-xb0-x8f-xe5-x85-xac-xe5-x80-x8d-xe6-x95-xb0","link":"/categories/b-xe5-xae-x8c-xe6-x95-xb0/b-xe6-xb0-xb4-xe4-xbb-x99-xe8-x8a-xb1-xe6-x95-xb0/b-xe5-x9b-x9e-xe6-x96-x87-xe6-x95-xb0/b-xe7-xb4-xa0-xe6-x95-xb0/b-xe6-x9c-x80-xe5-xa4-xa7-xe5-x85-xac-xe7-xba-xa6-xe6-x95-xb0-xe4-xb8-x8e-xe6-x9c-x80-xe5-xb0-x8f-xe5-x85-xac-xe5-x80-x8d-xe6-x95-xb0/"},{"name":"b'Java\\xe5\\xad\\x97\\xe7\\xac\\xa6\\xe4\\xb8\\xb2'","slug":"b-Java-xe5-xad-x97-xe7-xac-xa6-xe4-xb8-xb2","link":"/categories/b-Java-xe5-xad-x97-xe7-xac-xa6-xe4-xb8-xb2/"},{"name":"b'Algorithm'","slug":"b-Strange/b-Algorithm","link":"/categories/b-Strange/b-Algorithm/"},{"name":"b'Strange'","slug":"b-C/b-Strange","link":"/categories/b-C/b-Strange/"}]}